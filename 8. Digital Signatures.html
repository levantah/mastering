<!DOCTYPE html>
<html><head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <base target="_blank">
  <style>
/* latin */
@font-face {
  font-family: 'Comic Neue';
  font-style: normal;
  font-weight: 400;
  src: url(fonts/4UaHrEJDsxBrF37olUeD96rp57F2IwM.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
/* latin */
@font-face {
  font-family: 'Lexend Deca';
  font-style: normal;
  font-weight: 400;
  src: url(fonts/K2FifZFYk-dHSE0UPPuwQ7CrD94i-NCKm-U48M1wqxnDirZPl3v-.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
/* latin */
@font-face {
  font-family: 'Poppins';
  font-style: normal;
  font-weight: 400;
  src: url(fonts/pxiEyp8kv8JHgFVrJJfecnFHGPc.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

:root {
  --fg: #000; /* foreground  */
  --bg: #fff; /* background  */
  --bd: #000; /* border  */
  --lk: #006fa5; /* link */
  --lkv: #d33bf0; /* link visited */
  --hg: #ffff81; /* highlight  */
}
html {
  overflow: overlay;
}
body {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  margin: 30px auto 0 auto;
  padding: 10px;
  position: relative;

  color: var(--fg);
  border-color: var(--bd);
  background-color: var(--bg);
}
body[data-mode$="dark"] {
  --lk: #0096de;
}
body[data-mode="light"] {
  color-scheme: light;
  --fg: #222;
  --bd: #222;
  --bg: whitesmoke;
}
body[data-mode="dark"] {
  color-scheme: dark;
  --fg: #eee;
  --bd: #eee;
  --bg: #333;
}
body[data-mode="sepia"] {
  color-scheme: light;
  --fg: #5b4636;
  --bd: #5b4636;
  --bg: #f4ecd8;
}
body[data-mode="solarized-light"] {
  color-scheme: light;
  --fg: #586e75;
  --bd: #586e75;
  --bg: #fdf6e3;
}
body[data-mode="nord-light"] {
  color-scheme: light;
  --fg: #2e3440;
  --bd: #2e3440;
  --bg: #e5e9f0;
}
body[data-mode="groove-dark"] {
  color-scheme: dark;
  --fg: #cec4ac;
  --bd: #cec4ac;
  --bg: #282828;
}
body[data-mode="solarized-dark"] {
  color-scheme: dark;
  --fg: #839496;
  --bd: #839496;
  --bg: #002b36;
}
body[data-mode="nord-dark"] {
  color-scheme: dark;
  --fg: #e5e9f0;
  --bd: #e5e9f0;
  --bg: #2e3440;
}

@media print {
  body[data-mode] {
    --fg: #000;
    --bd: #000;
    --bg: #fff;

    width: unset;
    padding: 0;
    margin: 0;
  }
}
body[data-loaded=true] {
  
}
img {
  max-width: 100%;
  height: auto;
}
img:not([width])[src$=".svg"] {
  max-width: 100px;
}
body[data-images=false] canvas,
body[data-images=false] svg,
body[data-images=false] img {
  display: none;
}
svg:not([width]):not([height]) {
  max-width: 25vmin;
}
a {
  color: var(--lk);
  text-decoration: none;
}
a:visited {
  color: var(--lkv);
}

hr {
  background-color: var(--bd);
  height: 1px;
  border: 0;
}
#reader-domain {
  font-family: Helvetica, Arial, sans-serif;
  text-decoration: none;
  border-bottom-color: currentcolor;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  width: 100%;
  display: inline-block;
  direction: ltr;
}
#reader-domain > span:first-child {
  font-size: 1.1em;
}
#reader-domain > span:last-child {
  font-size: 0.8em;
}
#reader-title {
  font-size: 1.6em;
  line-height: 1.25em;
  width: 100%;
  margin: 20px 0;
  padding: 0;
}
#reader-credits,
#doi,
#published-time,
#reader-estimated-time {
  font-size: 0.85em;
  line-height: 1.48em;
  margin: 0 0 10px 0;
  padding: 0;
}
#reader-credits:not(:empty)::after {
  content: ' ⋮ ';
}
#published-time:not(:empty)::before {
  content: ' ⋮ ';
}
#doi-json {
  overflow: hidden;
}
#doi-json code {
  overflow: auto;
  max-height: 400px;
}
#published-time:empty,
#reader-credits:empty {
  display: none;
}
mark.hghlght {
  background-color: var(--hg);
}
body:not([data-columns="1"]) .page :is(h1, h2) {
  column-span: all;
  background-color: rgba(125, 125, 125, 0.1);
  padding: 10px;
}
.hidden {
  display: none;
}
</style>
  <style id="user-css">body {
  padding-bottom: 64px;
}
pre {
  white-space: pre-wrap;
}
pre code {
  background-color: #eff0f1;
  color: #393318;
  font-family: monospace;
  display: block;
  padding: 5px 10px;
}
body[data-mode="dark"] pre code {
  background-color: #585858;
  color: #e8e8e8;
}

/* CSS for sans-serif fonts */
body[data-font=sans-serif] {}
/* CSS for serif fonts */
body[data-font=serif] {}

/* CSS for "sepia" theme */
body[data-mode=sepia] {}
/* CSS for "light" theme */
body[data-mode=light] {}
/* CSS for "dark" theme */
body[data-mode=dark] {}</style>
<title>8. Digital Signatures</title><title>8. Digital Signatures :: Reader View</title></head>
<body tabindex="1" data-images="true" data-mode="groove-dark" data-font="serif" data-columns="1" data-loaded="true">
  <span></span> <!-- for IntersectionObserver -->
  <a id="reader-domain" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch08.html">
    <span>learning.oreilly.com</span>
    <span>/library/view/mastering-bitcoin-3rd/9781098150082/ch08.html</span>
  </a>
  <h1 dir="auto" id="reader-title">8. Digital Signatures</h1>
  <span dir="auto" id="reader-credits"></span>
  <span dir="auto" id="reader-estimated-time">43-54 minutes</span>
  <span dir="auto" id="published-time"></span>
  <hr>
  <div id="readability-page-1" class="page"><div id="sbo-rt-content" data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 8. Digital Signatures">
<h2><span>Chapter 8. </span>Digital Signatures</h2>


<p>Two <a data-type="indexterm" data-primary="digital signatures" data-secondary="schnorr signature algorithm" id="id997" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="schnorr signature algorithm" id="id998" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="digital signatures" data-secondary="ECDSA" id="id999" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="ECDSA (Elliptic Curve Digital Signature Algorithm)" id="id1000" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="transactions" data-secondary="signatures" data-see="digital signatures" id="id1001" target="_blank" rel="noopener noreferrer"></a>signature algorithms are currently
used in Bitcoin, the <em>schnorr signature algorithm</em> and the <em>Elliptic
Curve Digital Signature Algorithm</em> (<em>ECDSA</em>).
These algorithms are used for digital signatures based on elliptic
curve private/public key pairs, as described in <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch04.html#elliptic_curve" target="_blank" rel="noopener noreferrer">“Elliptic Curve Cryptography Explained”</a>.
They are used for spending segwit v0 P2WPKH outputs, segwit v1 P2TR
keypath spending, and by the script functions <code>OP_CHECKSIG</code>,
<code>OP_CHECKSIGVERIFY</code>, <code>OP_CHECKMULTISIG</code>, 
<span><code>OP_CHECKMULTISIGVERIFY</code>,</span> and
<code>OP_CHECKSIGADD</code>.
Any time one of those is executed, a signature must be
provided.</p>

<p>A digital signature<a data-type="indexterm" data-primary="digital signatures" data-secondary="purpose of" id="id1002" target="_blank" rel="noopener noreferrer"></a> serves
three purposes in Bitcoin. First, the
signature proves that the controller of a private key, who is by
implication the owner of the funds, has <em>authorized</em> the spending of
those funds. Secondly, the proof of authorization is <em>undeniable</em>
(nonrepudiation). Thirdly, that the authorized transaction cannot be
changed by unauthenticated third parties—​that its <em>integrity</em> is
intact.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Each transaction input and any signatures it may contain is <em>completely</em>
independent of any other input or signature. Multiple parties can
collaborate to construct transactions and sign only one input each.
Several protocols use this fact to create multiparty transactions for
privacy.</p>
</div>

<p>In this chapter we look at how digital signatures work and how they can
present proof of control of a private key without revealing that private
key.</p>






<div id="id413" data-type="sect1" data-pdf-bookmark="How Digital Signatures Work">
<h2>How Digital Signatures Work</h2>

<p>A digital signature
consists of two parts. The first part is an algorithm for creating a
signature for a message (the transaction) using a private key (the
signing key). The second part is an algorithm
that allows anyone to verify the signature, given also the message and the corresponding
public key.</p>








<div id="id136" data-type="sect2" data-pdf-bookmark="Creating a Digital Signature">
<h2>Creating a Digital Signature</h2>

<p>In Bitcoin’s<a data-type="indexterm" data-primary="digital signatures" data-secondary="creating" id="id1003" target="_blank" rel="noopener noreferrer"></a> use of digital signature algorithms, the “message” being
signed is the transaction, or more accurately a hash of a specific
subset of the data in the transaction, <a data-type="indexterm" data-primary="commitment hash" id="id1004" target="_blank" rel="noopener noreferrer"></a>called the <em>commitment hash</em> (see
<a data-type="xref" href="#sighash_types" target="_blank" rel="noopener noreferrer">“Signature Hash Types (SIGHASH)”</a>). The
signing key is the user’s private key. The result is the signature:</p>


<p>where:</p>

<ul>
<li>
<p><em>x</em> is the signing private key</p>
</li>
<li>
<p><em>m</em> is the message to sign, the commitment hash (such as parts of a transaction)</p>
</li>
<li>
<p><em>F</em><sub><em>hash</em></sub> is the hashing function</p>
</li>
<li>
<p><em>F</em><sub><em>sig</em></sub> is the signing algorithm</p>
</li>
<li>
<p><em>Sig</em> is the resulting signature</p>
</li>
</ul>

<p>You can find more details on the mathematics of schnorr and ECDSA signatures in <a data-type="xref" href="#schnorr_signatures" target="_blank" rel="noopener noreferrer">“Schnorr Signatures”</a>
and <a data-type="xref" href="#ecdsa_signatures" target="_blank" rel="noopener noreferrer">“ECDSA Signatures”</a>.</p>

<p>In both schnorr and ECDSA signatures, the function <em>F</em><sub><em>sig</em></sub> produces a signature <code>Sig</code> that is composed of
two values.  There are differences between the two values in the
different algorithms, which we’ll explore later. After the two values
are calculated, they are serialized into a byte stream.  For ECDSA
signatures, the encoding uses an international standard encoding scheme
called the
<em>Distinguished Encoding Rules</em>, or <em>DER</em>.  For schnorr signatures, a
simpler serialization format is used.</p>
</div>








<div id="id259" data-type="sect2" data-pdf-bookmark="Verifying the Signature">
<h2>Verifying the Signature</h2>

<p>The<a data-type="indexterm" data-primary="digital signatures" data-secondary="verifying" id="id1005" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="verifying" data-secondary="digital signatures" id="id1006" target="_blank" rel="noopener noreferrer"></a> signature verification algorithm takes the message (a hash of parts of the transaction and related data), the signer’s public key and the signature, and returns <code>TRUE</code> if the signature is valid for this message and public key.</p>

<p>To verify the signature, one must have the signature, the serialized
transaction, some data about the output being spent, and the public key
that corresponds to the private key used to create the signature.
Essentially, verification of a signature means “Only the controller of
the private key that generated this public key could have produced this
signature on this transaction.”</p>
</div>








<div id="sighash_types" data-type="sect2" data-pdf-bookmark="Signature Hash Types (SIGHASH)">
<h2>Signature Hash Types (SIGHASH)</h2>

<p>Digital signatures<a data-type="indexterm" data-primary="digital signatures" data-secondary="SIGHASH flags" id="digital-signature-sighash" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="SIGHASH flags" id="sighash" target="_blank" rel="noopener noreferrer"></a> apply to messages,
which in the case of Bitcoin, are the transactions themselves. The
signature proves a <em>commitment</em> by the signer to specific transaction
data. In the simplest form, the signature applies to almost the entire
transaction, thereby committing to all the inputs, outputs, and other
transaction fields. However, a signature can commit to only a subset of
the data in a transaction, which is useful for a number of scenarios as
we will see in this section.</p>

<p>Bitcoin signatures have a way of indicating which
part of a transaction’s data is included in the hash signed by the
private key using a <code>SIGHASH</code> flag. The <code>SIGHASH</code> flag is a single byte
that is appended to the signature. Every signature has either an
explicit or implicit <code>SIGHASH</code> flag,
and the flag can be different from input to input. A transaction with
three signed inputs may have three signatures with different <code>SIGHASH</code>
flags, each signature signing (committing) to different parts of the
transaction.</p>

<p>Remember, each input may contain one or more signatures. As
a result, an input may have signatures
with different <code>SIGHASH</code> flags that commit to different parts of the
transaction. Note also that Bitcoin transactions
may contain inputs from different “owners,” who may sign only one input
in a partially constructed transaction, collaborating with
others to gather all the necessary signatures to make a valid
transaction. Many of the <code>SIGHASH</code> flag types only make sense if you
think of multiple participants collaborating outside the Bitcoin network
and updating a partially signed transaction.</p>

<p>There are three <code>SIGHASH</code> flags: <code>ALL</code>, <code>NONE</code>, and <code>SINGLE</code>, as shown
in <a data-type="xref" href="#sighash_types_and_their" target="_blank" rel="noopener noreferrer">Table&nbsp;8-1</a>.</p>
<table id="sighash_types_and_their"><caption><span>Table 8-1. </span>
<span><code>SIGHASH</code></span> types and their meanings</caption><thead><tr><th><code>SIGHASH</code> flag</th><th>Value</th><th>Description</th></tr></thead><tbody><tr><td><p><code>ALL</code></p></td><td><p><code>0x01</code></p></td><td><p>Signature applies to all inputs and outputs</p></td></tr><tr><td><p><code>NONE</code></p></td><td><p><code>0x02</code></p></td><td><p>Signature applies to all inputs, none of the outputs</p></td></tr><tr><td><p><code>SINGLE</code></p></td><td><p><code>0x03</code></p></td><td><p>Signature applies to all inputs but only the one output with the same index number as the signed input</p></td></tr></tbody></table>

<p>In addition, there is a modifier flag, <code>SIGHASH_ANYONECANPAY</code>, which can
be combined with each of the preceding flags. When <code>ANYONECANPAY</code> is
set, only one input is signed, leaving the rest (and their sequence
numbers) open for modification. The <code>ANYONECANPAY</code> has the value <code>0x80</code>
and is applied by bitwise OR, resulting in the combined flags as shown
in <a data-type="xref" href="#sighash_types_with_modifiers" target="_blank" rel="noopener noreferrer">Table&nbsp;8-2</a>.</p>
<table id="sighash_types_with_modifiers"><caption><span>Table 8-2. </span>
<span><code>SIGHASH</code></span> types with modifiers and their meanings</caption><thead><tr><th><code>SIGHASH</code> flag</th><th>Value</th><th>Description</th></tr></thead><tbody><tr><td><p><code>ALL|ANYONECANPAY</code></p></td><td><p><code>0x81</code></p></td><td><p>Signature applies to one input and all outputs</p></td></tr><tr><td><p><code>NONE|ANYONECANPAY</code></p></td><td><p><code>0x82</code></p></td><td><p>Signature applies to one input, none of the outputs</p></td></tr><tr><td><p><code>SINGLE|ANYONECANPAY</code></p></td><td><p><code>0x83</code></p></td><td><p>Signature applies to one input and the output with the same index number</p></td></tr></tbody></table>

<p>The way <code>SIGHASH</code> flags are applied during signing and verification is
that a copy of the transaction is made and certain fields within are
either omitted or truncated (set to zero length and emptied). The resulting transaction is
serialized. The <code>SIGHASH</code> flag is included in the serialized
transaction data and the result is hashed. The hash digest itself is the “message”
that is signed. Depending on which <code>SIGHASH</code> flag is used, different
parts of the transaction are included.
By including the
<code>SIGHASH</code> flag itself, the signature commits the
<code>SIGHASH</code> type as well, so it can’t be changed (e.g., by a miner).</p>

<p>In
<a data-type="xref" href="#serialization_of_signatures_der" target="_blank" rel="noopener noreferrer">“Serialization of ECDSA Signatures (DER)”</a>, we will see that the last part of the
DER-encoded signature was <code>01</code>, which is the <code>SIGHASH_ALL</code> flag for ECDSA signatures. This
locks the transaction data, so Alice’s signature is committing to the state
of all inputs and outputs. This is the most common signature form.</p>

<p>Let’s look at some of the other <code>SIGHASH</code> types and how they can be used
in practice:</p>
<dl>
<dt><code>ALL|ANYONECANPAY</code> </dt>
<dd>
<p>This <a data-type="indexterm" data-primary="crowdfunding" id="id1007" target="_blank" rel="noopener noreferrer"></a>construction can be used to make a
“crowdfunding”-style transaction. Someone attempting to raise
funds can construct a transaction with a single output. The single
output pays the “goal” amount to the fundraiser. Such a transaction is
obviously not valid, as it has no inputs. However, others can now amend
it by adding an input of their own as a donation. They sign their own
input with <code>ALL|ANYONECANPAY</code>. Unless enough inputs are gathered to
reach the value of the output, the transaction is invalid. Each donation
is a “pledge,” which cannot be collected by the fundraiser until the
entire goal amount is raised.  Unfortunately, this protocol can be
circumvented by the fundraiser adding an input of their own (or from
someone who lends them funds), allowing them to collect the donations
even if they haven’t reached the specified value.</p>
</dd>
<dt><code>NONE</code> </dt>
<dd>
<p>This construction can be used to create a “bearer check” or
“blank check” of a specific amount. It commits to all inputs but allows
the outputs to be changed. Anyone can write their own
Bitcoin address into the output script.
By itself, this allows any miner to change
the output destination and claim the funds for themselves, but if other
required signatures in the transaction use <code>SIGHASH_ALL</code> or another type
that commits to the output, it allows those spenders to change the
destination without allowing any third parties (like miners) to modify
the outputs.</p>
</dd>
<dt><code>NONE|ANYONECANPAY</code> </dt>
<dd>
<p>This construction can be used to build a “dust
collector.” Users who have tiny UTXOs in their wallets can’t spend these
without the cost in fees exceeding the value of the UTXO; see
<a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch06.html#uneconomical_outputs" target="_blank" rel="noopener noreferrer">“Uneconomical outputs and disallowed dust”</a>. With this type
of signature, the uneconomical UTXOs can be donated for anyone to aggregate and
spend whenever they want.</p>
</dd>
</dl>

<p>There are some proposals to modify or
expand the <code>SIGHASH</code> system.  The most widely discussed proposal as of
this writing is <a data-type="indexterm" data-primary="BIP118 SIGHASH flags" id="id1008" target="_blank" rel="noopener noreferrer"></a>BIP118, which proposes to add two
new sighash flags.  A signature using <code>SIGHASH_ANYPREVOUT</code> would not
commit to an input’s outpoint field, allowing it to be used to spend any
previous output for a particular witness program.  For example, if Alice
receives two outputs for the same amount to the same witness program
(e.g., requiring a single signature from her wallet), a
<code>SIGHASH_ANYPREVOUT</code> signature for spending either one of those outputs
could be copied and used to spend the other output to the same
destination.</p>

<p>A signature using <code>SIGHASH_ANYPREVOUTANYSCRIPT</code> would not
commit to the outpoint, the amount, the witness program, or the
specific leaf in the taproot merkle tree (script tree), allowing it to spend any previous output that the signature could satisfy.  For example, if Alice received two
outputs for different amounts and different witness programs (e.g., one
requiring a single signature and another requiring her signature plus some
other data), a <code>SIGHASH_ANYPREVOUTANYSCRIPT</code> signature for spending
either one of those outputs could be copied and used to spend the other
output to the same destination (assuming the extra data for the second
output was known).</p>

<p>The main expected use for the two <code>SIGHASH_ANYPREVOUT</code> opcodes is improved
payment channels, such as those used in the Lightning Network (LN), although
several other uses have been described.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You will not often see <code>SIGHASH</code> flags presented as an option in a user’s
wallet application.  Simple wallet applications
sign with 
<span><code>SIGHASH_ALL</code></span> flags.  More sophisticated applications, such as
LN nodes, may use alternative <code>SIGHASH</code> flags, but they
use protocols that have been extensively reviewed to understand the
influence of the alternative <a data-type="indexterm" data-primary="digital signatures" data-secondary="SIGHASH flags" data-startref="digital-signature-sighash" id="id1009" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="SIGHASH flags" data-startref="sighash" id="id1010" target="_blank" rel="noopener noreferrer"></a>flags.</p>
</div>
</div>
</div>






<div id="schnorr_signatures" data-type="sect1" data-pdf-bookmark="Schnorr Signatures">
<h2>Schnorr Signatures</h2>

<p>In 1989, <a data-type="indexterm" data-primary="digital signatures" data-secondary="schnorr signature algorithm" id="digital-sigs-schnorr" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="schnorr signature algorithm" id="schnorr" target="_blank" rel="noopener noreferrer"></a>Claus Schnorr published a paper describing the signature
algorithm that’s become eponymous with him.  The algorithm isn’t
specific to the elliptic curve cryptography (ECC) that Bitcoin and many
other applications use, although it is perhaps most strongly associated
with ECC today.  Schnorr signatures have a number of nice properties:</p>
<dl>
<dt>Provable security</dt>
<dd>
<p>A mathematical <a data-type="indexterm" data-primary="digital signatures" data-secondary="schnorr signature algorithm" data-tertiary="properties of" id="id1011" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="schnorr signature algorithm" data-secondary="properties of" id="id1012" target="_blank" rel="noopener noreferrer"></a>proof of the security of schnorr signatures depends on
only the difficulty of solving the Discrete Logarithm Problem (DLP),
particularly for elliptic curves (EC) for Bitcoin, and the ability of
a hash function (like the SHA256 function used in Bitcoin) to produce
unpredictable values, called the random oracle model (ROM).  Other
signature algorithms have additional dependencies or require much
larger public keys or signatures for equivalent security to
ECC-Schnorr (when the threat is defined as classical computers; other
algorithms may provide more efficient security against quantum
computers).</p>
</dd>
<dt>Linearity</dt>
<dd>
<p>Schnorr signatures have a property that mathematicians <a data-type="indexterm" data-primary="linearity" id="id1013" target="_blank" rel="noopener noreferrer"></a>call
<em>linearity</em>, which applies to functions with two particular
properties.  The first property is that summing together two or more
variables and then running a function on that sum will produce the
same value as running the function on each of the variables
independently and then summing together the results, e.g.,
<em>f(x</em> + <em>y</em> + <em>z)</em> == <em>f(x)</em> + <em>f(y)</em> + <em>f(z)</em>; this property is<a data-type="indexterm" data-primary="additivity" id="id1014" target="_blank" rel="noopener noreferrer"></a> called
<em>additivity</em>.  The second property is that multiplying a variable and
then running a function on that product will produce the same value as
running the function on the variable and then multiplying it by the
same amount, e.g., <em>f(a</em> × <em>x)</em> == <em>a</em> × <em>f(x)</em>; this property is <a data-type="indexterm" data-primary="homogeneity of degree 1" id="id1015" target="_blank" rel="noopener noreferrer"></a>called
<em>homogeneity of degree 1</em>.</p>

<p>In cryptographic operations, some functions may be private (such
  as functions involving private keys or secret nonces), so being able
  to get the same result whether performing an operation inside or
  outside of a function makes it easy for multiple parties to coordinate
  and cooperate without sharing their secrets.  We’ll see some of the
  specific benefits of linearity in schnorr signatures in
  <a data-type="xref" href="#schnorr_multisignatures" target="_blank" rel="noopener noreferrer">“Schnorr-based Scriptless Multisignatures”</a> and <a data-type="xref" href="#schnorr_threshold_signatures" target="_blank" rel="noopener noreferrer">“Schnorr-based Scriptless Threshold Signatures”</a>.</p>
</dd>
<dt>Batch verification</dt>
<dd>
<p>When used<a data-type="indexterm" data-primary="batch verification of digital signatures" id="id1016" target="_blank" rel="noopener noreferrer"></a> in a certain way (which Bitcoin does), one consequence of
schnorr’s linearity is that it’s relatively straightforward to verify
more than one schnorr signature at the same time in less time than it
would take to verify each signature independently.  The more
signatures that are verified in a batch, the greater the speed up.
For the typical number of signatures in a block, it’s possible to
batch verify them in about half the amount of time it would take to
verify each signature independently.</p>
</dd>
</dl>

<p>Later in this chapter, we’ll describe the schnorr signature algorithm
exactly as it’s used in Bitcoin, but we’re going to start with a
simplified version of it and work our way toward the actual protocol in
stages.</p>

<p>Alice<a data-type="indexterm" data-primary="digital signatures" data-secondary="schnorr signature algorithm" data-tertiary="examples of usage" id="id1017" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="schnorr signature algorithm" data-secondary="examples of usage" id="id1018" target="_blank" rel="noopener noreferrer"></a> starts by choosing a large random number (<em>x</em>), which we call her
<em>private key</em>.  She also knows a public point on Bitcoin’s elliptic
curve called the Generator (<em>G</em>) (see <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch04.html#public_key_derivation" target="_blank" rel="noopener noreferrer">“Public Keys”</a>).  Alice uses EC
multiplication to multiply <em>G</em> by her private key <em>x</em>, in which case <em>x</em>
is called a <em>scalar</em> because it scales up <em>G</em>.  The result is <em>xG</em>,
which we call Alice’s <em>public key</em>.  Alice gives her public key to Bob.
Even though Bob also knows <em>G</em>, the DLP prevents Bob from being able to divide <em>xG</em> by <em>G</em> to derive Alice’s
private key.</p>

<p>At some later time, Bob wants Alice to identify herself by proving
that she knows the scalar <em>x</em> for the public key (<em>xG</em>) that Bob
received earlier.  Alice can’t give Bob <em>x</em> directly because that would
allow him to identify as her to other people, so she needs to prove
her knowledge of <em>x</em> without revealing <em>x</em> to Bob,<a data-type="indexterm" data-primary="zero-knowledge proof" id="id1019" target="_blank" rel="noopener noreferrer"></a> called a
<em>zero-knowledge proof</em>.  For that, we begin the schnorr identity
process:</p>
<ol>
<li>
<p>Alice chooses another large random number (<em>k</em>), which we call the
<em>private nonce</em>.  Again she uses it as a scalar, multiplying it by <em>G</em>
to produce <em>kG</em>, which we call the <em>public nonce</em>.  She gives the
public nonce to Bob.</p>
</li>
<li>
<p>Bob chooses a large random number of his own, <em>e</em>, which we call the
<em>challenge scalar</em>.  We say “challenge” because it’s used to challenge
Alice to prove that she knows the private key (<em>x</em>) for the public key
(<em>xG</em>) she previously gave Bob; we say “scalar” because it will later
be used to multiply an EC point.</p>
</li>
<li>
<p>Alice now has the numbers (scalars) <em>x</em>, <em>k</em>, and <em>e</em>.  She combines
them together to produce a final scalar <em>s</em> using the formula
<em>s</em> = <em>k</em> + <em>ex</em>.  She gives <em>s</em> to Bob.</p>
</li>
<li>
<p>Bob now knows the scalars <em>s</em> and <em>e</em>, but not <em>x</em> or <em>k</em>.  However,
Bob does know <em>xG</em> and <em>kG</em>, and he can compute for himself <em>sG</em> and
<em>exG</em>.  That means he can check the equality of a scaled-up version of
the operation Alice performed: 
<span><em>sG</em> == <em>kG</em> + <em>exG</em>.</span>  If that is equal,
then Bob can be sure that Alice knew <em>x</em> when she generated <em>s</em>.</p>
</li>

</ol>


<p>Let’s discuss some of the features of the interactive schnorr
identity protocol that make it secure:</p>
<dl>
<dt>The nonce (k)</dt>
<dd>
<p>In step 1, <a data-type="indexterm" data-primary="digital signatures" data-secondary="schnorr signature algorithm" data-tertiary="security features" id="id1021" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="schnorr signature algorithm" data-secondary="security features" id="id1022" target="_blank" rel="noopener noreferrer"></a>Alice chooses a number that Bob doesn’t
  know and can’t guess and gives him the scaled form of that number,
  <em>kG</em>.  At that point, Bob also already has her public key (<em>xG</em>),
  which is the scaled form of <em>x</em>, her private key.  That means when Bob is working on
  the final equation (<em>sG</em> = <em>kG</em> + <em>exG</em>), there are two independent
  variables that Bob doesn’t know (<em>x</em> and <em>k</em>).  It’s possible to use
  simple algebra to solve an equation with one unknown variable but not
  two independent unknown variables, so the presence of Alice’s nonce
  prevents Bob from being able to derive her private key.  It’s critical
  to note that this protection depends on nonces being unguessable in
  any way.  If there’s anything predictable about Alice’s nonce, Bob may
  be able to leverage that into figuring out Alice’s private key.  See
  <a data-type="xref" href="#nonce_warning" target="_blank" rel="noopener noreferrer">“The Importance of Randomness in Signatures”</a> for more details.</p>
</dd>
<dt>The challenge scalar (e)</dt>
<dd>
<p>Bob waits to receive Alice’s public nonce
  and then proceeds in step 2 to give her a number (the challenge
  scalar) that Alice didn’t previously know and couldn’t have guessed.
  It’s critical that Bob only give her the challenge scalar after she
  commits to her public nonce.  Consider what could happen if someone
  who didn’t know <em>x</em> wanted to impersonate Alice, and Bob accidentally
  gave them the challenge scalar <em>e</em> before they told him the public
  nonce <em>kG</em>.  This allows the impersonator to change parameters on both sides of
  the equation that Bob will use for verification, <em>sG</em> == <em>kG</em> + <em>exG</em>;
  specifically, they can change both <em>sG</em> and <em>kG</em>.  Think about a
  simplified form of that expression: <em>x</em> = <em>y</em> + <em>a</em>.  If you can change both
  <em>x</em> and <em>y</em>, you can cancel out <em>a</em> using <em>x</em><code>'</code> = (<em>x</em> – <em>a</em>) + <em>a</em>.  Any
  value you choose for <em>x</em> will now satisfy the equation.  For the
  actual equation the impersonator simply chooses a random number for <em>s</em>, generates
  <em>sG</em>, and then uses EC subtraction to select a <em>kG</em> that equals <em>kG</em> =
  <em>sG</em> – <em>exG</em>.  They give Bob their calculated <em>kG</em> and later their random
  <em>sG</em>, and Bob thinks that’s valid because 
<span><em>sG</em> == (<em>sG</em> – <em>exG</em>)</span> + <em>exG</em>.
  This explains why the order of operations in the protocol is
  essential: Bob must only give Alice the challenge scalar after Alice
  has committed to her public nonce.</p>
</dd>
</dl>
<p>
The interactive identity protocol described here matches part of Claus
Schnorr’s original description, but it lacks two essential features we
need for the decentralized Bitcoin network.  The first of these is that
it relies on Bob waiting for Alice to commit to her public nonce and
then Bob giving her a random challenge scalar.  In Bitcoin, the spender
of every transaction needs to be authenticated by thousands of Bitcoin
full nodes—including future nodes that haven’t been started yet but
whose operators will one day want to ensure the bitcoins they receive
came from a chain of transfers where every transaction was valid.  Any
Bitcoin node that is unable to communicate with Alice, today or in the
future, will be unable to authenticate her transaction and will be in
disagreement with every other node that did authenticate it.  That’s not
acceptable for a consensus system like Bitcoin.  For Bitcoin to work, we
need a protocol that doesn’t require interaction between Alice and each
node that wants to authenticate her.
</p>

<p>A simple technique, known as the Fiat-Shamir transform after its
discoverers, can turn the schnorr interactive identity protocol
into a noninteractive digital signature scheme.  Recall the importance
of steps 1 and 2—​including that they be performed in order.  Alice must
commit to an unpredictable nonce; Bob must give Alice an unpredictable
challenge scalar only after he has received her commitment.  Recall also
the properties of secure cryptographic hash functions we’ve used
elsewhere in this book: it will always produce the same output when
given the same input but it will produce a value indistinguishable from
random data when given a different input.</p>

<p>This allows Alice to choose her private nonce, derive her public nonce,
and then hash the public nonce to get the challenge scalar.  Because
Alice can’t predict the output of the hash function (the challenge), and
because it’s always the same for the same input (the nonce), this
ensures that Alice gets a random challenge even though she chooses the nonce
and hashes it herself.  We no longer need interaction from Bob.  She can
simply publish her public nonce <em>kG</em> and the scalar <em>s</em>, and each of the
thousands of full nodes (past and future) can hash <em>kG</em> to produce <em>e</em>,
use that to produce <em>exG</em>, and then verify <em>sG</em> == <em>kG</em> + <em>exG</em>.  Written
explicitly, the verification equation becomes 
<span><em>sG</em> == <em>kG</em> + <em>hash</em>(<em>kG</em>) × <em>xG</em>.</span></p>

<p>We need one other thing to finish converting the interactive schnorr
identity protocol into a digital signature protocol useful for
Bitcoin.  We don’t just want Alice to prove that she knows her private
key; we also want to give her the ability to commit to a message.  Specifically,
we want her to commit to the data related to the Bitcoin transaction she
wants to send.  With the Fiat-Shamir transform in place, we already
have a commitment, so we can simply have it additionally commit to the
message.  Instead of <em>hash</em>(<em>kG</em>), we now also commit to the message
<em>m</em> using <em>hash</em>(<em>kG</em> || <em>m</em>), where || stands for concatenation.</p>

<p>We’ve now defined a version of the schnorr signature protocol, but
there’s one more thing we need to do to address a Bitcoin-specific
concern.  In BIP32 key derivation, as described in
<a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch05.html#public_child_key_derivation" target="_blank" rel="noopener noreferrer">“Public Child Key Derivation”</a>, the algorithm for unhardened derivation
takes a public key and adds to it a nonsecret value to produce a
derived public key.  That means it’s also possible to add that
nonsecret value to a valid signature for one key to produce a signature
for a related key.  That related signature is valid but it wasn’t
authorized by the person possessing the private key, which is a major
security failure.  To protect BIP32 unhardened derivation and
also support several protocols people wanted to build on top of schnorr
signatures, Bitcoin’s version of schnorr signatures, called <em>BIP340
schnorr signatures for secp256k1</em>, also commits to the public key being
used in addition to the public nonce and the message.  That makes the
full commitment <em>hash</em>(<em>kG</em> || <em>xG</em> || <em>m</em>).</p>

<p>Now that we’ve described each part of the BIP340 schnorr signature
algorithm and explained what it does for us, we can define the protocol.
Multiplication of integers are performed <em>modulus p</em>, indicating that the
result of the operation is divided by the number <em>p</em> (as defined in the
secp256k1 standard) and the remainder is used.  The number <em>p</em> is very
large, but if it was 3 and the result of an operation was 5, the actual
number we would use is 2 (i.e., 5 divided by 3 has a remainder of 2).</p>

<p>Setup: Alice chooses a large random number (<em>x</em>) as her private key
(either directly or by using a protocol like BIP32 to deterministically
generate a private key from a large random seed value).  She uses the
parameters defined in secp256k1 (see <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch04.html#elliptic_curve" target="_blank" rel="noopener noreferrer">“Elliptic Curve Cryptography Explained”</a>) to multiply the
generator <em>G</em> by her scalar <em>x</em>, producing <em>xG</em> (her public key).  She
gives her public key to everyone who will later authenticate her Bitcoin
transactions (e.g., by having <em>xG</em> included in a transaction output).  When
she’s ready to spend, she begins generating her signature:</p>
<ol>
<li>
<p>Alice chooses a large random private nonce <em>k</em> and derives the public
nonce <em>kG</em>.</p>
</li>
<li>
<p>She chooses her message <em>m</em> (e.g., transaction data) and generates the
challenge scalar <em>e</em> = <em>hash</em>(<em>kG</em> || <em>xG</em> || <em>m</em>).</p>
</li>
<li>
<p>She produces the scalar <em>s</em> = <em>k</em> + <em>ex</em>.  The two values <em>kG</em> and <em>s</em>
are her signature.  She gives this signature to everyone who wants to
verify that signature; she also needs to ensure everyone receives her
message <em>m</em>.  In Bitcoin, this is done by including her signature in
the witness structure of her spending transaction and then relaying that
transaction to full nodes.</p>
</li>
<li>
<p>The verifiers (e.g., full nodes) use <em>s</em> to derive <em>sG</em> and then
verify that <em>sG</em> == <em>kG</em> + <em>hash</em>(<em>kG</em> || <em>xG</em> || <em>m</em>) × <em>xG</em>.  If the equation is
valid, Alice proved that she knows her private key <em>x</em> (without
revealing it) and committed to the message <em>m</em> (containing the
transaction data).</p>
</li>

</ol>








<div id="id260" data-type="sect2" data-pdf-bookmark="Serialization of Schnorr Signatures">
<h2>Serialization of Schnorr Signatures</h2>

<p>A schnorr signature <a data-type="indexterm" data-primary="digital signatures" data-secondary="schnorr signature algorithm" data-tertiary="serialization" id="id1023" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="schnorr signature algorithm" data-secondary="serialization" id="id1024" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="serialization" data-secondary="of schnorr signature algorithm" data-secondary-sortas="schnorr" id="id1025" target="_blank" rel="noopener noreferrer"></a>consists of two values, <em>kG</em> and <em>s</em>.  The value
<em>kG</em> is a point on Bitcoin’s elliptic curve (called secp256k1) and would normally be represented by two 32-byte coordinates, e.g., (<em>x</em>, <em>y</em>).
However, only the <em>x</em> coordinate is needed, so only that value is
included.  When you see <em>kG</em> in schnorr signatures for Bitcoin, note that it’s only that point’s <em>x</em>
coordinate.</p>

<p>The value <em>s</em> is a scalar (a number meant to multiply other numbers).  For
Bitcoin’s secp256k1 curve, it can never be more than 32 bytes long.</p>

<p>Although both <em>kG</em> and <em>s</em> can sometimes be values that can be
represented with fewer than 32 bytes, it’s improbable that they’d be
much smaller than 32 bytes, so they’re serialized as two 32-byte
values (i.e., values smaller than 32 bytes have leading zeros).
They’re serialized in the order of <em>kG</em> and then <em>s</em>, producing exactly
64 bytes.</p>

<p>The taproot soft fork, also called v1 segwit, introduced schnorr signatures
to Bitcoin and is the only way they are used in Bitcoin as of this writing.  When
used with either taproot keypath or scriptpath spending, a 64-byte
schnorr signature is considered to use a default signature hash (sighash)
that is <code>SIGHASH_ALL</code>.  If an alternative sighash is used, or if the
spender wants to waste space to explicitly specify <code>SIGHASH_ALL</code>, a
single additional byte is appended to the signature that specifies the
signature hash, making the signature 65 bytes.</p>

<p>As we’ll see, either 64 or 65 bytes is considerably more efficient that
the serialization used for ECDSA signatures described in
<a data-type="xref" href="#serialization_of_signatures_der" target="_blank" rel="noopener noreferrer">“Serialization of ECDSA Signatures (DER)”</a>.</p>
</div>








<div id="schnorr_multisignatures" data-type="sect2" data-pdf-bookmark="Schnorr-based Scriptless Multisignatures">
<h2>Schnorr-based Scriptless Multisignatures</h2>

<p>In the<a data-type="indexterm" data-primary="digital signatures" data-secondary="schnorr signature algorithm" data-tertiary="scriptless multisignatures" id="digital-sigs-schnorr-multisig" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="schnorr signature algorithm" data-secondary="scriptless multisignatures" id="schnorr-multisig" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="scriptless multisignatures" data-secondary="in schnorr signature algorithm" data-secondary-sortas="schnorr" id="scriptless-multi-schnorr" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="multisignature scripts" data-secondary="in schnorr signature algorithm" data-secondary-sortas="schnorr" id="multi-script-schnorr" target="_blank" rel="noopener noreferrer"></a> single-signature schnorr protocol described in <a data-type="xref" href="#schnorr_signatures" target="_blank" rel="noopener noreferrer">“Schnorr Signatures”</a>, Alice
uses a signature (<em>kG</em>, <em>s</em>) to publicly prove her knowledge of her
private key, which in this case we’ll call <em>y</em>.  Imagine if Bob also has
a private key (<em>z</em>) and he’s willing to work with Alice to prove that
together they know <em>x</em> = <em>y</em> + <em>z</em> without either of them revealing their
private key to each other or anyone else.  Let’s go through the BIP340
schnorr signature protocol again.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>The simple protocol we are about to describe is not secure for the
reasons we will explain shortly.  We use it only to demonstrate the
mechanics of schnorr multisignatures before describing related protocols
that are believed to be secure.</p>
</div>

<p>Alice and Bob need to derive the public key for <em>x</em>, which is <em>xG</em>.
Since it’s possible to use elliptic curve operations to add two EC
points together, they start by Alice deriving <em>yG</em> and Bob deriving
<em>zG</em>.  They then add them together to create 
<span><em>xG</em> = <em>yG</em> + <em>zG</em>.</span>  The point
<em>xG</em> is <a data-type="indexterm" data-primary="aggregated public keys" id="id1026" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="public keys" data-secondary="aggregated" id="id1027" target="_blank" rel="noopener noreferrer"></a>their <em>aggregated public key</em>.  To create a signature, they begin the
simple multisignature protocol:</p>
<ol>
<li>
<p>They each individually choose a large random private nonce, <em>a</em> for
Alice and <em>b</em> for Bob.  They also individually derive the corresponding
public nonce <em>aG</em> and <em>bG</em>.  Together, they produce an aggregated
public nonce <em>kG</em> = <em>aG</em> + <em>bG</em>.</p>
</li>
<li>
<p>They agree on the message to sign, <em>m</em> (e.g., a transaction), and
each generates a copy of the challenge scalar: <em>e</em> = <em>hash</em>(<em>kG</em> || <em>xG</em> || <em>m</em>).</p>
</li>
<li>
<p>Alice produces the scalar <em>q</em> = <em>a</em> + <em>ey</em>.  Bob produces the scalar
<em>r</em> = <em>b</em> + <em>ez</em>.  They add the scalars together to produce
<em>s</em> = <em>q</em> + <em>r</em>.  Their signature is the two values <em>kG</em> 
<span>and <em>s</em>.</span></p>
</li>
<li>
<p>The verifiers check their public key and signature using the normal
equation: 
<span><em>sG</em> ==</span> <em>kG</em> + <em>hash</em>(<em>kG</em> || <em>xG</em> || <em>m</em>) × <em>xG</em>.</p>
</li>

</ol>

<p>Alice and Bob have proven that they know the sum of their private keys without
either one of them revealing their private key to the other or anyone
else.  The protocol can be extended to any number of participants (e.g.,
a million people could prove they knew the sum of their million
different keys).</p>

<p>The preceding protocol has several security problems.  Most notable is that one
party might learn the public keys of the other parties before committing
to their own public key.  For example, Alice generates her public key
<em>yG</em> honestly and shares it with Bob.  Bob generates his public key
using <em>zG</em> – <em>yG</em>.  When their two keys are combined 
<span>(<em>yG</em> + <em>zG</em> – <em>yG</em>),</span> the
positive and negative <em>yG</em> terms cancel out so the public key only represents
the private key for <em>z</em> (i.e., Bob’s private key).  Now Bob can create a
valid signature without any assistance from Alice.  This is <a data-type="indexterm" data-primary="key cancellation attacks" id="id1028" target="_blank" rel="noopener noreferrer"></a>called a
<em>key cancellation attack</em>.</p>

<p>There are various ways to solve the key cancellation attack.  The
simplest scheme would be to require each participant commit to their
part of the public key before sharing anything about that key with all
of the other participants.  For example, Alice and Bob each individually
hash their public keys and share their digests with each other.  When
they both have the other’s digest, they can share their keys.  They
individually check that the other’s key hashes to the previously
provided digest and then proceed with the protocol normally.  This prevents
either one of them from choosing a public key that cancels out the keys
of the other participants.  However, it’s easy to fail to implement this
scheme correctly, such as using it in a naive way with unhardened
BIP32 public key derivation.  Additionally, it adds an extra step for
communication between the participants, which may be undesirable in many
cases.  More complex schemes have been proposed that address these
shortcomings.</p>

<p>In addition to the key cancellation attack, there are a number of
attacks possible against <a data-type="indexterm" data-primary="nonce attacks" id="id1029" target="_blank" rel="noopener noreferrer"></a>nonces.  Recall that the purpose of the nonce
is to prevent anyone from being able to use their knowledge of other values
in the signature verification equation to solve for your private key,
determining its value.  To effectively accomplish that, you must use a
different nonce every time you sign a different message or change other
signature parameters.  The different nonces must not be related in any
way.  For a multisignature, every participant must follow these rules or
it could compromise the security of other participants.  In addition,
cancellation and other attacks need to be prevented.  Different
protocols that accomplish these aims make different trade-offs, so
there’s no single multisignature protocol to recommend in all cases.
Instead, we’ll note three from the MuSig family of protocols:</p>
<dl>
<dt>MuSig</dt>
<dd>
<p>Also called <em>MuSig1</em>, this protocol<a data-type="indexterm" data-primary="MuSig protocol" id="id1030" target="_blank" rel="noopener noreferrer"></a> requires three rounds of
communication during the signing process, making it similar to the
process we just described.  MuSig1’s greatest advantage is its
simplicity.</p>
</dd>
<dt>MuSig2</dt>
<dd>
<p>This only <a data-type="indexterm" data-primary="MuSig2 protocol" id="id1031" target="_blank" rel="noopener noreferrer"></a>requires two rounds of communication and can sometimes allow
one of the rounds to be combined with key exchange.  This can
significantly speed up signing for certain protocols, such as how
scriptless multisignatures are planned to be used in the LN.  MuSig2 is specified in BIP327 (the only scriptless
multisignature protocol that has a BIP as of this writing).</p>
</dd>
<dt>MuSig-DN</dt>
<dd>
<p>DN stands <a data-type="indexterm" data-primary="MuSig-DN protocol" id="id1032" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="repeated session attacks" id="id1033" target="_blank" rel="noopener noreferrer"></a>for Deterministic Nonce, which eliminates as a concern a
problem known as the <em>repeated session attack</em>.  It can’t be combined
with key exchange and it’s significantly more complex to implement
than MuSig or MuSig2.</p>
</dd>
</dl>

<p>For most applications, MuSig2 is the best multisignature protocol
available at the time<a data-type="indexterm" data-primary="digital signatures" data-secondary="schnorr signature algorithm" data-tertiary="scriptless multisignatures" data-startref="digital-sigs-schnorr-multisig" id="id1034" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="schnorr signature algorithm" data-secondary="scriptless multisignatures" data-startref="schnorr-multisig" id="id1035" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="scriptless multisignatures" data-secondary="in schnorr signature algorithm" data-secondary-sortas="schnorr" data-startref="scriptless-multi-schnorr" id="id1036" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="multisignature scripts" data-secondary="in schnorr signature algorithm" data-secondary-sortas="schnorr" data-startref="multi-script-schnorr" id="id1037" target="_blank" rel="noopener noreferrer"></a> of writing.</p>
</div>








<div id="schnorr_threshold_signatures" data-type="sect2" data-pdf-bookmark="Schnorr-based Scriptless Threshold Signatures">
<h2>Schnorr-based Scriptless Threshold Signatures</h2>

<p>Scriptless <a data-type="indexterm" data-primary="digital signatures" data-secondary="schnorr signature algorithm" data-tertiary="scriptless threshold signatures" id="digital-sigs-schnorr-threshold" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="schnorr signature algorithm" data-secondary="scriptless threshold signatures" id="schnorr-threshold" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="scriptless threshold signatures" id="scriptless-threshold-schnorr" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="threshold signatures" data-secondary="in schnorr signature algorithm" data-secondary-sortas="schnorr" id="threshold-schnorr" target="_blank" rel="noopener noreferrer"></a>multisignature protocols only work for <em>k</em>-of-<em>k</em> signing.
Everyone with a partial public key that becomes part of the aggregated
public key must contribute a partial signature and partial nonce to the
final signature.  Sometimes, though, the participants want to allow a
subset of them to sign, such as <em>t</em>-of-<em>k</em> where a threshold (<em>t</em>) number of participants can sign for
a key constructed by <em>k</em> participants.  That type of signature is called a
<em>threshold signature</em>.</p>

<p>We saw script-based threshold signatures in
<a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch07.html#multisig" target="_blank" rel="noopener noreferrer">“Scripted Multisignatures”</a>.  But just as
scriptless multisignatures save space and increase privacy compared to
scripted multisignatures, <em>scriptless threshold signatures</em> save space and
increase privacy compared to <em>scripted threshold signatures</em>.  To anyone
not involved in the signing, a <em>scriptless threshold signature</em> looks
like any other signature that could’ve been created by a single-sig
user or through a scriptless multisignature protocol.</p>

<p>Various methods are known for generating scriptless threshold
signatures, with the simplest being a slight modification of how we
created scriptless multisignatures previously.  This protocol also
depends on verifiable secret sharing (which itself depends on secure
secret sharing).</p>

<p>Basic secret sharing can work through simple splitting.  Alice has a
secret number that she splits into three equal-length parts and shares
with Bob, Carol, and Dan.  Those three can combine the partial numbers
they received (called <em>shares</em>) in the correct order to reconstruct
Alice’s secret.  A more sophisticated scheme would involve Alice adding
on some additional information to each share, called a correction code,
that allows any two of them to recover the number.  This scheme is not
secure because each share gives its holder partial knowledge of Alice’s
secret, making it easier for the participant to guess Alice’s secret
than a nonparticipant who didn’t have a share.</p>

<p>A secure secret sharing scheme prevents participants from learning
anything about the secret unless they combine the minimum threshold
number of shares.  For example, Alice can choose a threshold of
2 if she wants any two of Bob, Carol, and Dan to be able to
reconstruct her secret.  The best known secure secret sharing algorithm
is <em>Shamir’s Secret Sharing Scheme</em>, commonly abbreviated SSSS and named
after its discoverer, one of the same discoverers of the Fiat-Shamir
transform we saw in <a data-type="xref" href="#schnorr_signatures" target="_blank" rel="noopener noreferrer">“Schnorr Signatures”</a>.</p>

<p>In some cryptographic protocols, such as the scriptless threshold signature
schemes we’re working toward, it’s critical for Bob, Carol, and Dan to
know that Alice followed her side of the protocol correctly.  They need to
know that the shares she creates all derive from the same secret, that
she used the threshold value she claims, and that she gave each one of
them a different share.  A protocol that can accomplish all of that,
and still be a secure secret sharing scheme, is a <em>verifiable secret
sharing scheme</em>.</p>

<p>To see how multisignatures and verifiable secret sharing work for
Alice, Bob, and Carol, imagine they each wish to receive funds that can
be spent by any two of them.  They collaborate as described in
<a data-type="xref" href="#schnorr_multisignatures" target="_blank" rel="noopener noreferrer">“Schnorr-based Scriptless Multisignatures”</a> to produce a regular multisignature public
key to accept the funds (k-of-k).  Then each participant derives two
secret shares from their private key—​one for each of two the other
participants. The shares allow any two of them to reconstruct the
originating partial private key for the multisignature. Each participant
distributes one of their secret shares to the other two participants,
resulting in each participant storing their own partial private key and
one share for every other participant. Subsequently, each participant
verifies the authenticity and uniqueness of the shares they received
compared to the shares given to the other participants.</p>

<p>Later on, when (for example) Alice and Bob want to generate a scriptless
threshold signature without Carol’s involvement, they exchange the two
shares they possess for Carol. This enables them to reconstruct Carol’s
partial private key.  Alice and Bob also have their private keys,
allowing them to create a scriptless multisignature with all three
necessary keys.</p>

<p>In other words, the scriptless threshold signature scheme just described
is the same as a scriptless multisignature scheme except that
a threshold number of participants have the ability to reconstruct the
partial private keys of any other participants who are unable or
unwilling to sign.</p>

<p>This does point to a few things to be aware about when considering a
scriptless threshold signature protocol:</p>
<dl>
<dt>No accountability</dt>
<dd>
<p>Because Alice and Bob reconstruct Carol’s partial
private key, there can be no fundamental difference between a scriptless
multisignature produced by a process that involved Carol and one that
didn’t.  Even if Alice, Bob, or Carol claim that they didn’t sign,
there’s no guaranteed way for them to prove that they didn’t
help produce the signature.  If it’s important to know which members of
the group signed, you will need to use a script.</p>
</dd>
<dt>Manipulation attacks</dt>
<dd>
<p>Imagine that Bob tells Alice that Carol is
unavailable, so they work together to reconstruct Carol’s partial
private key.  Then Bob tells Carol that Alice is unavailable, so they
work together to reconstruct Alice’s partial private key.  Now Bob has
his own partial private key plus the keys of Alice and Carol, allowing
him to spend the funds himself without their involvement.  This attack can
be addressed if all of the participants agree to only communicate using a
scheme that allows any one of them to see all of the other’s messages
(e.g., if Bob tells Alice that Carol is unavailable, Carol is able to see
that message before she begins working with Bob).  Other solutions,
possibly more robust solutions, to this problem were being researched at
the time of writing.</p>
</dd>
</dl>

<p>No scriptless threshold signature protocol has been proposed as a BIP
yet, although significant research into the subject has been performed
by multiple Bitcoin contributors and we expect peer-reviewed solutions
will become available after the publication of this<a data-type="indexterm" data-primary="digital signatures" data-secondary="schnorr signature algorithm" data-startref="digital-sigs-schnorr" id="id1038" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="schnorr signature algorithm" data-startref="schnorr" id="id1039" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="digital signatures" data-secondary="schnorr signature algorithm" data-tertiary="scriptless threshold signatures" data-startref="digital-sigs-schnorr-threshold" id="id1040" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="schnorr signature algorithm" data-secondary="scriptless threshold signatures" data-startref="schnorr-threshold" id="id1041" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="scriptless threshold signatures" data-startref="scriptless-threshold-schnorr" id="id1042" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="threshold signatures" data-secondary="in schnorr signature algorithm" data-secondary-sortas="schnorr" data-startref="threshold-schnorr" id="id1043" target="_blank" rel="noopener noreferrer"></a> book.</p>
</div>
</div>






<div id="ecdsa_signatures" data-type="sect1" data-pdf-bookmark="ECDSA Signatures">
<h2>ECDSA Signatures</h2>

<p>Unfortunately <a data-type="indexterm" data-primary="digital signatures" data-secondary="ECDSA" id="digital-signature-ecdsa" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="ECDSA (Elliptic Curve Digital Signature Algorithm)" id="ecdsa" target="_blank" rel="noopener noreferrer"></a>for the future development of Bitcoin and many other
applications, Claus Schnorr patented the algorithm he discovered and
prevented its use in open standards and open source software for almost
two decades.  Cryptographers in the early 1990s who were blocked from
using the schnorr signature scheme developed an alternative construction
called the <em>Digital Signature Algorithm</em> (DSA), with a version adapted
to elliptic curves called ECDSA.</p>

<p>The ECDSA scheme and standardized parameters for suggested curves it could be used
with were widely implemented in cryptographic libraries by the time
development on Bitcoin began in 2007.  This was almost certainly the
reason why ECDSA was the only digital signature protocol that Bitcoin
supported from its first release version until the activation of the
taproot soft fork in 2021.  ECDSA remains supported today for all
non-taproot transactions.  Some of the differences compared to schnorr
signatures include:</p>
<dl>
<dt>More complex</dt>
<dd>
<p>As we’ll see, ECDSA requires more operations to create or verify a
signature than the schnorr signature protocol.  It’s not significantly
more complex from an implementation standpoint, but that extra
complexity makes ECDSA less flexible, less performant, and harder to
prove secure.</p>
</dd>
<dt>Less provable security</dt>
<dd>
<p>The interactive schnorr signature identification protocol depends only
on the strength of the elliptic curve Discrete Logarithm Problem
(ECDLP).  The non-interactive authentication protocol used in Bitcoin
also relies on the random oracle model (ROM).  However, ECDSA’s extra
complexity has prevented a complete proof of its security being
published (to the best of our knowledge).  We are not experts in
proving cryptographic algorithms, but it seems unlikely after 30 years
that ECDSA will be proven to only require the same two assumptions as
schnorr.</p>
</dd>
<dt>Nonlinear</dt>
<dd>
<p>ECDSA signatures cannot be easily combined to create scriptless
multisignatures or used in related advanced applications, such as
multiparty signature adaptors.  There are workarounds for this
problem, but they involve additional extra complexity that
significantly slows down operations and which, in some cases, has
resulted in software accidentally leaking private keys.</p>
</dd>
</dl>








<div id="id414" data-type="sect2" data-pdf-bookmark="ECDSA Algorithm">
<h2>ECDSA Algorithm</h2>

<p>Let’s look at the math of ECDSA.
Signatures are created by a mathematical function <em>F</em><sub><em>sig</em></sub>
that produces a signature composed of two values.  In ECDSA, those two
values are <em>R</em> and <em>s</em>.</p>

<p>The signature
algorithm first generates a private nonce (<em>k</em>) and derives from it a public
nonce (<em>K</em>).  The <em>R</em> value of the digital signature is then the <em>x</em>
coordinate of the nonce <em>K</em>.</p>

<p>From there, the algorithm calculates the <em>s</em> value of the signature.  Like we did with schnorr signatures, operations involving
integers are modulus p:</p>


<p>where:</p>

<ul>
<li>
<p><em>k</em> is the private nonce</p>
</li>
<li>
<p><em>R</em> is the <em>x</em> coordinate of the public nonce</p>
</li>
<li>
<p><em>x</em> is the Alice’s private key</p>
</li>
<li>
<p><em>m</em> is the message (transaction data)</p>
</li>
</ul>

<p>Verification is the inverse of the signature generation function, using
the <em>R</em>, <em>s</em> values and the public key to calculate a value <em>K</em>, which
is a point on the elliptic curve (the public nonce used in
signature creation):</p>


<p>where:</p>

<ul>
<li>
<p><em>R</em> and <em>s</em> are the signature values</p>
</li>
<li>
<p><em>X</em> is Alice’s public key</p>
</li>
<li>
<p><em>m</em> is the message (the transaction data that was signed)</p>
</li>
<li>
<p><em>G</em> is the elliptic curve generator point</p>
</li>
</ul>

<p>If the <em>x</em> coordinate of the calculated point <em>K</em> is equal to <em>R</em>, then
the verifier can conclude that the signature is valid.</p>
<div data-type="tip"><h6>Tip</h6>
<p>ECDSA is necessarily a fairly complicated piece of math; a full
explanation is beyond the scope of this book. A number of great guides
online take you through it step by step: search for “ECDSA explained.”</p>
</div>
</div>








<div id="serialization_of_signatures_der" data-type="sect2" data-pdf-bookmark="Serialization of ECDSA Signatures (DER)">
<h2>Serialization of ECDSA Signatures (DER)</h2>

<p>Let’s <a data-type="indexterm" data-primary="serialization" data-secondary="ECDSA signatures" id="id1044" target="_blank" rel="noopener noreferrer"></a>look at
the following DER-encoded signature:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204
b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e381301</pre></div>

<p>That signature is a serialized byte stream of the <em>R</em> and <em>s</em> values
produced by the signer to prove control of the private key authorized
to spend an output. The serialization format consists of nine elements
as follows:</p>

<ul>
<li>
<p><code>0x30</code>, indicating the start of a DER sequence</p>
</li>
<li>
<p><code>0x45</code>, the length of the sequence (69 bytes)</p>
</li>
<li>
<p><code>0x02</code>, an integer value follows</p>
</li>
<li>
<p><code>0x21</code>, the length of the integer (33 bytes)</p>
</li>
<li>
<p><code>R</code>, <code>00884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb</code></p>
</li>
<li>
<p><code>0x02</code>, another integer follows</p>
</li>
<li>
<p><code>0x20</code>, the length of the integer (32 bytes)</p>
</li>
<li>
<p><code>S</code>, <code>4b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813</code></p>
</li>
<li>
<p>A suffix (<code>0x01</code>) indicating the type of hash<a data-type="indexterm" data-primary="digital signatures" data-secondary="ECDSA" data-startref="digital-signature-ecdsa" id="id1045" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="ECDSA (Elliptic Curve Digital Signature Algorithm)" data-startref="ecdsa" id="id1046" target="_blank" rel="noopener noreferrer"></a> used (<code>SIGHASH_ALL</code>)</p>
</li>
</ul>
</div>
</div>






<div id="nonce_warning" data-type="sect1" data-pdf-bookmark="The Importance of Randomness in Signatures">
<h2>The Importance of Randomness in Signatures</h2>

<p>As we<a data-type="indexterm" data-primary="digital signatures" data-secondary="randomness, importance of" id="digital-signature-random" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="randomness, importance in digital signatures" id="random-digital-signature" target="_blank" rel="noopener noreferrer"></a> saw in <a data-type="xref" href="#schnorr_signatures" target="_blank" rel="noopener noreferrer">“Schnorr Signatures”</a> and <a data-type="xref" href="#ecdsa_signatures" target="_blank" rel="noopener noreferrer">“ECDSA Signatures”</a>,
the signature generation algorithm uses a random number <em>k</em> as the basis
for a private/public nonce pair. The value of <em>k</em> is not
important, <em>as long as it is random</em>. If signatures from the same
private key use the private nonce <em>k</em> with different messages
(transactions), then the
signing <em>private key</em> can be calculated by anyone. Reuse of the same
value for <em>k</em> in a signature algorithm leads to exposure of the private
key!</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>If the same value <em>k</em>
is used in the signing algorithm on two different transactions, the
private key can be calculated and exposed to the world!</p>
</div>

<p>This is not just a theoretical possibility. We have seen this issue lead
to exposure of private keys in a few different implementations of
transaction-signing algorithms in Bitcoin. People have had funds stolen
because of inadvertent reuse of a <em>k</em> value. The most common reason for
reuse of a <em>k</em> value is an improperly initialized random-number
generator.</p>

<p>To avoid this
vulnerability, the industry best practice is to not generate <em>k</em> with a
random-number generator seeded only with entropy, but instead to use a
process seeded in part with the transaction data itself plus the
private key being used to sign.
This ensures that each transaction produces a different <em>k</em>. The
industry-standard algorithm for deterministic initialization of <em>k</em> for
ECDSA is defined in <a href="https://oreil.ly/yuabl" target="_blank" rel="noopener noreferrer">RFC6979</a>, published by
the Internet Engineering Task Force.  For schnorr signatures, BIP340
recommends a default signing algorithm.</p>

<p>BIP340 and RFC6979 can generate <em>k</em> entirely deterministically, meaning the same
transaction data will always produce the same <em>k</em>.  Many wallets do this
because it makes it easy to write tests to verify their safety-critical
signing code is producing <em>k</em> values correctly.  BIP340 and RFC6979 both also allow
including additional data in the calculation.  If that data is entropy,
then a different <em>k</em> will be produced even if the exact same transaction
data is signed.  This can increase protection against sidechannel and
fault-injection attacks.</p>

<p>If you are implementing an algorithm to sign transactions in Bitcoin,
you <em>must</em> use BIP340, RFC6979, or a similar algorithm to
ensure you generate a different <em>k</em> for each <a data-type="indexterm" data-primary="digital signatures" data-secondary="randomness, importance of" data-startref="digital-signature-random" id="id1047" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="randomness, importance in digital signatures" data-startref="random-digital-signature" id="id1048" target="_blank" rel="noopener noreferrer"></a>transaction.</p>
</div>






<div id="id144" data-type="sect1" data-pdf-bookmark="Segregated Witness’s New Signing Algorithm">
<h2>Segregated Witness’s New Signing Algorithm</h2>

<p>Signatures in<a data-type="indexterm" data-primary="digital signatures" data-secondary="segregated witness and" id="id1049" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="segregated witness (segwit)" data-secondary="digital signatures and" id="id1050" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="commitment hash" id="id1051" target="_blank" rel="noopener noreferrer"></a> Bitcoin transactions are applied on a <em>commitment hash</em>,
which is calculated from the transaction data, locking specific parts of
the data indicating the signer’s commitment to those values. For
example, in a simple <code>SIGHASH_ALL</code> type signature, the commitment hash
includes all inputs and outputs.</p>

<p>Unfortunately, the way the legacy commitment hashes were calculated introduced the
possibility that a node verifying a signature can be forced to perform
a significant number of hash computations. Specifically, the hash
operations increase roughly quadratically with respect to the number of
inputs in the transaction. An attacker could therefore create a
transaction with a very large number of signature operations, causing
the entire Bitcoin network to have to perform hundreds or thousands of
hash operations to verify the transaction.</p>

<p>Segwit represented an opportunity to address this problem by changing
the way the commitment hash is calculated. For segwit version 0 witness
programs, signature verification occurs using an improved commitment
hash algorithm as specified in BIP143.</p>

<p>The new algorithm allows the number of
hash operations to increase by a much more gradual O(n) to the number of
signature operations, reducing the opportunity to create
denial-of-service attacks with overly complex transactions.</p>

<p>In this chapter, we learned about schnorr and ECDSA signatures for
Bitcoin.  This explains how full nodes authenticate transactions to
ensure that only someone controlling the key to which bitcoins were
received can spend those bitcoins.  We also examined several advanced
applications of signatures, such as scriptless multisignatures and
scriptless threshold signatures that can be used to improve the
efficiency and privacy of Bitcoin.  In the past few chapters, we’ve
learned how to create transactions, how to secure them with
authorization and authentication, and how to sign them.  We will next
learn how to encourage miners to confirm them by adding fees to the
transactions we create.</p>
</div>
</div></div>
  <span></span> <!-- for IntersectionObserver -->
  
  
  
  


<style id="note-styling">
    .note {
      position: absolute;
      z-index: 10;
      border: none;
      outline: none;
      font-family: inherit;
      font-size: inherit;
      padding: 5px;
      min-width: 32px;
      min-height: 32px;
    }
    .note:focus {
      z-index: 11;
    }
    .note[type="0"] {
      background-color: #fff740;
      color: #2c2c2d;
    }
    .note[type="0"]::placeholder {
      color: #868226;
    }
    .note[type="1"] {
      background-color: #feff9c;
      color: #2c2c2d;
    }
    .note[type="1"]::placeholder {
      color: #6d6d3d;
    }
    .note[type="2"] {
      background-color: #ff65a3;
      color: #2c2c2d;
    }
    .note[type="2"]::placeholder {
      color: #65263f;
    }
    .note[type="3"] {
      background-color: #ff7eb9;
      color: #2c2c2d;
    }
    .note[type="3"]::placeholder {
      color: #562b3f;
    }
    .note[type="4"] {
      background-color: #7afcff;
      color: #295c5d;
    }
    .note[type="4"]::placeholder {
      color: #377677;
    }</style><div id="chapters-container">
      <style>
        #chapters {
          display: grid;
          grid-template-columns: 1fr 1fr;
          margin: 2ch 0;
        }
        #chapters a {
          cursor: pointer;
        }
        #chapters a[href=""] {
          opacity: 0.5;
          pointer-events: none;
          color: inherit;
        }
        #chapters a:first-child {
          justify-self: start;
        }
        #chapters a:last-child {
          justify-self: end;
        }
      </style>
      <hr>
      <div id="chapters">
        <a href="" title="move to the previous chapter (Ctrl/Command + PageUp)">Previous Chapter</a>
        <a href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch09.html" title="move to the next chapter (Ctrl/Command + PageDown)">Next Chapter</a>
      </div>
    </div></body><style>body {
      font-size:  19px;
      font-family: Georgia, 'Times New Roman', serif;
      width: 600px;
    }
    p {
      text-align: justify
    }
    .page {
      line-height: 28.5px;
      column-count: unset;
    }
    h1, h2, h3 {
      line-height: initial;
    }</style></html>