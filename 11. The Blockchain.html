<!DOCTYPE html>
<html><head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <base target="_blank">
  <style>
/* latin */
@font-face {
  font-family: 'Comic Neue';
  font-style: normal;
  font-weight: 400;
  src: url(fonts/4UaHrEJDsxBrF37olUeD96rp57F2IwM.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
/* latin */
@font-face {
  font-family: 'Lexend Deca';
  font-style: normal;
  font-weight: 400;
  src: url(fonts/K2FifZFYk-dHSE0UPPuwQ7CrD94i-NCKm-U48M1wqxnDirZPl3v-.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
/* latin */
@font-face {
  font-family: 'Poppins';
  font-style: normal;
  font-weight: 400;
  src: url(fonts/pxiEyp8kv8JHgFVrJJfecnFHGPc.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

:root {
  --fg: #000; /* foreground  */
  --bg: #fff; /* background  */
  --bd: #000; /* border  */
  --lk: #006fa5; /* link */
  --lkv: #d33bf0; /* link visited */
  --hg: #ffff81; /* highlight  */
}
html {
  overflow: overlay;
}
body {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  margin: 30px auto 0 auto;
  padding: 10px;
  position: relative;

  color: var(--fg);
  border-color: var(--bd);
  background-color: var(--bg);
}
body[data-mode$="dark"] {
  --lk: #0096de;
}
body[data-mode="light"] {
  color-scheme: light;
  --fg: #222;
  --bd: #222;
  --bg: whitesmoke;
}
body[data-mode="dark"] {
  color-scheme: dark;
  --fg: #eee;
  --bd: #eee;
  --bg: #333;
}
body[data-mode="sepia"] {
  color-scheme: light;
  --fg: #5b4636;
  --bd: #5b4636;
  --bg: #f4ecd8;
}
body[data-mode="solarized-light"] {
  color-scheme: light;
  --fg: #586e75;
  --bd: #586e75;
  --bg: #fdf6e3;
}
body[data-mode="nord-light"] {
  color-scheme: light;
  --fg: #2e3440;
  --bd: #2e3440;
  --bg: #e5e9f0;
}
body[data-mode="groove-dark"] {
  color-scheme: dark;
  --fg: #cec4ac;
  --bd: #cec4ac;
  --bg: #282828;
}
body[data-mode="solarized-dark"] {
  color-scheme: dark;
  --fg: #839496;
  --bd: #839496;
  --bg: #002b36;
}
body[data-mode="nord-dark"] {
  color-scheme: dark;
  --fg: #e5e9f0;
  --bd: #e5e9f0;
  --bg: #2e3440;
}

@media print {
  body[data-mode] {
    --fg: #000;
    --bd: #000;
    --bg: #fff;

    width: unset;
    padding: 0;
    margin: 0;
  }
}
body[data-loaded=true] {
  
}
img {
  max-width: 100%;
  height: auto;
}
img:not([width])[src$=".svg"] {
  max-width: 100px;
}
body[data-images=false] canvas,
body[data-images=false] svg,
body[data-images=false] img {
  display: none;
}
svg:not([width]):not([height]) {
  max-width: 25vmin;
}
a {
  color: var(--lk);
  text-decoration: none;
}
a:visited {
  color: var(--lkv);
}

hr {
  background-color: var(--bd);
  height: 1px;
  border: 0;
}
#reader-domain {
  font-family: Helvetica, Arial, sans-serif;
  text-decoration: none;
  border-bottom-color: currentcolor;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  width: 100%;
  display: inline-block;
  direction: ltr;
}
#reader-domain > span:first-child {
  font-size: 1.1em;
}
#reader-domain > span:last-child {
  font-size: 0.8em;
}
#reader-title {
  font-size: 1.6em;
  line-height: 1.25em;
  width: 100%;
  margin: 20px 0;
  padding: 0;
}
#reader-credits,
#doi,
#published-time,
#reader-estimated-time {
  font-size: 0.85em;
  line-height: 1.48em;
  margin: 0 0 10px 0;
  padding: 0;
}
#reader-credits:not(:empty)::after {
  content: ' ⋮ ';
}
#published-time:not(:empty)::before {
  content: ' ⋮ ';
}
#doi-json {
  overflow: hidden;
}
#doi-json code {
  overflow: auto;
  max-height: 400px;
}
#published-time:empty,
#reader-credits:empty {
  display: none;
}
mark.hghlght {
  background-color: var(--hg);
}
body:not([data-columns="1"]) .page :is(h1, h2) {
  column-span: all;
  background-color: rgba(125, 125, 125, 0.1);
  padding: 10px;
}
.hidden {
  display: none;
}
</style>
  <style id="user-css">body {
  padding-bottom: 64px;
}
pre {
  white-space: pre-wrap;
}
pre code {
  background-color: #eff0f1;
  color: #393318;
  font-family: monospace;
  display: block;
  padding: 5px 10px;
}
body[data-mode="dark"] pre code {
  background-color: #585858;
  color: #e8e8e8;
}

/* CSS for sans-serif fonts */
body[data-font=sans-serif] {}
/* CSS for serif fonts */
body[data-font=serif] {}

/* CSS for "sepia" theme */
body[data-mode=sepia] {}
/* CSS for "light" theme */
body[data-mode=light] {}
/* CSS for "dark" theme */
body[data-mode=dark] {}</style>
<title>11. The Blockchain</title><title>11. The Blockchain :: Reader View</title></head>
<body tabindex="1" data-images="true" data-mode="groove-dark" data-font="serif" data-columns="1" data-loaded="true">
  <span></span> <!-- for IntersectionObserver -->
  <a id="reader-domain" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch11.html">
    <span>learning.oreilly.com</span>
    <span>/library/view/mastering-bitcoin-3rd/9781098150082/ch11.html</span>
  </a>
  <h1 dir="auto" id="reader-title">11. The Blockchain</h1>
  <span dir="auto" id="reader-credits"></span>
  <span dir="auto" id="reader-estimated-time">28-36 minutes</span>
  <span dir="auto" id="published-time"></span>
  <hr>
  <div id="readability-page-1" class="page"><div id="sbo-rt-content" data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 11. The Blockchain">
<h2><span>Chapter 11. </span>The Blockchain</h2>


<p>The <a data-type="indexterm" data-primary="blockchain" data-secondary="explained" id="blockchain-explain" target="_blank" rel="noopener noreferrer"></a>blockchain is the history of every confirmed Bitcoin transaction.
It’s what allows every full node to independently determine what keys and
scripts control which bitcoins.  In this chapter, we’ll look at the
structure of the blockchain and see how it uses cryptographic
commitments and other clever tricks to make every part of it easy for
full nodes (and sometimes lightweight clients) to validate.</p>

<p>The blockchain data structure is
an ordered, back-linked list of blocks of transactions.  The blockchain
can be stored as a flat file or in a simple database.
Blocks are linked “back,” each referring to the previous block in the
chain. The blockchain is often visualized
as a vertical stack, with blocks layered on top of each other and the
first block serving as the foundation of the stack. The visualization of
blocks stacked on top of each other results in the use of terms such as
“height” to refer to the distance from the first block, and “top” or
“tip” to refer to the most recently added block.</p>

<p>Each block
within the blockchain is identified by a hash, generated using the
SHA256 cryptographic hash algorithm on the header of the block. Each
block also commits to the previous block, known as <a data-type="indexterm" data-primary="parent blocks" id="id1177" target="_blank" rel="noopener noreferrer"></a>the <em>parent</em> block,
through the “previous block hash” field in the block header.
The sequence of hashes linking each block to its parent creates a chain
going back all the way to the first block ever created, known <a data-type="indexterm" data-primary="genesis block" id="id1178" target="_blank" rel="noopener noreferrer"></a>as the
<em>genesis block</em>.</p>

<p>Although a block has just one parent, it can have <a data-type="indexterm" data-primary="child blocks" id="id1179" target="_blank" rel="noopener noreferrer"></a>multiple
children. Each of the children commits to the same parent block.
Multiple children arise during a blockchain “fork,” a temporary
situation that can occur when different blocks are discovered almost
simultaneously by different miners (see <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch12.html#forks" target="_blank" rel="noopener noreferrer">“Assembling and Selecting Chains of Blocks”</a>). Eventually only one
child block becomes part of the blockchain accepted by all full nodes, and the “fork” is resolved.</p>

<p>The “previous block hash” field is inside the block header and thereby
affects the <em>current</em> block’s hash.
Any change to a parent block
requires a child block’s hash to change, which requires a change in the
pointer of the grandchild, which in turn changes the grandchild, and so
on. This sequence ensures that, once a block has many generations
following it, it cannot be changed without forcing a recalculation of
all subsequent blocks. Because such a recalculation would require
enormous computation (and therefore energy consumption), the existence
of a long chain of blocks makes the blockchain’s deep history impractical to change,
which is a key feature of Bitcoin’s security.</p>

<p>One way to think about the blockchain is like layers in a geological
formation, or glacier core sample. The surface layers might change with
the seasons, or even be blown away before they have time to settle. But
once you go a few inches deep, geological layers become more and more
stable. By the time you look a few hundred feet down, you are looking at
a snapshot of the past that has remained undisturbed for millions of
years. In the blockchain, the most recent few blocks might be revised if
there is a chain reorganization due to a fork. The top six blocks are
like a few inches of topsoil. But once you go more deeply into the
blockchain, beyond six blocks, blocks are less and less likely to
change. After 100 blocks back there is so much stability that
the coinbase transaction—​the transaction containing the reward in
bitcoin for creating a new block—​can be spent.
While the
protocol always allows a chain to be undone by a longer chain and while
the possibility of any block being reversed always exists, the
probability of such an event decreases as time passes until it <a data-type="indexterm" data-primary="blockchain" data-secondary="explained" data-startref="blockchain-explain" id="id1180" target="_blank" rel="noopener noreferrer"></a>becomes
infinitesimal.</p>






<div id="id269" data-type="sect1" data-pdf-bookmark="Structure of a Block">
<h2>Structure of a Block</h2>

<p>A block <a data-type="indexterm" data-primary="blocks" data-secondary="structure of" id="id1181" target="_blank" rel="noopener noreferrer"></a>is a container data structure that aggregates
transactions for inclusion in the blockchain. The
block is made of a header, containing metadata, followed by a long list
of transactions that make up the bulk of its size. The block header is
80 bytes, whereas the total size of all transactions in a block can be
up to about 4,000,000 bytes.  A complete block,
with all transactions, can therefore be almost 50,000 times larger than the block
header. <a data-type="xref" href="#block_structure1" target="_blank" rel="noopener noreferrer">Table&nbsp;11-1</a> describes how Bitcoin Core stores the structure of a block.</p>
<table id="block_structure1"><caption><span>Table 11-1. </span>The structure of a block</caption><thead><tr><th>Size</th><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p>4 bytes</p></td><td><p>Block Size</p></td><td><p>The size of the block, in bytes, following this field</p></td></tr><tr><td><p>80 bytes</p></td><td><p>Block Header</p></td><td><p>Several fields form the block header</p></td></tr><tr><td><p>1–3 bytes (compactSize)</p></td><td><p>Transaction Counter</p></td><td><p>How many transactions follow</p></td></tr><tr><td><p>Variable</p></td><td><p>Transactions</p></td><td><p>The transactions recorded in this block</p></td></tr></tbody></table>
</div>













<div id="block_hash" data-type="sect1" data-pdf-bookmark="Block Identifiers: Block Header Hash and Block Height">
<h2>Block Identifiers: Block Header Hash and Block Height</h2>

<p>The <a data-type="indexterm" data-primary="blocks" data-secondary="identifiers" id="block-identify" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="block header hash" id="block-header-hash" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="block height" id="block-height" target="_blank" rel="noopener noreferrer"></a>primary identifier of a block
is its cryptographic hash, a commitment made by hashing the
block header twice through the SHA256 algorithm. The resulting 32-byte
hash is called the <em>block hash</em> but is more accurately the <em>block header
hash</em>, <span>because only the block header is
used to compute it. For example,</span>
<code>000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f</code> is
the block hash of the first block on Bitcoin’s blockchain. The block hash
identifies a block uniquely and unambiguously and can be independently
derived by any node by simply hashing the block header.</p>

<p>Note that the block hash is not actually included inside the block’s
data structure.
Instead, the block’s hash is computed by each node as the
block is received from the network. The block hash might be stored in a
separate database table as part of the block’s metadata, to facilitate
indexing and faster retrieval of blocks from disk.</p>

<p>A second way to identify a block is by its position in the blockchain,
called the <span><em>block height</em>. The
genesis block is at block height 0 (zero) and is the</span>
<span>same block that was previously
referenced by the following block hash</span>
<code>000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f</code>. A
block can thus be identified in two ways: by referencing the block hash
or by referencing the block height. Each subsequent block added “on top”
of that first block is one position “higher” in the blockchain, like
boxes stacked one on top of the other. The block height 800,000 was
reached during the writing of this book in mid-2023, meaning there were
800,000 blocks stacked on top of the first block created in January
2009.</p>

<p>Unlike the block hash, the block height is not a unique identifier.
Although a single block will always have a specific and invariant block
height, the reverse is not true—the block height does not always
identify a single block. Two or more blocks might have the same block
height, competing for the same position in the blockchain. This scenario
is discussed in detail in the section <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch12.html#forks" target="_blank" rel="noopener noreferrer">“Assembling and Selecting Chains of Blocks”</a>.  In early blocks, the block height was
also not a part of the block’s data structure; it was not stored within
the block. Each node dynamically identified a block’s position (height)
in the blockchain when it was received from the Bitcoin network.  A
later protocol change (BIP34) began including the block height in the
coinbase transaction, although its purpose was to ensure each block had
a different coinbase transaction.  Nodes still need to dynamically
identify a block’s height in order to validate the coinbase field.  The
block height might also be stored as metadata in an indexed database
table for faster retrieval.</p>
<div data-type="tip"><h6>Tip</h6>
<p>A block’s <em>block hash</em> always identifies a single block uniquely. A
block also always has a specific <em>block height</em>. However, it is not
always the case that a specific block height identifies a single
block. Rather, two or more blocks might compete for a single position<a data-type="indexterm" data-primary="blocks" data-secondary="identifiers" data-startref="block-identify" id="id1184" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="block header hash" data-startref="block-header-hash" id="id1185" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="block height" data-startref="block-height" id="id1186" target="_blank" rel="noopener noreferrer"></a> in
the blockchain.</p>
</div>
</div>






<div id="id172" data-type="sect1" data-pdf-bookmark="The Genesis Block">
<h2>The Genesis Block</h2>

<p>The first block<a data-type="indexterm" data-primary="blockchain" data-secondary="genesis block" id="blockchain-genesis" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="genesis block" id="genesis-block" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="Bitcoin Core" data-secondary="genesis block" id="bitcoin-core-genesis" target="_blank" rel="noopener noreferrer"></a> in the blockchain is called the <em>genesis block</em>
and was created in 2009. It is the common ancestor of all the blocks in
the blockchain, meaning that if you start at any block and follow the
chain backward in time, you will eventually arrive at the genesis block.</p>

<p>Every node always starts with a blockchain of at least one block because
the genesis block is statically encoded within Bitcoin Core,
such that it cannot be altered. Every node always “knows” the
genesis block’s hash and structure, the fixed time it was created, and
even the single transaction within. Thus, every node has the starting
point for the blockchain, a secure “root” from which to build a trusted
blockchain.</p>

<p>See the statically encoded genesis block inside the Bitcoin Core client
in <a href="https://oreil.ly/FqPW5" target="_blank" rel="noopener noreferrer"><em>chainparams.cpp</em></a>.</p>

<p>The following identifier hash belongs to the genesis block:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f</pre></div>

<p>You can search for that block hash in almost any block explorer website, such
as <em>blockstream.info</em>, and you will find a page describing the contents
of this block, with a URL containing that hash:</p>
<blockquote>
<p><a href="https://blockstream.info/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f" target="_blank" rel="noopener noreferrer"><em>https://blockstream.info/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f</em></a></p></blockquote>

<p>Alternatively, you can get the block using Bitcoin Core on the command line:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">$ bitcoin-cli getblock \
  000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f</pre></div>

<div data-testid="custom pre block"><pre data-type="programlisting" data-code-language="json"><code>{</code><code></code>
<code>  </code><code>"hash"</code><code>:</code><code> </code><code>"000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f"</code><code>,</code><code></code>
<code>  </code><code>"confirmations"</code><code>:</code><code> </code><code>790496</code><code>,</code><code></code>
<code>  </code><code>"height"</code><code>:</code><code> </code><code>0</code><code>,</code><code></code>
<code>  </code><code>"version"</code><code>:</code><code> </code><code>1</code><code>,</code><code></code>
<code>  </code><code>"versionHex"</code><code>:</code><code> </code><code>"00000001"</code><code>,</code><code></code>
<code>  </code><code>"merkleroot"</code><code>:</code><code> </code><code>"4a5e1e4baab89f3a32518a88c3[...]76673e2cc77ab2127b7afdeda33b"</code><code>,</code><code></code>
<code>  </code><code>"time"</code><code>:</code><code> </code><code>1231006505</code><code>,</code><code></code>
<code>  </code><code>"mediantime"</code><code>:</code><code> </code><code>1231006505</code><code>,</code><code></code>
<code>  </code><code>"nonce"</code><code>:</code><code> </code><code>2083236893</code><code>,</code><code></code>
<code>  </code><code>"bits"</code><code>:</code><code> </code><code>"1d00ffff"</code><code>,</code><code></code>
<code>  </code><code>"difficulty"</code><code>:</code><code> </code><code>1</code><code>,</code><code></code>
<code>  </code><code>"chainwork"</code><code>:</code><code> </code><code>"[...]000000000000000000000000000000000000000000000100010001"</code><code>,</code><code></code>
<code>  </code><code>"nTx"</code><code>:</code><code> </code><code>1</code><code>,</code><code></code>
<code>  </code><code>"nextblockhash"</code><code>:</code><code> </code><code>"00000000839a8e6886ab5951d7[...]fc90947ee320161bbf18eb6048"</code><code>,</code><code></code>
<code>  </code><code>"strippedsize"</code><code>:</code><code> </code><code>285</code><code>,</code><code></code>
<code>  </code><code>"size"</code><code>:</code><code> </code><code>285</code><code>,</code><code></code>
<code>  </code><code>"weight"</code><code>:</code><code> </code><code>1140</code><code>,</code><code></code>
<code>  </code><code>"tx"</code><code>:</code><code> </code><code>[</code><code></code>
<code>    </code><code>"4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b"</code><code></code>
<code>  </code><code>]</code><code></code>
<code>}</code><code></code></pre></div>

<p>The genesis block contains a message within it. The coinbase
transaction input contains the text “The Times 03/Jan/2009 Chancellor on
brink of second bailout for banks.” This message was intended to offer
proof of the earliest date this block could have been created, by referencing the
headline of the British newspaper <em>The Times</em>. It also serves as a
tongue-in-cheek reminder of the importance of an independent monetary
system, with Bitcoin’s launch occurring at the same time as an
unprecedented worldwide monetary crisis. The message was embedded in the
first block by Satoshi Nakamoto, Bitcoin’s <a data-type="indexterm" data-primary="Nakamoto, Satoshi" id="id1187" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="blockchain" data-secondary="genesis block" data-startref="blockchain-genesis" id="id1188" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="genesis block" data-startref="genesis-block" id="id1189" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="Bitcoin Core" data-secondary="genesis block" data-startref="bitcoin-core-genesis" id="id1190" target="_blank" rel="noopener noreferrer"></a>creator.</p>
</div>






<div id="id173" data-type="sect1" data-pdf-bookmark="Linking Blocks in the Blockchain">
<h2>Linking Blocks in the Blockchain</h2>

<p>Bitcoin<a data-type="indexterm" data-primary="blockchain" data-secondary="linking blocks" id="blockchain-link" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="blocks" data-secondary="linking in blockchain" id="block-link" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="linking blocks in blockchain" id="link-block" target="_blank" rel="noopener noreferrer"></a> full nodes validate every
block in the blockchain after the genesis block. Their local view of
the blockchain is constantly updated as new blocks are found and used to
extend the chain. As a node receives incoming blocks from the network,
it will validate these blocks and then link them to its view of the existing
blockchain. To establish a link, a node will examine the incoming block
header and look for the “previous block hash.”</p>

<p>Let’s assume, for example, that a node has 277,314 blocks in the local
copy of the blockchain. The last block the node knows about is block
277,314, with a block header hash of:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249</pre></div>

<p>The Bitcoin node then receives a new block from the network, which it
parses as follows:</p>

<div data-testid="custom pre block"><pre data-type="programlisting" data-code-language="json"><code>{</code><code></code>
<code>    </code><code>"size"</code><code> </code><code>:</code><code> </code><code>43560</code><code>,</code><code></code>
<code>    </code><code>"version"</code><code> </code><code>:</code><code> </code><code>2</code><code>,</code><code></code>
<code>    </code><code>"previousblockhash"</code><code> </code><code>:</code><code></code>
<code>        </code><code>"00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249"</code><code>,</code><code></code>
<code>    </code><code>"merkleroot"</code><code> </code><code>:</code><code></code>
<code>        </code><code>"5e049f4030e0ab2debb92378f53c0a6e09548aea083f3ab25e1d94ea1155e29d"</code><code>,</code><code></code>
<code>    </code><code>"time"</code><code> </code><code>:</code><code> </code><code>1388185038</code><code>,</code><code></code>
<code>    </code><code>"difficulty"</code><code> </code><code>:</code><code> </code><code>1180923195.25802612</code><code>,</code><code></code>
<code>    </code><code>"nonce"</code><code> </code><code>:</code><code> </code><code>4215469401</code><code>,</code><code></code>
<code>    </code><code>"tx"</code><code> </code><code>:</code><code> </code><code>[</code><code></code>
<code>        </code><code>"257e7497fb8bc68421eb2c7b699dbab234831600e7352f0d9e6522c7cf3f6c77"</code><code>,</code><code></code>
<code>        </code><code>"[... many more transactions omitted ...]"</code><code>,</code><code></code>
<code>        </code><code>"05cfd38f6ae6aa83674cc99e4d75a1458c165b7ab84725eda41d018a09176634"</code><code></code>
<code>    </code><code>]</code><code></code>
<code>}</code><code></code></pre></div>

<p>Looking at this new block, the node finds the <code>previousblockhash</code> field,
which contains the hash of its parent block. It is a hash known to the
node, that of the last block on the chain at height 277,314. Therefore,
this new block is a child of the last block on the chain and extends the
existing blockchain. The node adds this new block to the end of the
chain, making the blockchain longer with a new height of 277,315.
<a data-type="xref" href="#chain_of_blocks" target="_blank" rel="noopener noreferrer">Figure&nbsp;11-1</a> shows the chain of three blocks, linked by
references in<a data-type="indexterm" data-primary="blockchain" data-secondary="linking blocks" data-startref="blockchain-link" id="id1191" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="blocks" data-secondary="linking in blockchain" data-startref="block-link" id="id1192" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="linking blocks in blockchain" data-startref="link-block" id="id1193" target="_blank" rel="noopener noreferrer"></a> the <code>previousblockhash</code> field.</p>

<figure><div id="chain_of_blocks">
<p><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098150082/files/assets/mbc3_1101.png" alt="" width="359" height="800"></p><h6><span>Figure 11-1. </span>Blocks linked in a chain by each referencing the previous block header hash.</h6>
</div></figure>
</div>






<div id="merkle_trees" data-type="sect1" data-pdf-bookmark="Merkle Trees">
<h2>Merkle Trees</h2>

<p>Each block<a data-type="indexterm" data-primary="blockchain" data-secondary="merkle trees" id="blockchain-merkle" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="merkle trees" id="merkle-tree-explain" target="_blank" rel="noopener noreferrer"></a> in the Bitcoin blockchain contains
a summary of all the transactions in the block using a <em>merkle tree</em>.</p>

<p>A <em>merkle tree</em>, also known
as a <em>binary hash tree</em>, is <a data-type="indexterm" data-primary="binary hash trees" id="id1194" target="_blank" rel="noopener noreferrer"></a>a data structure used for efficiently
summarizing and verifying the integrity of large sets of data. Merkle
trees are binary trees containing cryptographic hashes. The term “tree”
is used in computer science to describe a branching data structure, but
these trees are usually displayed upside down with the “root” at the top
and the “leaves” at the bottom of a diagram, as you will see in the
examples that follow.</p>

<p>Merkle trees are used in Bitcoin to summarize all the transactions in a
block, producing an overall commitment to the entire set of
transactions and permitting a very efficient process to verify whether a
transaction is included in a block. A merkle tree is constructed by
recursively hashing pairs of elements until there is only one hash, called
the <em>root</em>, or <em>merkle root</em>. The cryptographic hash algorithm used in
Bitcoin’s merkle trees is SHA256 applied twice, also known as
double-SHA256.</p>

<p>When N data elements are hashed and summarized in a merkle tree, you can
check to see if any one data element is included in the tree with
about <code>log<sub>2</sub>(N)</code> calculations, making this a very efficient data
structure.</p>

<p>The merkle tree is constructed bottom-up. In the following example, we
start with four transactions, A, B, C, and D, which form the <em>leaves</em> of
the merkle tree, as shown in <a data-type="xref" href="#simple_merkle" target="_blank" rel="noopener noreferrer">Figure&nbsp;11-2</a>. The transactions are not
stored in the merkle tree; rather, their data is hashed and the
resulting hash is stored in each leaf node as H<sub>A</sub>, H<sub>B</sub>, H<sub>C</sub>, and
H<sub>D</sub>:</p>
<div data-testid="custom pre block"><pre data-type="codelisting">H<sub>A</sub> = SHA256(SHA256(Transaction A))
</pre></div>

<p>Consecutive pairs of leaf nodes are then summarized in a parent node by
concatenating the two hashes and hashing them together. For example, to
construct the parent node H<sub>AB</sub>, the two 32-byte hashes of the children
are concatenated to create a 64-byte string. That string is then
double-hashed to produce the parent node’s hash:</p>
<div data-testid="custom pre block"><pre data-type="codelisting">H<sub>AB</sub> = SHA256(SHA256(H<sub>A</sub> || H<sub>B</sub>))
</pre></div>

<p>The process continues until there is only one node at the top, the node
known as the merkle root. That 32-byte hash is stored in the block
header and summarizes all the data in all four transactions.
<a data-type="xref" href="#simple_merkle" target="_blank" rel="noopener noreferrer">Figure&nbsp;11-2</a> shows how the root is calculated by pair-wise hashes
of the nodes.</p>

<figure><div id="simple_merkle">
<p><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098150082/files/assets/mbc3_1102.png" alt="" width="600" height="309"></p><h6><span>Figure 11-2. </span>Calculating the nodes in a merkle tree.</h6>
</div></figure>

<p>Because the merkle tree is a binary tree, it needs
an even number of leaf nodes. If there are an odd number of transactions
to summarize, the last transaction hash will be duplicated to create an
even number of leaf nodes, also known <a data-type="indexterm" data-primary="balanced merkle trees" id="id1195" target="_blank" rel="noopener noreferrer"></a>as a <em>balanced tree</em>. This is
shown in <a data-type="xref" href="#merkle_tree_odd" target="_blank" rel="noopener noreferrer">Figure&nbsp;11-3</a>, where transaction C is duplicated.
Similarly, if there are an odd number of hashes to process at any level,
the last hash is duplicated.</p>

<figure><div id="merkle_tree_odd">
<p><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098150082/files/assets/mbc3_1103.png" alt="" width="600" height="309"></p><h6><span>Figure 11-3. </span>Duplicating one data element achieves an even number of data elements.</h6>
</div></figure>


<p>The same method for constructing a tree from four transactions can be
generalized to construct trees of any size. In Bitcoin it is common to
have several thousand transactions in a single
block, which are summarized in exactly the same way, producing just 32
bytes of data as the single merkle root. In <a data-type="xref" href="#merkle_tree_large" target="_blank" rel="noopener noreferrer">Figure&nbsp;11-5</a>, you
will see a tree built from 16 transactions. Note that although the root
looks bigger than the leaf nodes in the diagram, it is the exact same
size, just 32 bytes. Whether there is one transaction or ten
thousand transactions in the block, the merkle root always summarizes
them into 32 bytes.</p>

<p>To prove that a specific transaction is
included in a block, a node only needs to produce approximately <code>log<sub>2</sub>(N)</code> 32-byte
hashes, constituting <a data-type="indexterm" data-primary="authentication path" id="id1197" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="merkle path" id="id1198" target="_blank" rel="noopener noreferrer"></a>an <em>authentication path</em> or <em>merkle path</em>
connecting the specific transaction to the root of the tree. This is
especially important as the number of transactions increases because
the base-2 logarithm of the number of transactions increases much more
slowly. This allows Bitcoin nodes to efficiently produce paths of 10 or
12 hashes (320–384 bytes), which can provide proof of a single
transaction out of more than a thousand transactions in a multimegabyte
block.</p>

<figure><div id="merkle_tree_large">
<p><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098150082/files/assets/mbc3_1105.png" alt="" width="600" height="248"></p><h6><span>Figure 11-5. </span>A merkle tree summarizing many data elements.</h6>
</div></figure>

<p>In <a data-type="xref" href="#merkle_tree_path" target="_blank" rel="noopener noreferrer">Figure&nbsp;11-6</a>, a node can prove that a transaction K is
included in the block by producing a merkle path that is only four
32-byte hashes long (128 bytes total). The path consists of the four
hashes (shown with a shaded background) H<sub>L</sub>,
H<sub>IJ</sub>, H<sub>MNOP</sub>, and H<sub>ABCDEFGH</sub>. With those four hashes provided as an
authentication path, any node can prove that H<sub>K</sub> (with a black
background at the bottom of the diagram) is included in the merkle root
by computing four additional pair-wise hashes H<sub>KL</sub>, H<sub>IJKL</sub>,
H<sub>IJKLMNOP</sub>, and the merkle tree root (outlined in a dashed line in the
diagram).</p>

<figure><div id="merkle_tree_path">
<p><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098150082/files/assets/mbc3_1106.png" alt="" width="600" height="248"></p><h6><span>Figure 11-6. </span>A merkle path used to prove inclusion of a data element.</h6>
</div></figure>

<p>The efficiency of merkle trees becomes obvious as the scale increases.
The largest possible block can hold almost 16,000 transactions in 4,000,000
bytes, but proving any particular one of those 16,000 transactions
is a part of that block only requires a copy of the transaction, a copy
of the 80-byte block header, and 448 bytes for the merkle proof.  That
makes the largest possible proof almost 10,000 times smaller than the
largest possible Bitcoin block.</p>
</div>






<div id="id175" data-type="sect1" data-pdf-bookmark="Merkle Trees and Lightweight Clients">
<h2>Merkle Trees and Lightweight Clients</h2>

<p>Merkle trees are <a data-type="indexterm" data-primary="Bitcoin network" data-secondary="lightweight clients" data-tertiary="merkle trees and" id="id1199" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="lightweight clients" data-secondary="merkle trees and" id="id1200" target="_blank" rel="noopener noreferrer"></a>used extensively by lightweight clients. Lightweight clients don’t
have all transactions and do not download full blocks, just block
headers. In order to verify that a transaction is included in a block,
without having to download all the transactions in the block, they use
a merkle path.</p>

<p>Consider, for example, a lightweight client that is interested in incoming
payments to an address contained in its wallet. The lightweight client will
establish a bloom filter (see <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch10.html#bloom_filters" target="_blank" rel="noopener noreferrer">“Bloom Filters”</a>) on its connections to
peers to limit the transactions received to only those containing
addresses of interest. When a peer sees a transaction that matches the
bloom filter, it will send that block using a <code>merkleblock</code> message. The
<code>merkleblock</code> message contains the block header as well as a merkle path
that links the transaction of interest to the merkle root in the block.
The lightweight client can use this merkle path to connect the transaction to the
block header and verify that the transaction is included in the block. The lightweight
client also uses the block header to link the block to the rest of the
blockchain. The combination of these two links, between the transaction
and block and between the block and blockchain, proves that the
transaction is recorded in the blockchain. All in all, the lightweight client will
have received less than a kilobyte of data for the block header and
merkle path, an amount of data that is more than a thousand times less
than a full block (about 2 MB <a data-type="indexterm" data-primary="blockchain" data-secondary="merkle trees" data-startref="blockchain-merkle" id="id1201" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="merkle trees" data-startref="merkle-tree-explain" id="id1202" target="_blank" rel="noopener noreferrer"></a>currently).</p>
</div>






<div id="id176" data-type="sect1" data-pdf-bookmark="Bitcoin’s Test Blockchains">
<h2>Bitcoin’s Test Blockchains</h2>

<p>You might be
surprised to learn that there is more than one blockchain used with Bitcoin. The
“main” Bitcoin blockchain, the one created by Satoshi Nakamoto on
January 3rd, 2009, the one with the genesis block we studied in this
chapter, is <a data-type="indexterm" data-primary="mainnet" id="id1203" target="_blank" rel="noopener noreferrer"></a>called <em>mainnet</em>.  There are other Bitcoin blockchains that
are used for testing purposes: at this time <em>testnet</em>, <em>signet</em>, and
<em>regtest</em>. Let’s look at each in turn.</p>








<div id="id177" data-type="sect2" data-pdf-bookmark="Testnet: Bitcoin’s Testing Playground">
<h2>Testnet: Bitcoin’s Testing Playground</h2>

<p>Testnet is <a data-type="indexterm" data-primary="blockchain" data-secondary="test blockchains" data-tertiary="testnet" id="blockchain-test-testnet" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="test blockchains" data-secondary="testnet" id="test-block-testnet" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="testnet" id="testnet" target="_blank" rel="noopener noreferrer"></a>the name of the test blockchain, network, and currency that
is used for testing purposes. The testnet is a fully featured live P2P
network, with wallets, test bitcoins (testnet coins), mining, and all
the other features of mainnet.  The most important difference is that
testnet coins are meant to be worthless.</p>

<p>Any software development that is intended for production use on
Bitcoin’s mainnet can first be tested on testnet with test coins.
This protects both the developers from monetary losses due to bugs and
the network from unintended behavior due to bugs.</p>

<p>The current testnet is called <em>testnet3</em>, the third iteration of
testnet, restarted in February 2011 to reset the difficulty from the
previous testnet.  Testnet3 is a large blockchain, in excess of 30 GB in
2023. It will take a while to sync fully and use up resources
on your computer. Not as much as mainnet, but not exactly “lightweight”
either.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Testnet and the other test blockchains described in this book don’t use
the same address prefixes as mainnet addresses to prevent someone from
accidentally sending real bitcoins to a test address.  Mainnet addresses
begin with <code>1</code>, <code>3</code>, or <code>bc1</code>.  Addresses for the test networks
mentioned in this book begin with <code>m</code>, <code>n</code>, or <code>tb1</code>.  Other test
networks, or new protocols being developed on test networks, may use
other address prefixes or alterations.</p>
</div>










<div id="id270" data-type="sect3" data-pdf-bookmark="Using testnet">
<h3>Using testnet</h3>

<p>Bitcoin Core, like<a data-type="indexterm" data-primary="Bitcoin Core" data-secondary="testnet" id="id1204" target="_blank" rel="noopener noreferrer"></a> many other Bitcoin programs, has full support
for operation on testnet as an alternative mainnet. All of Bitcoin Core’s
functions work on testnet, including the wallet, mining testnet coins,
and syncing a full testnet node.</p>

<p>To start Bitcoin Core on testnet instead of mainnet you use the
<code>testnet</code> switch:</p>



<p>In the logs you should see that bitcoind is building a new blockchain in
the <code>testnet3</code> subdirectory of the default bitcoind directory:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">bitcoind: Using data directory /home/username/.bitcoin/testnet3</pre></div>

<p>To connect to bitcoind, you use the <code>bitcoin-cli</code> command-line tool, but
you must also switch it to testnet mode:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">$ bitcoin-cli -testnet getblockchaininfo
{
  "chain": "test",
  "blocks": 1088,
  "headers": 139999,
  "bestblockhash": "0000000063d29909d475a1c[...]368e56cce5d925097bf3a2084370128",
  "difficulty": 1,
  "mediantime": 1337966158,
  "verificationprogress": 0.001644065914099759,
  "chainwork": "[...]000000000000000000000000000000000000000000044104410441",
  "pruned": false,
  "softforks": [

  [...]</pre></div>

<p>You can also run on testnet3 with other full-node implementations, such
as <code>btcd</code> (written in Go) and <code>bcoin</code> (written in JavaScript), to
experiment and learn in other programming languages and frameworks.</p>

<p>Testnet3 supports all the features of mainnet, including
segregated witness v0 and v1 (see <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch06.html#segwit" target="_blank" rel="noopener noreferrer">“Segregated Witness”</a> and <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch07.html#taproot" target="_blank" rel="noopener noreferrer">“Taproot”</a>). Therefore, testnet3 can also be
used to test segregated witness features.</p>
</div>










<div id="id178" data-type="sect3" data-pdf-bookmark="Problems with testnet">
<h3>Problems with testnet</h3>

<p>Testnet doesn’t just use the same data structures as Bitcoin, it also
uses almost exactly the same proof-of-work security mechanism as
Bitcoin.  The notable differences for testnet are that its minimum
difficulty is half that of Bitcoin and that it’s allowed to include a
block at the minimum difficulty if that block’s timestamp is more than
20 minutes after the previous block.</p>

<p>Unfortunately, Bitcoin’s PoW security mechanism was designed to depend
on economic incentives—​incentives which don’t exist in a test
blockchain that is forbidden from having value.  On mainnet, miners are
incentivized to include user transactions in their blocks because those
transactions pay fees.  On testnet, transactions still contain something
called fees, but those fees don’t have any economic value.  That means
the only incentive for a testnet miner to include transactions is
because they want to help users and developers to test their software.</p>

<p>Alas, people who like to disrupt systems often feel a stronger
incentive, at least in the short term.  Because PoW mining is designed
to be permissionless, anyone can mine, whether their intention is good
or not.  That means disruptive miners can create many blocks in a row on
testnet without including any user transactions.  When those attacks
happen, testnet becomes unusable for users and <a data-type="indexterm" data-primary="blockchain" data-secondary="test blockchains" data-tertiary="testnet" data-startref="blockchain-test-testnet" id="id1205" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="test blockchains" data-secondary="testnet" data-startref="test-block-testnet" id="id1206" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="testnet" data-startref="testnet" id="id1207" target="_blank" rel="noopener noreferrer"></a>developers.</p>
</div>
</div>








<div id="id179" data-type="sect2" data-pdf-bookmark="Signet: The Proof of Authority Testnet">
<h2>Signet: The Proof of Authority Testnet</h2>

<p>There’s no <a data-type="indexterm" data-primary="blockchain" data-secondary="test blockchains" data-tertiary="signet" id="blockchain-test-signet" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="test blockchains" data-secondary="signet" id="test-block-signet" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="signet" id="signet" target="_blank" rel="noopener noreferrer"></a>known way for a system dependent on permissionless PoW to
provide a highly usable blockchain without introducing economic
incentives, so Bitcoin protocol developers began considering
alternatives.  The primary goal was to preserve as much of the structure of
Bitcoin as possible so that software could run on a testnet with minimal
changes—​but to also provide an environment that would remain useful.
A secondary goal was to produce a reusable design that would allow
developers of new software to easily create their own test networks.</p>

<p>The solution implemented in Bitcoin Core and other software is called
<em>signet</em>, as defined by BIP325.  A signet is a test network where each
block must contain proof (such as a signature) that the creation of that
block was sanctioned by a trusted authority.</p>

<p>Whereas mining in Bitcoin is permissionless—​anyone can do it—​mining on
signet is fully permissioned.  Only those with permission can do it.
This would be a completely unacceptable change to Bitcoin’s mainnet—​no
one would use that software—​but it’s reasonable on a testnet where coins have
no value and the only purpose is testing software and systems.</p>

<p>BIP325 signets are designed to make it very easy to create your own.  If
you disagree with how someone else is running their signet, you can
start your own signet and connect your software to it.</p>










<div id="id180" data-type="sect3" data-pdf-bookmark="The default signet and custom signets">
<h3>The default signet and custom signets</h3>

<p>Bitcoin Core supports<a data-type="indexterm" data-primary="Bitcoin Core" data-secondary="signet" id="id1208" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="default signet" id="id1209" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="custom signets" id="id1210" target="_blank" rel="noopener noreferrer"></a> a default signet, which we believe to be the most
widely used signet at the time of writing.  It is currently operated by
two contributors to that project.  If you start Bitcoin Core with the
<code>signet</code> parameter and no other signet-related parameters, this is the
signet you will be using.</p>

<p>As of this writing, the default signet has about 150,000 blocks and is
about a gigabyte in size.  It supports all of the same features as
Bitcoin’s mainnet and is also used for testing proposed upgrades through
the Bitcoin Inquisition project, which is a software fork of Bitcoin
Core that’s only designed to run on signet.</p>

<p>If you want to use a different signet, called a <em>custom signet</em>, you
will need to know the script used to determine when a block is
authorized, called<a data-type="indexterm" data-primary="challenge script" id="id1211" target="_blank" rel="noopener noreferrer"></a> the <em>challenge</em> script.  This is a standard Bitcoin
script, so it can use features such as multisig to allow multiple people
to authorize blocks.  You may also need to connect to a seed node that
will provide you with the addresses of peers on the custom signet.  For
example:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">bitcoind -signet -signetchallenge=0123...cdef -signetseednode=example.com:1234</pre></div>

<p>As of this writing, we generally recommend that the public testing of
mining software occur on testnet3 and that all other public testing of
Bitcoin software occur on the default signet.</p>

<p>To interact with your chosen signet, you can use the <code>-signet</code> parameter
with <code>bitcoin-cli</code>, similar to how you used testnet.  For<a data-type="indexterm" data-primary="blockchain" data-secondary="test blockchains" data-tertiary="signet" data-startref="blockchain-test-signet" id="id1212" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="test blockchains" data-secondary="signet" data-startref="test-block-signet" id="id1213" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="signet" data-startref="signet" id="id1214" target="_blank" rel="noopener noreferrer"></a> example:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">$ bitcoin-cli -signet getblockchaininfo
{
  "chain": "signet",
  "blocks": 143619,
  "headers": 143619,
  "bestblockhash": "000000c46cb3505ddd296537[...]ad1c5768e2908439382447572a93",
  "difficulty": 0.003020638517858618,
  "time": 1684530244,
  "mediantime": 1684526116,
  "verificationprogress": 0.999997961940662,
  "initialblockdownload": false,
  "chainwork": "[...]000000000000000000000000000000000000000000019ab37d2194",
  "size_on_disk": 769525915,
  "pruned": false,
  "warnings": ""
}</pre></div>
</div>
</div>








<div id="id181" data-type="sect2" data-pdf-bookmark="Regtest: The Local Blockchain">
<h2>Regtest: The Local Blockchain</h2>

<p>Regtest, <a data-type="indexterm" data-primary="blockchain" data-secondary="test blockchains" data-tertiary="regtest" id="blockchain-test-regtest" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="test blockchains" data-secondary="regtest" id="test-block-regtest" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="regtest" id="regtest" target="_blank" rel="noopener noreferrer"></a>which stands for
“Regression Testing,” is a Bitcoin Core feature that allows you to
create a local blockchain for testing purposes. Unlike signet and testnet3, which
are public and shared test blockchains, the regtest blockchains are
intended to be run as closed systems for local testing. You launch a
regtest blockchain from scratch. You may
add other nodes to the network or run it with a single node only to
test the Bitcoin Core software.</p>

<p>To start <a data-type="indexterm" data-primary="Bitcoin Core" data-secondary="regtest" id="id1215" target="_blank" rel="noopener noreferrer"></a>Bitcoin Core in regtest mode, you use the <code>regtest</code> flag:</p>



<p>Just like with testnet, Bitcoin Core will initialize a new blockchain
under the <em>regtest</em> subdirectory of your bitcoind default directory:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">bitcoind: Using data directory /home/username/.bitcoin/regtest</pre></div>

<p>To use the command-line tool, you need to specify the <code>regtest</code> flag
too. Let’s try the <code>getblockchaininfo</code> command to inspect the regtest
blockchain:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">$ bitcoin-cli -regtest getblockchaininfo
{
  "chain": "regtest",
  "blocks": 0,
  "headers": 0,
  "bestblockhash": "0f9188f13cb7b2c71f2a335e3[...]b436012afca590b1a11466e2206",
  "difficulty": 4.656542373906925e-10,
  "mediantime": 1296688602,
  "verificationprogress": 1,
  "chainwork": "[...]000000000000000000000000000000000000000000000000000002",
  "pruned": false,
  [...]</pre></div>

<p>As you can see, there are no blocks yet. Let’s create a default wallet,
get an address, and then mine some (500 blocks) to earn the reward:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">$ bitcoin-cli -regtest createwallet ""

$ bitcoin-cli -regtest getnewaddress
bcrt1qwvfhw8pf79kw6tvpmtxyxwcfnd2t4e8v6qfv4a

$ bitcoin-cli -regtest generatetoaddress 500 \
  bcrt1qwvfhw8pf79kw6tvpmtxyxwcfnd2t4e8v6qfv4a
[
  "3153518205e4630d2800a4cb65b9d2691ac68eea99afa7fd36289cb266b9c2c0",
  "621330dd5bdabcc03582b0e49993702a8d4c41df60f729cc81d94b6e3a5b1556",
  "32d3d83538ba128be3ba7f9dbb8d1ef03e1b536f65e8701893f70dcc1fe2dbf2",
  ...,
  "32d55180d010ffebabf1c3231e1666e9eeed02c905195f2568c987c2751623c7"
]</pre></div>

<p>It will only take a few seconds to mine all these blocks, which
certainly makes it easy for testing. If you check your wallet balance,
you will see that you earned the rewards for the first 400 blocks (coinbase
rewards must be 100 blocks deep before you can <a data-type="indexterm" data-primary="blockchain" data-secondary="test blockchains" data-tertiary="regtest" data-startref="blockchain-test-regtest" id="id1216" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="test blockchains" data-secondary="regtest" data-startref="test-block-regtest" id="id1217" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="regtest" data-startref="regtest" id="id1218" target="_blank" rel="noopener noreferrer"></a>spend them):</p>

<div data-testid="custom pre block"><pre data-type="programlisting">$ bitcoin-cli -regtest getbalance
12462.50000000</pre></div>
</div>
</div>






<div id="id271" data-type="sect1" data-pdf-bookmark="Using Test Blockchains for Development">
<h2>Using Test Blockchains for Development</h2>

<p>Bitcoin’s <a data-type="indexterm" data-primary="blockchain" data-secondary="test blockchains" data-tertiary="development usage" id="id1219" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="test blockchains" data-secondary="development usage" id="id1220" target="_blank" rel="noopener noreferrer"></a>various
blockchains (regtest, signet, testnet3, mainnet) offer a range
of testing environments for bitcoin development. Use the test
blockchains whether you are developing for Bitcoin Core or another
full-node consensus client; developing an application such as a wallet, exchange,
ecommerce site; or even developing novel smart contracts and complex
scripts).</p>

<p>You can use the test blockchains to establish a development pipeline.
Test your code locally on a regtest as you develop it. Once you are
ready to try it on a public network, switch to signet or testnet to expose your
code to a more dynamic environment with more diversity of code and
applications. Finally, once you are confident your code works as
expected, switch to mainnet to deploy it in production. As you make
changes, improvements, bug fixes, etc., start the pipeline again,
deploying each change first on regtest, then on signet or testnet, and finally
into production.</p>

<p>Now that we know what data the blockchain contains and how cryptographic
commitments securely tie the various parts together, we will look at the
special commitment that both provide computational security and
ensure no block can be changed without invalidating all other blocks
built on top of it: Bitcoin’s mining function.</p>
</div>
</div></div>
  <span></span> <!-- for IntersectionObserver -->
  
  
  
  


<style id="note-styling">
    .note {
      position: absolute;
      z-index: 10;
      border: none;
      outline: none;
      font-family: inherit;
      font-size: inherit;
      padding: 5px;
      min-width: 32px;
      min-height: 32px;
    }
    .note:focus {
      z-index: 11;
    }
    .note[type="0"] {
      background-color: #fff740;
      color: #2c2c2d;
    }
    .note[type="0"]::placeholder {
      color: #868226;
    }
    .note[type="1"] {
      background-color: #feff9c;
      color: #2c2c2d;
    }
    .note[type="1"]::placeholder {
      color: #6d6d3d;
    }
    .note[type="2"] {
      background-color: #ff65a3;
      color: #2c2c2d;
    }
    .note[type="2"]::placeholder {
      color: #65263f;
    }
    .note[type="3"] {
      background-color: #ff7eb9;
      color: #2c2c2d;
    }
    .note[type="3"]::placeholder {
      color: #562b3f;
    }
    .note[type="4"] {
      background-color: #7afcff;
      color: #295c5d;
    }
    .note[type="4"]::placeholder {
      color: #377677;
    }</style><div id="chapters-container">
      <style>
        #chapters {
          display: grid;
          grid-template-columns: 1fr 1fr;
          margin: 2ch 0;
        }
        #chapters a {
          cursor: pointer;
        }
        #chapters a[href=""] {
          opacity: 0.5;
          pointer-events: none;
          color: inherit;
        }
        #chapters a:first-child {
          justify-self: start;
        }
        #chapters a:last-child {
          justify-self: end;
        }
      </style>
      <hr>
      <div id="chapters">
        <a href="" title="move to the previous chapter (Ctrl/Command + PageUp)">Previous Chapter</a>
        <a href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch12.html" title="move to the next chapter (Ctrl/Command + PageDown)">Next Chapter</a>
      </div>
    </div></body><style>body {
      font-size:  19px;
      font-family: Georgia, 'Times New Roman', serif;
      width: 600px;
    }
    p {
      text-align: justify
    }
    .page {
      line-height: 28.5px;
      column-count: unset;
    }
    h1, h2, h3 {
      line-height: initial;
    }</style></html>