<!DOCTYPE html>
<html><head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <base target="_blank">
  <style>
/* latin */
@font-face {
  font-family: 'Comic Neue';
  font-style: normal;
  font-weight: 400;
  src: url(fonts/4UaHrEJDsxBrF37olUeD96rp57F2IwM.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
/* latin */
@font-face {
  font-family: 'Lexend Deca';
  font-style: normal;
  font-weight: 400;
  src: url(fonts/K2FifZFYk-dHSE0UPPuwQ7CrD94i-NCKm-U48M1wqxnDirZPl3v-.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
/* latin */
@font-face {
  font-family: 'Poppins';
  font-style: normal;
  font-weight: 400;
  src: url(fonts/pxiEyp8kv8JHgFVrJJfecnFHGPc.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

:root {
  --fg: #000; /* foreground  */
  --bg: #fff; /* background  */
  --bd: #000; /* border  */
  --lk: #006fa5; /* link */
  --lkv: #d33bf0; /* link visited */
  --hg: #ffff81; /* highlight  */
}
html {
  overflow: overlay;
}
body {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  margin: 30px auto 0 auto;
  padding: 10px;
  position: relative;

  color: var(--fg);
  border-color: var(--bd);
  background-color: var(--bg);
}
body[data-mode$="dark"] {
  --lk: #0096de;
}
body[data-mode="light"] {
  color-scheme: light;
  --fg: #222;
  --bd: #222;
  --bg: whitesmoke;
}
body[data-mode="dark"] {
  color-scheme: dark;
  --fg: #eee;
  --bd: #eee;
  --bg: #333;
}
body[data-mode="sepia"] {
  color-scheme: light;
  --fg: #5b4636;
  --bd: #5b4636;
  --bg: #f4ecd8;
}
body[data-mode="solarized-light"] {
  color-scheme: light;
  --fg: #586e75;
  --bd: #586e75;
  --bg: #fdf6e3;
}
body[data-mode="nord-light"] {
  color-scheme: light;
  --fg: #2e3440;
  --bd: #2e3440;
  --bg: #e5e9f0;
}
body[data-mode="groove-dark"] {
  color-scheme: dark;
  --fg: #cec4ac;
  --bd: #cec4ac;
  --bg: #282828;
}
body[data-mode="solarized-dark"] {
  color-scheme: dark;
  --fg: #839496;
  --bd: #839496;
  --bg: #002b36;
}
body[data-mode="nord-dark"] {
  color-scheme: dark;
  --fg: #e5e9f0;
  --bd: #e5e9f0;
  --bg: #2e3440;
}

@media print {
  body[data-mode] {
    --fg: #000;
    --bd: #000;
    --bg: #fff;

    width: unset;
    padding: 0;
    margin: 0;
  }
}
body[data-loaded=true] {
  
}
img {
  max-width: 100%;
  height: auto;
}
img:not([width])[src$=".svg"] {
  max-width: 100px;
}
body[data-images=false] canvas,
body[data-images=false] svg,
body[data-images=false] img {
  display: none;
}
svg:not([width]):not([height]) {
  max-width: 25vmin;
}
a {
  color: var(--lk);
  text-decoration: none;
}
a:visited {
  color: var(--lkv);
}

hr {
  background-color: var(--bd);
  height: 1px;
  border: 0;
}
#reader-domain {
  font-family: Helvetica, Arial, sans-serif;
  text-decoration: none;
  border-bottom-color: currentcolor;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  width: 100%;
  display: inline-block;
  direction: ltr;
}
#reader-domain > span:first-child {
  font-size: 1.1em;
}
#reader-domain > span:last-child {
  font-size: 0.8em;
}
#reader-title {
  font-size: 1.6em;
  line-height: 1.25em;
  width: 100%;
  margin: 20px 0;
  padding: 0;
}
#reader-credits,
#doi,
#published-time,
#reader-estimated-time {
  font-size: 0.85em;
  line-height: 1.48em;
  margin: 0 0 10px 0;
  padding: 0;
}
#reader-credits:not(:empty)::after {
  content: ' ⋮ ';
}
#published-time:not(:empty)::before {
  content: ' ⋮ ';
}
#doi-json {
  overflow: hidden;
}
#doi-json code {
  overflow: auto;
  max-height: 400px;
}
#published-time:empty,
#reader-credits:empty {
  display: none;
}
mark.hghlght {
  background-color: var(--hg);
}
body:not([data-columns="1"]) .page :is(h1, h2) {
  column-span: all;
  background-color: rgba(125, 125, 125, 0.1);
  padding: 10px;
}
.hidden {
  display: none;
}
</style>
  <style id="user-css">body {
  padding-bottom: 64px;
}
pre {
  white-space: pre-wrap;
}
pre code {
  background-color: #eff0f1;
  color: #393318;
  font-family: monospace;
  display: block;
  padding: 5px 10px;
}
body[data-mode="dark"] pre code {
  background-color: #585858;
  color: #e8e8e8;
}

/* CSS for sans-serif fonts */
body[data-font=sans-serif] {}
/* CSS for serif fonts */
body[data-font=serif] {}

/* CSS for "sepia" theme */
body[data-mode=sepia] {}
/* CSS for "light" theme */
body[data-mode=light] {}
/* CSS for "dark" theme */
body[data-mode=dark] {}</style>
<title>9. Transaction Fees</title><title>9. Transaction Fees :: Reader View</title></head>
<body tabindex="1" data-images="true" data-mode="groove-dark" data-font="serif" data-columns="1" data-loaded="true">
  <span></span> <!-- for IntersectionObserver -->
  <a id="reader-domain" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch09.html">
    <span>learning.oreilly.com</span>
    <span>/library/view/mastering-bitcoin-3rd/9781098150082/ch09.html</span>
  </a>
  <h1 dir="auto" id="reader-title">9. Transaction Fees</h1>
  <span dir="auto" id="reader-credits"></span>
  <span dir="auto" id="reader-estimated-time">28-36 minutes</span>
  <span dir="auto" id="published-time"></span>
  <hr>
  <div id="readability-page-1" class="page"><div id="sbo-rt-content" data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 9. Transaction Fees">
<h2><span>Chapter 9. </span>Transaction Fees</h2>

<p>
The digital signature we saw Alice create in <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch08.html#c_signatures" target="_blank" rel="noopener noreferrer">Chapter&nbsp;8</a> only
proves that she knows her private key and that she committed to a
transaction that pays Bob.  She can create another signature that
instead commits to a transaction paying Carol—a transaction that spends
the same output (bitcoins) that she used to pay Bob.  Those two
transactions are now <em>conflicting transactions</em> because only one
transaction spending a particular output can be included in the valid
blockchain with the most proof of work—the blockchain that full nodes
use to determine which keys control which bitcoins.
</p>

<p>To<a data-type="indexterm" data-primary="conflicting transactions" id="id1052" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="transactions" data-secondary="conflicts in" id="id1053" target="_blank" rel="noopener noreferrer"></a> protect himself against conflicting transactions, it would be wise
for Bob to wait until the transaction from Alice is included in the
blockchain to a sufficient depth before he considers the money he
received as his to spend (see <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch01.html#confirmations" target="_blank" rel="noopener noreferrer">“Confirmations”</a>).
For Alice’s transaction to be included in the
blockchain, it must be included in a <em>block</em> of transactions.  There are
a limited number of<a data-type="indexterm" data-primary="blocks" data-secondary="transactions in" id="id1054" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="transactions" data-secondary="in blocks" data-secondary-sortas="blocks" id="id1055" target="_blank" rel="noopener noreferrer"></a> blocks produced in a given amount of time, and each
block only has a limited amount of space.  Only the miner who creates
that block gets to choose which transactions to include.  Miners may
select transactions by any criteria they want, including refusing to
include any transactions at all.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p> When we say “transactions” in this chapter, we refer to every
transaction in a block except for the first transaction.  The first
transaction in a block is a <em>coinbase transaction</em>, described in
<a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch06.html#coinbase_transactions" target="_blank" rel="noopener noreferrer">“Coinbase Transactions”</a>, which allows the miner of the block to
collect their reward for producing the block.  Unlike other
transactions, a coinbase transaction doesn’t spend the output of a
previous transaction and is also an exception to several other rules
that apply to other transactions.  Coinbase transactions don’t pay
transaction fees, don’t need to be fee bumped, aren’t subject to
transaction pinning, and are largely uninteresting to the following
discussion about fees—so we’re going to ignore them in this chapter.
</p>
</div>

<p>The criterion that almost all miners use to select which transactions to
include in their blocks is to maximize their revenue.  Bitcoin was
specifically designed to accommodate this by providing a mechanism that
allows a transaction to give money to the miner who includes that
transaction in a block.  We call that mechanism <em>transaction fees</em>,
although it’s not a fee in the usual sense of that word.  It’s not an
amount set by the protocol or by any particular miner—​it’s much more
like a bid in an auction.  The good being purchased is the portion of
limited space in a block that a transaction will consume.  Miners choose
the set of transactions whose bids will allow them to earn the greatest
revenue.</p>

<p>In this chapter, we’ll explore various aspects of those
bids—​transaction fees—​and how they influence the creation and
management of Bitcoin transactions.</p>






<div id="id261" data-type="sect1" data-pdf-bookmark="Who Pays the Transaction Fee?">
<h2>Who Pays the Transaction Fee?</h2>

<p>Most <a data-type="indexterm" data-primary="transaction fees" data-secondary="responsibility for" id="fees-responsibility" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="payments" data-secondary="transaction fees" data-see="transaction fees" id="id1056" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="fees" data-see="transaction fees" id="id1057" target="_blank" rel="noopener noreferrer"></a>payment systems involve some sort of fee for transacting, but
often this fee is hidden from typical buyers.  For example, a merchant
may advertise the same item for the same price whether you pay with cash
or a credit card even though their payment processor may charge them
a higher fee for credit transactions than their bank charges them for
cash deposits.</p>

<p>In Bitcoin, every spend of bitcoins must be authenticated (typically
with a signature), so it’s not possible for a transaction to pay a fee
without the permission of the spender.  It is possible for the receiver
of a transaction to pay a fee in a different transaction—​and we’ll see
that in use later—​but if we want a single transaction to pay its own
fee, that fee needs to be something agreed upon by the spender.  It
can’t be hidden.</p>

<p>Bitcoin transactions are designed so that it doesn’t take any extra
space in a transaction for a spender to commit to the fee it pays.  That
means that, even though it’s possible to pay the fee in a different
transaction, it’s most efficient (and thus cheapest) to pay the fee in a
single transaction.</p>

<p>In Bitcoin,
the fee is a bid and the amount paid contributes to determining how long
it will take the transaction to confirm.  Both spenders and receivers of
a payment typically have an interest in having it confirming quickly, so
normally allowing only spenders to choose fees can sometimes be a
problem; we’ll look at a solution to that problem in <a data-type="xref" href="#cpfp" target="_blank" rel="noopener noreferrer">“Child Pays for Parent (CPFP) Fee Bumping”</a>.  However,
in many common payment flows, the parties with the highest desire to see a
transaction confirm quickly—​that is, the parties who would be the most
willing to pay higher fees—​are the spenders.</p>

<p>For those reasons, both technical and practical, it is customary in
Bitcoin for spenders to pay transaction fees.  There are exceptions,
such as for merchants that accept unconfirmed transactions and in
protocols that don’t immediately broadcast 
<span>transactions</span> after they are
signed (preventing the spender from being able to choose an appropriate
fee for the current market).  We’ll explore those exceptions<a data-type="indexterm" data-primary="transaction fees" data-secondary="responsibility for" data-startref="fees-responsibility" id="id1058" target="_blank" rel="noopener noreferrer"></a> later.</p>
</div>






<div id="id146" data-type="sect1" data-pdf-bookmark="Fees and Fee Rates">
<h2>Fees and Fee Rates</h2>

<p>Each <a data-type="indexterm" data-primary="transaction fees" data-secondary="fee rates" id="fees-rates" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="fee rates" id="fee-rate" target="_blank" rel="noopener noreferrer"></a>transaction only pays a single fee—​it doesn’t matter how large the
transaction is.  However, the larger transactions become, the fewer of
them a miner will be able to fit in a block.  For that reason, miners
evaluate transactions the same way you might comparison shop between
several equivalent items at the market: they divide the price by the
quantity.</p>

<p>Whereas you might divide the cost of several different bags of rice by
each bag’s weight to find the lowest price per weight (best deal), miners
divide the fee of a transaction by its size (also called its weight) to
find the highest fee per weight (most revenue).  In Bitcoin, we use the
term <em>fee rate</em> for a transaction’s size divided by weight.  Due to
changes in Bitcoin over the years, fee rate can be expressed in
different units:</p>

<ul>
<li>
<p>BTC/Bytes (a legacy unit rarely used anymore)</p>
</li>
<li>
<p>BTC/Kilobytes (a legacy unit rarely used anymore)</p>
</li>
<li>
<p>BTC/Vbytes (rarely used)</p>
</li>
<li>
<p>BTC/Kilo-vbyte (used mainly in Bitcoin Core)</p>
</li>
<li>
<p>Satoshi/Vbyte (most commonly used today)</p>
</li>
<li>
<p>Satoshi/Weight (also commonly used today)</p>
</li>
</ul>

<p>We recommend either the sat/vbyte or sat/weight units for displaying
fee rates.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Be careful <a data-type="indexterm" data-primary="absurd fees" id="id1059" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="excessive fees" id="id1060" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="transaction fees" data-secondary="overpaying" id="id1061" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="overpaying transaction fees" id="id1062" target="_blank" rel="noopener noreferrer"></a>accepting input for fee rates.  If a user copies and pastes a
fee rate printed in one denominator into a field using a different
denominator, they could overpay fees by 1,000 times.  If they instead
switch the numerator, they could theoretically overpay by 100,000,000
times.  Wallets should make it hard for the user to pay an excessive
fee rate and may want to prompt the user to confirm any fee rate that was
not generated by the wallet itself using a trusted data source.</p>

<p>An excessive fee, also called an <em>absurd fee</em>, is any fee rate that’s
significantly higher than the amount that fee rate estimators currently
expect is necessary to get a transaction confirmed in the next block.
Note that wallets should not entirely prevent users from choosing an
excessive fee rate—​they should only make using such a fee rate hard to do
by accident.  There are legitimate reasons for users to overpay fees on
rare occasions.</p>
</div>
</div>






<div id="id147" data-type="sect1" data-pdf-bookmark="Estimating Appropriate Fee Rates">
<h2>Estimating Appropriate Fee Rates</h2>

<p>We’ve <a data-type="indexterm" data-primary="estimating fee rates" id="estimate-fee-rate" target="_blank" rel="noopener noreferrer"></a>established that you can pay a lower fee rate if you’re willing to
wait longer for your transaction to be confirmed, with the exception
that paying too low of a fee rate could result in your transaction never
confirming.  Because fee rates are bids in an open auction for block
space, it’s not possible to perfectly predict what fee rate you need to
pay to get your transaction confirmed by a certain time.  However, we
can generate a rough estimate based on what fee rates other transactions
have paid in the recent past.</p>

<p>A full node can record three pieces of information about each
transactions it sees: the time (block height) when it first received
that transaction, the block height when that transaction was confirmed,
and the fee rate paid by that transaction.  By grouping together
transactions that arrived at similar heights, were confirmed at similar
heights, and which paid similar fees, we can calculate how many blocks it
took to confirm transactions paying a certain fee rate.  We can then
assume that a transaction paying a similar fee rate now will take a
similar number of blocks to confirm.  Bitcoin Core includes a fee rate
estimator that uses these principles, which can be called using the
<code>estimatesmartfee</code> RPC with a parameter specifying how many blocks
you’re willing to wait before the transaction is highly likely to
confirm (for example, 144 blocks is about 1 day):</p>

<div data-testid="custom pre block"><pre data-type="programlisting">$ bitcoin-cli -named estimatesmartfee conf_target=144
{
  "feerate": 0.00006570,
  "blocks": 144
}</pre></div>

<p>Many web-based services also provide fee estimation as an API.  For a
current list, see <a href="https://oreil.ly/TB6IN" target="_blank" rel="noopener noreferrer"><em>https://oreil.ly/TB6IN</em></a>.</p>

<p>As mentioned, fee rate estimation can never be perfect.  One common
problem is that the fundamental demand might change, adjusting the
equilibrium and either increasing prices (fees) to new heights or
decreasing them toward the minimum.
If fee rates go down, then a transaction
that previously paid a normal fee rate might now be paying a high fee
rate and it will be confirmed earlier than expected.  There’s no way to
lower the fee rate on a transaction you’ve already sent, so you’re stuck
paying a higher fee rate.  But, when fee rates go up, there’s a need for
methods to be able to increase the fee rates on those transactions,
which is called <em>fee bumping</em>.  There are two commonly used types of fee
bumping in Bitcoin, replace by fee (RBF) and child pays for <a data-type="indexterm" data-primary="fee rates" data-startref="fee-rate" id="id1063" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="transaction fees" data-secondary="fee rates" data-startref="fees-rates" id="id1064" target="_blank" rel="noopener noreferrer"></a>parent
(CPFP).</p>
</div>






<div id="rbf" data-type="sect1" data-pdf-bookmark="Replace By Fee (RBF) Fee Bumping">
<h2>Replace By Fee (RBF) Fee Bumping</h2>

<p>To<a data-type="indexterm" data-primary="transaction fees" data-secondary="fee bumping" data-tertiary="RBF (replace by fee)" id="transaction-fees-bump-rbf" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="fee bumping" data-secondary="RBF (replace by fee)" id="fee-bump-rbf" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="RBF (replace by fee) fee bumping" id="rbf-ch9" target="_blank" rel="noopener noreferrer"></a> increase the fee of a transaction using RBF fee bumping, you create
a conflicting version of the transaction that pays a higher fee.  Two
or more transactions are considered<a data-type="indexterm" data-primary="conflicting transactions" id="id1065" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="transactions" data-secondary="conflicts in" id="id1066" target="_blank" rel="noopener noreferrer"></a> to be <em>conflicting transactions</em> if
only one of them can be included in a valid blockchain, forcing a miner
to choose only one of them.  Conflicts occur when two or more transactions
each try to spend one of the same UTXOs, i.e., they each include an input
that has the same outpoint (reference to the output of a previous
transaction).</p>

<p>To prevent someone from consuming large amounts of bandwidth by creating
an unlimited number of conflicting transactions and sending them through
the network of relaying full nodes, Bitcoin Core and other full nodes
that support transaction replacement require each replacement
transaction to pay a higher fee rate than the transaction being
replaced.  Bitcoin Core also currently requires the replacement
transaction to pay a higher total fee than the original transaction, but
this requirement has undesired side effects and developers have been
looking for ways to remove it at the time of writing.</p>

<p>Bitcoin Core<a data-type="indexterm" data-primary="Bitcoin Core" data-secondary="RBF variants" id="bitcoin-core-rbf" target="_blank" rel="noopener noreferrer"></a> currently supports two variations of RBF:</p>
<dl>
<dt>Opt-in RBF</dt>
<dd>
<p>An unconfirmed transaction can signal to miners and full nodes that
the creator of the transaction wants to allow it to be replaced by a
higher fee rate version.  This signal and the rules for using it
are specified in BIP125.  As of this writing, this has been enabled by
default in Bitcoin Core for several years.</p>
</dd>
<dt>Full RBF</dt>
<dd>
<p>Any unconfirmed transaction can be replaced by a higher fee rate
version.  As of this writing, this can be optionally enabled in
Bitcoin Core (but it is disabled by default).</p>
</dd>
</dl>


<p>As a user, if you plan to use RBF fee bumping, you will first need to
choose a wallet that supports it, such as one of the wallets listed as
having “Sending support” on
<a href="https://oreil.ly/IhMzx" target="_blank" rel="noopener noreferrer"><em>https://oreil.ly/IhMzx</em></a>.</p>

<p>As a developer, if you plan to implement RBF fee bumping, you will first
need to decide whether to perform opt-in RBF or full RBF.  At the time
of writing, opt-in RBF is the only method that’s sure to work.  Even if
full RBF becomes reliable, there will likely be several years where
replacements of opt-in transactions get confirmed slightly faster than
full-RBF replacements.  If you choose opt-in RBF, your wallet will need
to implement the signaling specified in BIP125, which is a simple
modification to any one of the sequence fields in a transaction (see
<a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch06.html#sequence" target="_blank" rel="noopener noreferrer">“Sequence”</a>).  If you choose full RBF, you don’t need to include any
signaling in your transactions.  Everything else related to RBF is the
same for both approaches.</p>

<p>When you need to fee bump a transaction, you will simply create a new
transaction that spends at least one of the same UTXOs as the original
transaction you want to replace.  You will likely want to keep the
same outputs in the transaction that pay the receiver (or receivers).
You may pay the increased fee by reducing the value of your change
output or by adding additional inputs to the transaction.  Developers
should provide users with a fee-bumping interface that does all of this
work for them and simply asks them (or suggests to them) how much the
fee rate should be increased.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Be very careful when creating more than one replacement of the same
transaction.  You must ensure than all versions of the transactions
conflict with each other.  If they aren’t all conflicts, it may be
possible for multiple separate transactions to confirm, leading you to
overpay the receivers.  For example:</p>

<ul>
<li>
<p>Transaction version 0 includes input <em>A</em>.</p>
</li>
<li>
<p>Transaction version 1 includes inputs <em>A</em> and <em>B</em> (e.g., you had to add
input <em>B</em> to pay the extra fees)</p>
</li>
<li>
<p>Transaction version 2 includes inputs <em>B</em> and <em>C</em> (e.g., you had to add input
<em>C</em> to pay the extra fees but <em>C</em> was large enough that you no longer
need input <em>A</em>).</p>
</li>
</ul>

<p>In this scenario, any miner who saved version 0 of the transaction
will be able to confirm both it and version 2 of the transaction.  If
both versions pay the same receivers, they’ll be paid twice (and the
miner will receive transaction fees from two separate transactions).</p>

<p>A simple method to avoid this problem is to ensure the replacement
transaction always includes all of the same inputs as the previous
version of the transaction.</p>
</div>

<p>The advantage of RBF fee bumping over other types of fee bumping is that
it can be very efficient at using block space.  Often, a replacement
transaction is the same size as the transaction it replaces.  Even when
it’s larger, it’s often the same size as the transaction the user would
have created if they had paid the increased fee rate in the first place.</p>

<p>The fundamental disadvantage of RBF fee bumping is that it can normally
only be performed by the creator of the transaction—​the person or
people who were required to provide signatures or other authentication
data for the transaction.  An exception to this is transactions that
were designed to allow additional inputs to be added by using sighash
flags (see <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch08.html#sighash_types" target="_blank" rel="noopener noreferrer">“Signature Hash Types (SIGHASH)”</a>), but that presents its own challenges.  In
general, if you’re the receiver of an unconfirmed transaction and you
want to make it confirm faster (or at all), you can’t use an RBF fee
bump; you need some other method.</p>

<p>There are additional problems <a data-type="indexterm" data-primary="transaction fees" data-secondary="fee bumping" data-tertiary="RBF (replace by fee)" data-startref="transaction-fees-bump-rbf" id="id1069" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="fee bumping" data-secondary="RBF (replace by fee)" data-startref="fee-bump-rbf" id="id1070" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="RBF (replace by fee) fee bumping" data-startref="rbf-ch9" id="id1071" target="_blank" rel="noopener noreferrer"></a>with RBF that we’ll explore in <a data-type="xref" href="#transaction_pinning" target="_blank" rel="noopener noreferrer">“Transaction Pinning”</a>.</p>
</div>






<div id="cpfp" data-type="sect1" data-pdf-bookmark="Child Pays for Parent (CPFP) Fee Bumping">
<h2>Child Pays for Parent (CPFP) Fee Bumping</h2>

<p>Anyone <a data-type="indexterm" data-primary="transaction fees" data-secondary="fee bumping" data-tertiary="CPFP (child pays for parent)" id="transaction-fees-bump-cpfp" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="fee bumping" data-secondary="CPFP (child pays for parent)" id="fee-bump-cpfp" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="CPFP (child pays for parent) fee bumping" id="cpfp-ch9" target="_blank" rel="noopener noreferrer"></a>who receives the output of an unconfirmed transaction can
incentivize miners to confirm that transaction by spending that output.
The transaction you want to get confirmed is called the <em>parent
transaction</em>.  A transaction that spends an output of the parent
transaction is called a <em>child transaction</em>.</p>

<p>As we learned in <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch06.html#outpoints" target="_blank" rel="noopener noreferrer">“Outpoint”</a>, every input in a confirmed transaction
must reference the unspent output of a transaction that appears earlier
in the blockchain (whether earlier in the same block or in a previous
block).  That means a miner who wants to confirm a child transaction
must also ensure that its parent transaction is confirmed.  If the
parent transaction hasn’t been confirmed yet but the child transaction
pays a high enough fee, the miner can consider whether it would be
profitable to confirm both of them in the same block.</p>

<p>To evaluate the profitability of mining both a parent and child
transaction, the miner looks at them as a <em>package of transactions</em> with
an aggregate size and aggregate fees, from which the fees can be divided
by the size to calculate<a data-type="indexterm" data-primary="package fee rate" id="id1072" target="_blank" rel="noopener noreferrer"></a> a <em>package fee rate</em>.  The miner can then sort
all of the individual transactions and transaction packages they know
about by fee rate and include the highest-revenue ones in the block
they’re attempting to mine, up to the maximum size (weight) allowed to
be included in a block.  To find even more packages that might be
profitable to mine, the miner can evaluate packages across multiple
generations (e.g., an unconfirmed parent transaction being combined with
both its child and grandchild).  This is <a data-type="indexterm" data-primary="ancestor fee rate mining" id="id1073" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="CPFP (child pays for parent) fee bumping" data-secondary="ancestor fee rate mining" id="id1074" target="_blank" rel="noopener noreferrer"></a>called <em>ancestor fee rate
mining</em>.</p>

<p>Bitcoin Core has implemented ancestor fee rate mining for many years,
and it’s believed that almost all miners use it at the time of writing.
That means it’s practical for wallets to use this feature to fee bump an
incoming transaction by using a child transaction to pay for its parent
(CPFP).</p>

<p>CPFP has several advantages over RBF.  Anyone who receives an output
from a transaction can use CPFP—​that includes both the receivers of
payments and the spender (if the spender included a change output).  It
also doesn’t require replacing the original transaction, which makes it
less disruptive to some merchants than RBF.</p>

<p>The primary disadvantage of CPFP compared to RBF is that CPFP typically
uses more block space.  In RBF, a fee bump transaction is often the same
size as the transaction it replaces.  In CPFP, a fee bump adds a whole
separate transaction.  Using extra block space requires paying extra
fees beyond the cost of the fee bump.</p>

<p>There are several challenges with CPFP, some of which we’ll explore in
<a data-type="xref" href="#transaction_pinning" target="_blank" rel="noopener noreferrer">“Transaction Pinning”</a>.  One other problem that we
specifically need to mention is the minimum relay fee rate problem,
which is addressed by <a data-type="indexterm" data-primary="transaction fees" data-secondary="fee bumping" data-tertiary="CPFP (child pays for parent)" data-startref="transaction-fees-bump-cpfp" id="id1075" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="fee bumping" data-secondary="CPFP (child pays for parent)" data-startref="fee-bump-cpfp" id="id1076" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="CPFP (child pays for parent) fee bumping" data-startref="cpfp-ch9" id="id1077" target="_blank" rel="noopener noreferrer"></a>package relay.</p>
</div>






<div id="id150" data-type="sect1" data-pdf-bookmark="Package Relay">
<h2>Package Relay</h2>

<p>Early versions<a data-type="indexterm" data-primary="transaction fees" data-secondary="package relay" id="transaction-fee-package-relay" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="package relay" id="package-relay" target="_blank" rel="noopener noreferrer"></a> of Bitcoin Core didn’t place any limits on the number of
unconfirmed transactions they stored for later relay and mining in their
mempools (see <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch10.html#mempool" target="_blank" rel="noopener noreferrer">“Mempools and Orphan Pools”</a>).  Of course, computers have physical limits, whether
it’s the memory (RAM) or disk space—​it’s not possible for a full node
to store an unlimited number of unconfirmed transactions.  Later
versions of Bitcoin Core limited the size of the mempool to hold about
one day’s worth of transactions, storing only the transactions or packages
with the highest fee rate.</p>

<p>That works extremely well for most things, but it creates a dependency
problem.  In order to calculate the fee rate for a transaction package,
we need both the parent and descendant transactions—​but if the parent
transaction doesn’t pay a high enough fee rate, it won’t be kept in a
node’s mempool.  If a node receives a child transaction without having
access to its parent, it can’t do anything with that transaction.</p>

<p>The solution to this problem is the ability to relay transactions as a
package, called <em>package relay</em>, allowing the receiving node to evaluate
the fee rate of the entire package before operating on any individual
transaction.  As of this writing, developers working on Bitcoin Core
have made significant progress on implementing package relay, and a
limited early version of it may be available by the time this book is
published.</p>

<p>Package relay is especially important for protocols based on
time-sensitive presigned transactions, such as Lightning Network (LN).  In
non-cooperative cases, some presigned transactions can’t be fee bumped
using RBF, forcing them to depend on CPFP.  In those protocols, some
transactions may also be created long before they need to be broadcast,
making it effectively impossible to estimate an appropriate fee rate.
If a presigned transaction pays a fee rate below the amount necessary to
get into a node’s mempool, there’s no way to fee bump it with a child.
If that prevents the transaction from confirming in time, an honest user
might lose money.  Package relay is the solution for this critical
problem.</p>
</div>






<div id="transaction_pinning" data-type="sect1" data-pdf-bookmark="Transaction Pinning">
<h2>Transaction Pinning</h2>
<p>
Although both RBF and CPFP fee bumping work in the basic cases we
described, there are rules related to both
methods that are designed to prevent denial-of-service attacks on miners
and relaying full nodes.  An unfortunate side effect of those rules
is that they can sometimes prevent someone from being able to use fee
bumping.  Making it impossible or difficult to fee bump a transaction is
called <em>transaction pinning</em>.</p>

<p>One<a data-type="indexterm" data-primary="transaction fees" data-secondary="fee bumping" data-tertiary="transaction pinning" id="transaction-fee-bump-pin" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="fee bumping" data-secondary="transaction pinning" id="fee-bump-pin" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="transaction pinning" id="transaction-pin" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="RBF (replace by fee) fee bumping" data-secondary="transaction pinning" id="rbf-pin" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="CPFP (child pays for parent) fee bumping" data-secondary="transaction pinning" id="cpfp-pin" target="_blank" rel="noopener noreferrer"></a> of the major denial of service concerns revolves around the effect of
transaction relationships.  Whenever the output of a transaction is
spent, that transaction’s identifier (txid) is referenced by the child
transaction.  However, when a transaction is replaced, the replacement
has a different txid.  If that replacement transaction gets confirmed,
none of its descendants can be included in the same blockchain.  It’s
possible to re-create and re-sign the descendant transactions, but that’s
not guaranteed to happen.  This has related but divergent implications
for RBF and CPFP:</p>

<ul>
<li>
<p>In the context of RBF, when Bitcoin Core accepts a replacement
transaction, it keeps things simple by forgetting about the original
transaction and all descendant transactions that depended on that
original.  To ensure that it’s more profitable for miners to accept
replacements, Bitcoin Core only accepts a replacement transaction if it
pays more fees than all the transactions that will be forgotten.</p>

<p>The downside of this approach is that Alice can create a small
transaction that pays Bob.  Bob can then use his output to create a
large child transaction.  If Alice then wants to replace her original
transaction, she needs to pay a fee that’s larger than what both she and
Bob originally paid.  For example, if Alice’s original transaction was
about 100 vbytes and Bob’s transaction was about 100,000 vbytes, and
they both used the same fee rate, Alice now needs to pay more than 1,000
times as much as she originally paid in order to RBF fee bump her
transaction.</p>
</li>
<li>
<p>In the context of CPFP, any time the node considers including a
package in a block, it must remove the transactions in that package
from any other package it wants to consider for the same block.  For
example, if a child transaction pays for 25 ancestors, and each of
those ancestors has 25 other children, then including the package in
the block requires updating approximately 625 packages (25<sup>2</sup>).
Similarly, if a transaction with 25 descendants is removed from a
node’s mempool (such as for being included in a block), and each of
those descendants has 25 other ancestors, another 625 packages need to
be updated.  Each time we double our parameter (e.g., from 25 to 50),
we quadruple the amount of work our node needs to perform.</p>

<p>Additionally, a transaction and all of its descendants is not
  useful to keep in a mempool long term if an alternative version of
  that transaction is mined—​none of those transactions can now be
  confirmed unless there’s a rare blockchain reorganization.  Bitcoin
  Core will remove from its mempool every transaction that can no longer
  be confirmed on the current blockchain.  At it’s worst, that can
  waste an enormous amount of your node’s bandwidth and possibly be used
  to prevent transactions from propagating correctly.</p>

<p>To prevent these problems, and other related
  problems, Bitcoin Core limits a parent transaction to having a maximum
  of 25 ancestors or descendants in its mempool and limits the
  total size of all those transactions to 100,000 vbytes.  The downside
  of this approach is that users are prevented from creating CPFP fee
  bumps if a transaction already has too many descendants (or if it and
  its descendants are too large).</p>
</li>
</ul>

<p>Transaction pinning can happen by accident, but it also represents a
serious vulnerability for multiparty time-sensitive protocols such as
LN.  If your counterparty can prevent one of your
transactions from confirming by a deadline, they may be able to steal
money from you.</p>

<p>Protocol developers have been working on mitigating problems with
transaction pinning for several years.  One partial solution is
described in <a data-type="xref" href="#cpfp_carve_out" target="_blank" rel="noopener noreferrer">“CPFP Carve Out and Anchor Outputs”</a>.  Several other solutions have been
proposed, and at least one solution is being actively <a data-type="indexterm" data-primary="transaction fees" data-secondary="fee bumping" data-tertiary="transaction pinning" data-startref="transaction-fee-bump-pin" id="id1078" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="fee bumping" data-secondary="transaction pinning" data-startref="fee-bump-pin" id="id1079" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="transaction pinning" data-startref="transaction-pin" id="id1080" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="RBF (replace by fee) fee bumping" data-secondary="transaction pinning" data-startref="rbf-pin" id="id1081" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="CPFP (child pays for parent) fee bumping" data-secondary="transaction pinning" data-startref="cpfp-pin" id="id1082" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="transaction fees" data-secondary="fee bumping" data-tertiary="CPFP carve outs" id="transaction-fee-bump-carveout" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="fee bumping" data-secondary="CPFP carve outs" id="fee-bump-carveout" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="carve outs (CPFP)" id="carveout" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="CPFP (child pays for parent) fee bumping" data-secondary="carve outs" id="cpfp-carveout" target="_blank" rel="noopener noreferrer"></a>developed as of
this writing—<a href="https://oreil.ly/300dv" target="_blank" rel="noopener noreferrer">ephemeral anchors</a>.</p>
</div>






<div id="cpfp_carve_out" data-type="sect1" data-pdf-bookmark="CPFP Carve Out and Anchor Outputs">
<h2>CPFP Carve Out and Anchor Outputs</h2>
<p>
In 2018, developers working on LN had a problem.
Their protocol uses transactions that require signatures from two
different parties.  Neither party wants to trust the other, so they sign
transactions at a point in the protocol when trust isn’t needed,
allowing either of them to broadcast one of those transactions at a
later time when the other party may not want to (or be able to) fulfill
its obligations.  The problem with this approach is that the
transactions might need to be broadcast at an unknown time, far in the future, beyond any
reasonable ability to estimate an appropriate fee rate for the
transactions.</p>

<p>In theory, the developers could have designed their transactions to
allow fee bumping with either RBF (using special sighash flags) or CPFP,
but both of those protocols are vulnerable to transaction pinning.
Given that the involved transactions are time sensitive, allowing a
counterparty to use transaction pinning to delay confirmation of a
transaction can easily lead to a repeatable exploit that malicious
parties could use to steal money from honest parties.</p>

<p>LN developer Matt Corallo proposed a solution: give the rules for CPFP
fee bumping a special exception, called <em>CPFP carve out</em>.  The normal
rules for CPFP forbid the inclusion of an additional descendant if it
would cause a parent transaction to have 26 or more descendants or if it
would cause a parent and all of its descendants to exceed 100,000 vbytes
in size.  Under the rules of CPFP carve out, a single additional
transaction up to 1,000 vbytes in size can be added to a package even if
it would exceed the other limits as long as it is a direct child of an
unconfirmed transaction with no unconfirmed ancestors.</p>
<p>
For example, Bob and Mallory both co-sign a transaction with two
outputs, one to each of them.  Mallory broadcasts that transaction and
uses her output to attach either 25 child transactions or any smaller
number of child transactions equaling 100,000 vbytes in size.  Without
carve-out, Bob would be unable to attach another child transaction to
his output for CPFP fee bumping.  With carve-out, he can spend one of
the two outputs in the transaction, the one that belongs to him, as long
as his child transaction is less than 1,000 vbytes in size (which should
be more than enough space).</p>

<p>It’s not allowed to use CPFP carve-out more than once, so it only works
for two-party protocols.  There have been proposals to extend it to
protocols involving more participants, but there hasn’t been much demand
for that and developers are focused on building more generic solutions
to transaction pinning attacks.</p>

<p>As of this writing, most popular LN implementations use a transaction
template called <em>anchor outputs</em>, which is designed to be used <a data-type="indexterm" data-primary="anchor outputs (CPFP)" id="id1083" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="transaction fees" data-secondary="fee bumping" data-tertiary="CPFP carve outs" data-startref="transaction-fee-bump-carveout" id="id1084" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="fee bumping" data-secondary="CPFP carve outs" data-startref="fee-bump-carveout" id="id1085" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="carve outs (CPFP)" data-startref="carveout" id="id1086" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="CPFP (child pays for parent) fee bumping" data-secondary="carve outs" data-startref="cpfp-carveout" id="id1087" target="_blank" rel="noopener noreferrer"></a>with CPFP
carve out.</p>
</div>






<div id="id262" data-type="sect1" data-pdf-bookmark="Adding Fees to Transactions">
<h2>Adding Fees to Transactions</h2>

<p>The data<a data-type="indexterm" data-primary="transaction fees" data-secondary="change outputs and" id="id1088" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="change output" data-secondary="transaction fees and" id="id1089" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="outputs" data-secondary="transaction fees and" id="id1090" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="inputs" data-secondary="transaction fees and" id="id1091" target="_blank" rel="noopener noreferrer"></a> structure of transactions does not have a field for fees.
Instead, fees are implied as the difference between the sum of inputs
and the sum of outputs. Any excess amount that remains after all outputs
have been deducted from all inputs is the fee that is collected by the
miners:</p>


<p>This is a somewhat confusing element of transactions and an important
point to understand because if you are constructing your own
transactions, you must ensure you do not inadvertently include a very
large fee by underspending the inputs. That means that you must account
for all inputs, if necessary, by creating change, or you will end up
giving the miners a very big tip!</p>

<p>For example, if you spend a 20-bitcoin UTXO to make a 1-bitcoin
payment, you must include a 19-bitcoin change output back to your
wallet. Otherwise, the 19-bitcoin “leftover” will be counted as a
transaction fee and will be collected by the miner who mines your
transaction in a block. Although you will receive priority processing
and make a miner very happy, this is probably not what you intended.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>If you forget to add a
change output in a manually constructed transaction, you will be paying
the change as a transaction fee. “Keep the change!” might not be what
you intended.</p>
</div>
</div>






<div id="fee_sniping" data-type="sect1" data-pdf-bookmark="Timelock Defense Against Fee Sniping">
<h2>Timelock Defense Against Fee Sniping</h2>

<p>Fee sniping <a data-type="indexterm" data-primary="transaction fees" data-secondary="fee sniping" id="transaction-fee-sniping" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="fee sniping" id="fee-snipe" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="timelocks" data-secondary="fee sniping and" id="timelock-fee-snipe" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="lock time" data-secondary="fee sniping and" id="lock-time-fee-snipe" target="_blank" rel="noopener noreferrer"></a>is a theoretical
attack scenario where miners attempting to rewrite past blocks “snipe”
higher-fee transactions from future blocks to maximize their

<span>profitability.</span></p>

<p>For example, let’s say the highest block in existence is block
#100,000. If instead of attempting to mine block #100,001 to extend the
chain, some miners attempt to remine  #100,000. These miners can choose
to include any valid transaction (that hasn’t been mined yet) in their
candidate block  #100,000. They don’t have to remine the block with the
same transactions. In fact, they have the incentive to select the most
profitable (highest fee per kB) transactions to include in their block.
They can include any transactions that were in the “old” block
#100,000, as well as any transactions from the current mempool.
Essentially they have the option to pull transactions from the “present”
into the rewritten “past” when they re-create block  #100,000.</p>

<p>Today, this attack is not very lucrative because the block subsidy is much
higher than total fees per block. But at some point in the future,
transaction fees will be the majority of the reward (or even the
entirety of the reward). At that time, this scenario becomes inevitable.</p>

<p>Several wallets discourage fee sniping by creating transactions with a
lock time that limits those transactions to being included in the next
block or any later block. In our
scenario, our wallet would set lock time to 100,001 on any
transaction it created. Under normal circumstances, this lock time has
no effect—the transactions could only be included in block
#100,001 anyway; it’s the next block.</p>

<p>But under a reorganization attack, the miners would not be able to pull
high-fee transactions from the mempool because all those transactions
would be timelocked to block #100,001. They can only remine  #100,000
with whatever transactions were valid at that time, essentially gaining
no new fees.</p>

<p>This does not entirely prevent fee sniping, but it does make it less
profitable in some cases and can help preserve the stability of the
Bitcoin network as the block subsidy declines.  We recommend all wallets
implement anti-fee sniping when it doesn’t interfere with the wallet’s
other uses of the lock time field.</p>

<p>As Bitcoin continues to mature, and as the subsidy continues to decline,
fees become more and more important to Bitcoin users, both in their
day-to-day use for getting transactions confirmed quickly and in
providing an incentive for miners to continue securing Bitcoin
transactions with new proof of work.</p>
</div>
</div></div>
  <span></span> <!-- for IntersectionObserver -->
  
  
  
  


<style id="note-styling">
    .note {
      position: absolute;
      z-index: 10;
      border: none;
      outline: none;
      font-family: inherit;
      font-size: inherit;
      padding: 5px;
      min-width: 32px;
      min-height: 32px;
    }
    .note:focus {
      z-index: 11;
    }
    .note[type="0"] {
      background-color: #fff740;
      color: #2c2c2d;
    }
    .note[type="0"]::placeholder {
      color: #868226;
    }
    .note[type="1"] {
      background-color: #feff9c;
      color: #2c2c2d;
    }
    .note[type="1"]::placeholder {
      color: #6d6d3d;
    }
    .note[type="2"] {
      background-color: #ff65a3;
      color: #2c2c2d;
    }
    .note[type="2"]::placeholder {
      color: #65263f;
    }
    .note[type="3"] {
      background-color: #ff7eb9;
      color: #2c2c2d;
    }
    .note[type="3"]::placeholder {
      color: #562b3f;
    }
    .note[type="4"] {
      background-color: #7afcff;
      color: #295c5d;
    }
    .note[type="4"]::placeholder {
      color: #377677;
    }</style><div id="chapters-container">
      <style>
        #chapters {
          display: grid;
          grid-template-columns: 1fr 1fr;
          margin: 2ch 0;
        }
        #chapters a {
          cursor: pointer;
        }
        #chapters a[href=""] {
          opacity: 0.5;
          pointer-events: none;
          color: inherit;
        }
        #chapters a:first-child {
          justify-self: start;
        }
        #chapters a:last-child {
          justify-self: end;
        }
      </style>
      <hr>
      <div id="chapters">
        <a href="" title="move to the previous chapter (Ctrl/Command + PageUp)">Previous Chapter</a>
        <a href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch10.html" title="move to the next chapter (Ctrl/Command + PageDown)">Next Chapter</a>
      </div>
    </div></body><style>body {
      font-size:  19px;
      font-family: Georgia, 'Times New Roman', serif;
      width: 600px;
    }
    p {
      text-align: justify
    }
    .page {
      line-height: 28.5px;
      column-count: unset;
    }
    h1, h2, h3 {
      line-height: initial;
    }</style></html>