<!DOCTYPE html>
<html><head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <base target="_blank">
  <style>
/* latin */
@font-face {
  font-family: 'Comic Neue';
  font-style: normal;
  font-weight: 400;
  src: url(fonts/4UaHrEJDsxBrF37olUeD96rp57F2IwM.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
/* latin */
@font-face {
  font-family: 'Lexend Deca';
  font-style: normal;
  font-weight: 400;
  src: url(fonts/K2FifZFYk-dHSE0UPPuwQ7CrD94i-NCKm-U48M1wqxnDirZPl3v-.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
/* latin */
@font-face {
  font-family: 'Poppins';
  font-style: normal;
  font-weight: 400;
  src: url(fonts/pxiEyp8kv8JHgFVrJJfecnFHGPc.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

:root {
  --fg: #000; /* foreground  */
  --bg: #fff; /* background  */
  --bd: #000; /* border  */
  --lk: #006fa5; /* link */
  --lkv: #d33bf0; /* link visited */
  --hg: #ffff81; /* highlight  */
}
html {
  overflow: overlay;
}
body {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  margin: 30px auto 0 auto;
  padding: 10px;
  position: relative;

  color: var(--fg);
  border-color: var(--bd);
  background-color: var(--bg);
}
body[data-mode$="dark"] {
  --lk: #0096de;
}
body[data-mode="light"] {
  color-scheme: light;
  --fg: #222;
  --bd: #222;
  --bg: whitesmoke;
}
body[data-mode="dark"] {
  color-scheme: dark;
  --fg: #eee;
  --bd: #eee;
  --bg: #333;
}
body[data-mode="sepia"] {
  color-scheme: light;
  --fg: #5b4636;
  --bd: #5b4636;
  --bg: #f4ecd8;
}
body[data-mode="solarized-light"] {
  color-scheme: light;
  --fg: #586e75;
  --bd: #586e75;
  --bg: #fdf6e3;
}
body[data-mode="nord-light"] {
  color-scheme: light;
  --fg: #2e3440;
  --bd: #2e3440;
  --bg: #e5e9f0;
}
body[data-mode="groove-dark"] {
  color-scheme: dark;
  --fg: #cec4ac;
  --bd: #cec4ac;
  --bg: #282828;
}
body[data-mode="solarized-dark"] {
  color-scheme: dark;
  --fg: #839496;
  --bd: #839496;
  --bg: #002b36;
}
body[data-mode="nord-dark"] {
  color-scheme: dark;
  --fg: #e5e9f0;
  --bd: #e5e9f0;
  --bg: #2e3440;
}

@media print {
  body[data-mode] {
    --fg: #000;
    --bd: #000;
    --bg: #fff;

    width: unset;
    padding: 0;
    margin: 0;
  }
}
body[data-loaded=true] {
  
}
img {
  max-width: 100%;
  height: auto;
}
img:not([width])[src$=".svg"] {
  max-width: 100px;
}
body[data-images=false] canvas,
body[data-images=false] svg,
body[data-images=false] img {
  display: none;
}
svg:not([width]):not([height]) {
  max-width: 25vmin;
}
a {
  color: var(--lk);
  text-decoration: none;
}
a:visited {
  color: var(--lkv);
}

hr {
  background-color: var(--bd);
  height: 1px;
  border: 0;
}
#reader-domain {
  font-family: Helvetica, Arial, sans-serif;
  text-decoration: none;
  border-bottom-color: currentcolor;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  width: 100%;
  display: inline-block;
  direction: ltr;
}
#reader-domain > span:first-child {
  font-size: 1.1em;
}
#reader-domain > span:last-child {
  font-size: 0.8em;
}
#reader-title {
  font-size: 1.6em;
  line-height: 1.25em;
  width: 100%;
  margin: 20px 0;
  padding: 0;
}
#reader-credits,
#doi,
#published-time,
#reader-estimated-time {
  font-size: 0.85em;
  line-height: 1.48em;
  margin: 0 0 10px 0;
  padding: 0;
}
#reader-credits:not(:empty)::after {
  content: ' ⋮ ';
}
#published-time:not(:empty)::before {
  content: ' ⋮ ';
}
#doi-json {
  overflow: hidden;
}
#doi-json code {
  overflow: auto;
  max-height: 400px;
}
#published-time:empty,
#reader-credits:empty {
  display: none;
}
mark.hghlght {
  background-color: var(--hg);
}
body:not([data-columns="1"]) .page :is(h1, h2) {
  column-span: all;
  background-color: rgba(125, 125, 125, 0.1);
  padding: 10px;
}
.hidden {
  display: none;
}
</style>
  <style id="user-css">body {
  padding-bottom: 64px;
}
pre {
  white-space: pre-wrap;
}
pre code {
  background-color: #eff0f1;
  color: #393318;
  font-family: monospace;
  display: block;
  padding: 5px 10px;
}
body[data-mode="dark"] pre code {
  background-color: #585858;
  color: #e8e8e8;
}

/* CSS for sans-serif fonts */
body[data-font=sans-serif] {}
/* CSS for serif fonts */
body[data-font=serif] {}

/* CSS for "sepia" theme */
body[data-mode=sepia] {}
/* CSS for "light" theme */
body[data-mode=light] {}
/* CSS for "dark" theme */
body[data-mode=dark] {}</style>
<title>14. Second-Layer Applications</title><title>14. Second-Layer Applications :: Reader View</title></head>
<body tabindex="1" data-images="true" data-mode="groove-dark" data-font="serif" data-columns="1" data-loaded="true">
  <span></span> <!-- for IntersectionObserver -->
  <a id="reader-domain" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch14.html">
    <span>learning.oreilly.com</span>
    <span>/library/view/mastering-bitcoin-3rd/9781098150082/ch14.html</span>
  </a>
  <h1 dir="auto" id="reader-title">14. Second-Layer Applications</h1>
  <span dir="auto" id="reader-credits"></span>
  <span dir="auto" id="reader-estimated-time">56-71 minutes</span>
  <span dir="auto" id="published-time"></span>
  <hr>
  <div id="readability-page-1" class="page"><div id="sbo-rt-content" data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 14. Second-Layer Applications">



<p>Let’s now build on our understanding of the primary Bitcoin system (the
<em>first layer</em>) by looking at it as a
platform for other applications, or <em>second layers</em>.
In this chapter we will look at the features offered by Bitcoin
as an application platform. We will consider the application
building <em>primitives</em>, which form the building blocks of any blockchain
application. We will look at several important applications that use
these primitives, such as client-side validation, payment channels, and
routed payment channels (Lightning Network).</p>






<div id="id218" data-type="sect1" data-pdf-bookmark="Building Blocks (Primitives)">
<h2>Building Blocks (Primitives)</h2>

<p>When <a data-type="indexterm" data-primary="Bitcoin" data-secondary="as application platform" data-tertiary="primitives, list of" data-secondary-sortas="application platform" id="bitcoin-app-platform-primitive" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="application platform, Bitcoin as" data-secondary="primitives, list of" id="app-platform-primitive" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="primitives" id="primitive-list" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="building blocks" id="build-block" target="_blank" rel="noopener noreferrer"></a>operating correctly and over the
long term, the Bitcoin system offers certain guarantees, which can be
used as building blocks to create applications. These include:</p>
<dl>
<dt>No double-spend</dt>
<dd>
<p>The most fundamental guarantee of Bitcoin’s
decentralized consensus algorithm ensures that no UTXO can be spent
twice in the same valid chain of blocks.</p>
</dd>
<dt>Immutability</dt>
<dd>
<p>Once a transaction is recorded in the blockchain and
sufficient work has been added with subsequent blocks, the transaction’s
data becomes practically immutable. Immutability is underwritten by energy, as
rewriting the blockchain requires the expenditure of energy to produce
PoW. The energy required and therefore the degree of
immutability increases with the amount of work committed on top of the
block containing a transaction.</p>
</dd>
</dl>
<dl>
<dt>Neutrality</dt>
<dd>
<p>The decentralized Bitcoin network propagates valid
transactions regardless of the origin of those transactions.
This means that anyone can create a valid transaction with sufficient
fees and trust they will be able to transmit that transaction and have
it included in the blockchain at any time.</p>
</dd>
<dt>Secure timestamping</dt>
<dd>
<p>The consensus rules reject any block whose
timestamp is too far in the future and attempt to prevent blocks with
timestamps too far in the past. This ensures that timestamps
on blocks can be trusted to a certain degree. The timestamp on a block implies an
unspent-before reference for the inputs of all included transactions.</p>
</dd>
<dt>Authorization</dt>
<dd>
<p>Digital signatures, validated in a decentralized
network, offer authorization guarantees. Scripts that contain a
requirement for a digital signature cannot be executed without
authorization by the holder of the private key implied in the script.</p>
</dd>
<dt>Auditability</dt>
<dd>
<p>All transactions are public and can be audited. All
transactions and blocks can be linked back in an unbroken chain to the
genesis block.</p>
</dd>
<dt>Accounting</dt>
<dd>
<p>In any transaction (except the coinbase transaction) the
value of inputs is equal to the value of outputs plus fees. It is not
possible to create or destroy bitcoin value in a transaction. The
outputs cannot exceed the inputs.</p>
</dd>
<dt>Nonexpiration</dt>
<dd>
<p>A valid transaction does not expire. If it is valid
today, it will be valid in the near future, as long as the inputs remain
unspent and the consensus rules do not change.</p>
</dd>
<dt>Integrity</dt>
<dd>
<p>The outputs of a Bitcoin transaction signed with <code>SIGHASH_ALL</code> or parts of
a transaction signed by another <code>SIGHASH</code> type cannot be modified
without invalidating the signature, thus invalidating the transaction
itself.</p>
</dd>
<dt>Transaction atomicity</dt>
<dd>
<p>Bitcoin transactions are atomic. They are either
valid and confirmed (mined) or not. Partial transactions cannot be mined,
and there is no interim state for a transaction. At any point in time a
transaction is either mined or not.</p>
</dd>
<dt>Discrete (indivisible) units of value</dt>
<dd>
<p>Transaction outputs are discrete
and indivisible units of value. They can either be spent or unspent, in
full. They cannot be divided or partially spent.</p>
</dd>
<dt>Quorum of control</dt>
<dd>
<p>Multisignature constraints in scripts impose a
quorum of authorization, predefined in the multisignature scheme. The
requirement is enforced by the consensus rules.</p>
</dd>
<dt>Timelock/aging</dt>
<dd>
<p>Any script clause containing a relative or absolute
timelock can only be executed after its age exceeds the time specified.</p>
</dd>
<dt>Replication</dt>
<dd>
<p>The decentralized storage of the blockchain ensures that
when a transaction is mined, after sufficient confirmations, it is
replicated across the network and becomes durable and resilient to power
loss, data loss, etc.</p>
</dd>
<dt>Forgery protection</dt>
<dd>
<p>A transaction can only spend existing, validated
outputs. It is not possible to create or counterfeit value.</p>
</dd>
<dt>Consistency</dt>
<dd>
<p>In the absence of miner partitions, blocks that are
recorded in the blockchain are subject to reorganization or disagreement
with exponentially decreasing likelihood, based on the depth at which
they are recorded. Once deeply recorded, the computation and energy
required to change makes change practically infeasible.</p>
</dd>
<dt>Recording external state</dt>
<dd>
<p>A transaction can commit to a data value, via
<code>OP_RETURN</code> or pay to contract, representing a state transition in an external state
machine.</p>
</dd>
<dt>Predictable issuance</dt>
<dd>
<p>Less than 21 million bitcoin will be issued at a
predictable rate.</p>
</dd>
</dl>

<p>The list of building blocks is not complete, and more are added with each
new feature introduced <a data-type="indexterm" data-primary="Bitcoin" data-secondary="as application platform" data-tertiary="primitives, list of" data-secondary-sortas="application platform" data-startref="bitcoin-app-platform-primitive" id="id1367" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="application platform, Bitcoin as" data-secondary="primitives, list of" data-startref="app-platform-primitive" id="id1368" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="primitives" data-startref="primitive-list" id="id1369" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="building blocks" data-startref="build-block" id="id1370" target="_blank" rel="noopener noreferrer"></a>into Bitcoin.</p>
</div>






<div id="id282" data-type="sect1" data-pdf-bookmark="Applications from Building Blocks">
<h2>Applications from Building Blocks</h2>

<p>The <a data-type="indexterm" data-primary="Bitcoin" data-secondary="as application platform" data-tertiary="example applications" data-secondary-sortas="application platform" id="bitcoin-app-platform-example" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="application platform, Bitcoin as" data-secondary="example applications" id="app-platform-example" target="_blank" rel="noopener noreferrer"></a>building blocks
offered by Bitcoin are elements of a trust platform that can be used to
compose applications. Here are some examples of applications that exist
today and the building blocks they use:</p>
<dl>
<dt>Proof-of-Existence (Digital Notary)</dt>
<dd>
<p>Immutability + Timestamp + Durability.
A transaction on the blockchain can commit to a value,
proving that a piece of data existed at the time
it was recorded (Timestamp). The commitment cannot be modified ex-post-facto
(Immutability), and the proof will be stored permanently (Durability).</p>
</dd>
<dt>Kickstarter (Lighthouse)</dt>
<dd>
<p>Consistency + Atomicity + Integrity. If you
sign one input and the output (Integrity) of a fundraiser transaction,
others can contribute to the fundraiser but it cannot be spent
(Atomicity) until the goal (output amount) is funded (Consistency).</p>
</dd>
<dt>Payment Channels</dt>
<dd>
<p>Quorum of Control + Timelock + No Double Spend + Nonexpiration
+ Censorship Resistance + Authorization. A multisig 2-of-2
(Quorum) with a timelock (Timelock) used as the “settlement” transaction
of a payment channel can be held (Nonexpiration) and spent at any time
(Censorship Resistance) by either party (Authorization). The two parties
can then create commitment transactions that supersede (No
Double-Spend) the settlement on a shorter timelock<a data-type="indexterm" data-primary="Bitcoin" data-secondary="as application platform" data-tertiary="example applications" data-secondary-sortas="application platform" data-startref="bitcoin-app-platform-example" id="id1371" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="application platform, Bitcoin as" data-secondary="example applications" data-startref="app-platform-example" id="id1372" target="_blank" rel="noopener noreferrer"></a> (Timelock).</p>
</dd>
</dl>
</div>






<div id="id219" data-type="sect1" data-pdf-bookmark="Colored Coins">
<h2>Colored Coins</h2>

<p>The first
blockchain<a data-type="indexterm" data-primary="Bitcoin" data-secondary="as application platform" data-tertiary="colored coins application" data-secondary-sortas="application platform" id="bitcoin-app-platform-color" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="application platform, Bitcoin as" data-secondary="colored coins application" id="app-platform-color" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="colored coins application" id="color-coin" target="_blank" rel="noopener noreferrer"></a> application we will discuss is <em>colored coins</em>.</p>

<p>Colored coins refers to a set of
similar technologies that use Bitcoin transactions to record the
creation, ownership, and transfer of extrinsic assets other than
bitcoin. By “extrinsic” we mean assets that are not stored directly on
the Bitcoin blockchain, as opposed to bitcoin itself, which is an asset
intrinsic to the blockchain.</p>

<p>Colored coins are used to track digital
assets as well as physical assets held by third parties and traded
through certificates of ownership associated with colored coins. Digital asset colored
coins can represent intangible assets such as a stock certificate,
license, virtual property (game items), or most any form of licensed
intellectual property (trademarks, copyrights, etc.). Tangible asset
colored coins can represent certificates of ownership of commodities
(gold, silver, oil), land titles, automobiles, boats, aircraft, etc.</p>

<p>The term derives
from the idea of “coloring” or marking a nominal amount of bitcoin, for
example, a single satoshi, to represent something other than the bitcoin
amount itself. As an analogy, consider stamping a $1 note with a message
saying, “this is a stock certificate of ACME” or “this note can be
redeemed for 1 oz of silver” and then trading the $1 note as a
certificate of ownership of this other asset. The first implementation
of colored coins, named <em>Enhanced Padded-Order-Based Coloring</em> or
<em>EPOBC</em>, assigned extrinsic assets to a 1-satoshi output. In this way,
it was a true “colored coin,” as each asset was added as an attribute
(color) of a single satoshi.</p>

<p>More recent implementations of colored coins use other mechanisms
to attach metadata with a transaction, in conjunction with external
data stores that associate the metadata to specific assets.  The three
main mechanisms used as of this writing are single-use seals,
pay to contract, and client-side validation.</p>








<div id="single_use_seals" data-type="sect2" data-pdf-bookmark="Single-Use Seals">
<h2>Single-Use Seals</h2>

<p>Single-use seals <a data-type="indexterm" data-primary="colored coins application" data-secondary="single-use seals" id="id1373" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="single-use seals" id="id1374" target="_blank" rel="noopener noreferrer"></a>originate in physical security.  Someone shipping an
item through a third party needs a way to detect tampering, so they
secure their package with a special mechanism that will become clearly
damaged if the package is opened.  If the package arrives with the seal
intact, the sender and receiver can be confident that the package wasn’t
opened in transit.</p>

<p>In the context of colored coins, single-use seals refer to a data
structure than can only be associated with another data structure once.
In Bitcoin, this<a data-type="indexterm" data-primary="UTXOs (unspent transaction outputs)" id="id1375" target="_blank" rel="noopener noreferrer"></a> definition is fulfilled by unspent transaction outputs
(UTXOs).  A UTXO can only be spent once within a valid blockchain, and
the process of spending them associates them with the data in the
spending transaction.</p>

<p>This provides part of the basis for the modern transfer for colored
coins.  One or more colored coins are received to a UTXO.  When that
UTXO is spent, the spending transaction must describe how the colored
coins are to be spent.  That brings us to pay to contract (P2C).</p>
</div>








<div id="p2c_for_colored_coins" data-type="sect2" data-pdf-bookmark="Pay to Contract (P2C)">
<h2>Pay to Contract (P2C)</h2>

<p>We <a data-type="indexterm" data-primary="colored coins application" data-secondary="P2C (pay to contract)" id="color-coin-p2c" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="P2C (pay to contract)" id="p2c-color-coin" target="_blank" rel="noopener noreferrer"></a>previously learned about P2C in <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch07.html#pay_to_contract" target="_blank" rel="noopener noreferrer">“Pay to Contract (P2C)”</a>, where it became
part of the basis for the taproot upgrade to Bitcoin’s consensus rules.
As a short reminder, P2C allows a spender (Bob) and receiver (Alice) to
agree on some data, such as a contract, and then<a data-type="indexterm" data-primary="key tweaks" id="id1376" target="_blank" rel="noopener noreferrer"></a> tweak Alice’s public
key so that it commits to the contract.  At any time, Bob can reveal
Alice’s underlying key and the tweak used to commit to the contract,
proving that she received the funds.  If Alice spends the funds, that
fully proves that she knew about the contract, since the only way she
could spend the funds received to a P2C tweaked key is by knowing the
tweak (the contract).</p>

<p>A powerful attribute of P2C tweaked keys is that they look like any
other public keys to everyone besides Alice and Bob, unless they choose
to reveal the contract used to tweak the keys.  Nothing is publicly
revealed about the contract—​not even that a contract between them
exists.</p>

<p>A P2C contract can be arbitrarily long and detailed, the terms can be written
in any language, and it can reference anything the participants want
because the contract is not validated by full nodes and only the public
key with the commitment is published to the blockchain.</p>

<p>In the context of colored coins, Bob can open the single-use seal
containing his colored coins by spending the associated UTXO.  In the
transaction spending that UTXO, he can commit to a contract indicating
the terms that the next owner (or owners) of the colored coins must
fulfill in order to further spend the coins.  The new owner doesn’t need
to be Alice, even though Alice is the one receiving the UTXO that Bob
spends and Alice has tweaked her public key by the contract terms.</p>

<p>Because full nodes don’t (and can’t) validate that the contract is
followed correctly, we need to figure out who is responsible for
validation.  That brings <a data-type="indexterm" data-primary="colored coins application" data-secondary="P2C (pay to contract)" data-startref="color-coin-p2c" id="id1377" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="P2C (pay to contract)" data-startref="p2c-color-coin" id="id1378" target="_blank" rel="noopener noreferrer"></a>us to <em>client-side validation.</em></p>
</div>








<div id="id222" data-type="sect2" data-pdf-bookmark="Client-Side Validation">
<h2>Client-Side Validation</h2>

<p>Bob had <a data-type="indexterm" data-primary="colored coins application" data-secondary="client-side validation" id="id1379" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="client-side validation" id="id1380" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="validating" data-secondary="with client-side validation" data-secondary-sortas="client-side validation" id="id1381" target="_blank" rel="noopener noreferrer"></a>some colored coins associated with a UTXO.  He spent that UTXO
in a way that committed to a contract that indicated how the next
receiver (or receivers) of the colored coins will prove their ownership
over the coins in order to further spend them.</p>

<p>In practice, Bob’s P2C contract likely simply committed to one or more
unique identifiers for the UTXOs that will be used as single-use seals
for deciding when the colored coins are next spent.  For example, Bob’s
contract may have indicated that the UTXO Alice received to her P2C
tweaked public key now controls half of his colored coins, with the
other half of his colored coins now being assigned to a different UTXO
that may have nothing to do with the transaction between Alice and Bob.
This provides significant privacy against blockchain surveillance.</p>

<p>When Alice later wants to spend her colored coins to Dan, she first
needs to prove to Dan that she controls the colored coins.  Alice can do
this by revealing to Dan her underlying P2C public key and the P2C contract
terms chosen by Bob.  Alice also reveals to Dan the UTXO that Bob used
as the single-use seal and any information that Bob gave her about the
previous owners of the colored coins.  In short, Alice gives Dan a
complete set of history about every previous transfer of the colored
coins, with each step anchored in the Bitcoin blockchain (but not
storing any special data in the chain—​just regular public keys).  That
history is a lot like the history of regular Bitcoin transactions that
we call the blockchain, but the colored history is completely invisible
to other users of the blockchain.</p>

<p>Dan validates this history using his software, called <em>client-side
validation</em>.  Notably, Dan only needs to receive and validate the parts
of history that pertain to the colored coins he wants to receive.  He
doesn’t need information about what happened to other people’s colored
coins—​for example, he’ll never need to know what happened to the other
half of Bob’s coins, the ones that Bob didn’t transfer to Alice.  This
helps enhance the privacy of the colored coin protocol.</p>

<p>Now that we’ve learned about single-use seals, pay to contract, and
client-side validation, we can look at the two main protocols that use
them as of this writing, RGB and Taproot Assets.</p>
</div>








<div id="id223" data-type="sect2" data-pdf-bookmark="RGB">
<h2>RGB</h2>

<p>Developers <a data-type="indexterm" data-primary="colored coins application" data-secondary="RGB protocol" id="color-coin-rgb" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="RGB protocol" id="rgb" target="_blank" rel="noopener noreferrer"></a>of the RGB protocol pioneered many of the ideas used in
modern Bitcoin-based colored coin protocols.  A primary requirement of
the design for RGB was making the protocol compatible with offchain
payment channels (see <a data-type="xref" href="#state_channels" target="_blank" rel="noopener noreferrer">“Payment Channels and State Channels”</a>), such as those used in
Lightning Network (LN).  That’s accomplished at each layer of the RGB
protocol:</p>
<dl>
<dt>Single-use seals</dt>
<dd>
<p>To create a payment channel, Bob assigns his colored
  coins to a UTXO that requires signatures from both him and Alice to
  spend.  Their mutual control over that UTXO serves as the single-use
  seal for future transfers.</p>
</dd>
<dt>Pay to contract (P2C)</dt>
<dd>
<p>Alice and Bob can now sign multiple versions of
  a P2C contract.  The enforcement mechanism of the underlying payment
  channel ensures that both parties are incentivized to only publish the
  latest version of the contract onchain.</p>
</dd>
<dt>Client-side validation</dt>
<dd>
<p>To ensure that neither Alice nor Bob needs to
  trust each other, they each check all previous transfers of the
  colored coins back to their creation to ensure all contract rules were
  followed correctly.</p>
</dd>
</dl>

<p>The developers of RGB have described other uses for their protocol, such
as creating identity tokens that can be periodically updated to protect
against private key compromise.</p>

<p>For more information, <a data-type="indexterm" data-primary="colored coins application" data-secondary="RGB protocol" data-startref="color-coin-rgb" id="id1382" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="RGB protocol" data-startref="rgb" id="id1383" target="_blank" rel="noopener noreferrer"></a>see <a href="https://rgb.tech/" target="_blank" rel="noopener noreferrer">RGB’s documentation</a>.</p>
</div>








<div id="id224" data-type="sect2" data-pdf-bookmark="Taproot Assets">
<h2>Taproot Assets</h2>

<p>Formerly <a data-type="indexterm" data-primary="colored coins application" data-secondary="Taproot Assets" id="color-coin-taproot" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="Taproot Assets" id="taproot-assets" target="_blank" rel="noopener noreferrer"></a>called Taro, Taproot Assets are a colored coin protocol that is
heavily influenced by RGB.  Compared to RGB, Taproot Assets use a form
of P2C contracts that is very similar to the version used by taproot for
enabling MAST functionality (see <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch07.html#mast" target="_blank" rel="noopener noreferrer">“Merklized Alternative Script Trees (MAST)”</a>).  The claimed advantage of
Taproot Assets over RGB is that its similarity to the widely used
taproot protocol makes it simpler for wallets and other software to
implement.  One downside is that it may not be as flexible as the RGB
protocol, especially when it comes to implementing nonasset features
such as identity tokens.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><em>Taproot</em> is part of the Bitcoin protocol.  <em>Taproot Assets</em> is not,
despite the similar name.  Both RGB and Taproot Assets are protocols
built on top of the Bitcoin protocol.  The only asset natively supported
by Bitcoin is bitcoin.</p>
</div>

<p>Even more than RGB, Taproot Assets has been designed to be compatible
with LN.  One challenge with forwarding nonbitcoin assets
over LN is that there are two ways to accomplish the
sending, each with a different set of trade-offs:</p>
<dl>
<dt>Native forwarding</dt>
<dd>
<p>Every <a data-type="indexterm" data-primary="native forwarding" id="id1384" target="_blank" rel="noopener noreferrer"></a>hop in the path between the spender and the receiver must know
about the particular asset (type of colored coin) and have a
sufficient balance of it to support forwarding a payment.</p>
</dd>
<dt>Translated forwarding</dt>
<dd>
<p>The hop next to the spender and<a data-type="indexterm" data-primary="translated forwarding" id="id1385" target="_blank" rel="noopener noreferrer"></a> the hop next to the receiver must know
about the particular asset and have a sufficient balance of it to
support forwarding a payment, but every other hop only needs to
support forwarding bitcoin 
<span>payments.</span></p>
</dd>
</dl>

<p>Native forwarding is conceptually simpler but essentially requires a
separate Lightning-type network for every asset.  Translated forwarding
allows building on the economies of scale of the Bitcoin LN, but it may be vulnerable to a problem called<a data-type="indexterm" data-primary="free American call option" id="id1386" target="_blank" rel="noopener noreferrer"></a> the <em>free American
call option</em>, where a receiver may selectively accept or reject certain
payments depending on recent changes to the exchange rate in order to
siphon money from the hop next to them.  Although there’s no known
perfect solution to the free American call option, there may be
practical solutions that limit its harm.</p>

<p>Both Taproot Assets and RGB can technically support both native and
translated forwarding.  Taproot Assets is specifically designed around
translated forwarding, whereas RGB has seen proposals to implement both.</p>

<p>For more information, see
<a href="https://oreil.ly/Ef4hb" target="_blank" rel="noopener noreferrer">Taproot
Asset’s documentation</a>.  Additionally, the Taproot Asset developers are
working on BIPs that may be available after this book goes<a data-type="indexterm" data-primary="Bitcoin" data-secondary="as application platform" data-tertiary="colored coins application" data-secondary-sortas="application platform" data-startref="bitcoin-app-platform-color" id="id1387" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="application platform, Bitcoin as" data-secondary="colored coins application" data-startref="app-platform-color" id="id1388" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="colored coins application" data-startref="color-coin" id="id1389" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="colored coins application" data-secondary="Taproot Assets" data-startref="color-coin-taproot" id="id1390" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="Taproot Assets" data-startref="taproot-assets" id="id1391" target="_blank" rel="noopener noreferrer"></a> into print.</p>
</div>
</div>






<div id="state_channels" data-type="sect1" data-pdf-bookmark="Payment Channels and State Channels">
<h2>Payment Channels and State Channels</h2>

<p><em>Payment channels</em> are <a data-type="indexterm" data-primary="Bitcoin" data-secondary="as application platform" data-tertiary="payment channels" data-secondary-sortas="application platform" id="bitcoin-app-platform-payment" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="application platform, Bitcoin as" data-secondary="payment channels" id="app-platform-payment" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="payment channels" id="payment-channel" target="_blank" rel="noopener noreferrer"></a>a trustless mechanism for exchanging Bitcoin
transactions between two parties outside of the Bitcoin blockchain.
These transactions, which would be valid if settled on the Bitcoin
blockchain, are held offchain instead, waiting for
eventual batch settlement. Because the transactions are not settled,
they can be exchanged without the usual settlement latency, allowing
extremely high transaction throughput, low latency, and
fine granularity.</p>

<p>Actually, the term <em>channel</em> is a metaphor. State channels are virtual
constructs represented by the exchange of state between two parties
outside of the blockchain. There are no “channels” per se, and the
underlying data transport mechanism is not the channel. We use the term
<em>channel</em> to represent the relationship and shared state between two
parties outside of the blockchain.</p>

<p>To further explain this
concept, think of a TCP stream. From the perspective of higher-level
protocols, it is a “socket” connecting two applications across the
internet. But if you look at the network traffic, a TCP stream is just a
virtual channel over IP packets. Each endpoint of the TCP stream
sequences and assembles IP packets to create the illusion of a stream of
bytes. Underneath, it’s all disconnected packets. Similarly, a payment
channel is just a series of transactions. If properly sequenced and
connected, they create redeemable obligations that you can trust even
though you don’t trust the other side of the channel.</p>

<p>In this section we will look at various forms of payment channels.
First, we will examine the mechanisms used to construct a one-way
(unidirectional) payment channel for a metered micropayment service,
such as streaming video. Then, we will expand on this mechanism and
introduce bidirectional payment channels. Finally, we will look at how
bidirectional channels can be connected end-to-end to form multihop
channels in a routed network, first proposed under the name <em>Lightning
Network</em>.</p>

<p>Payment channels are part of the broader concept of a <em>state channel</em>,
which represents an offchain alteration of state, secured by eventual
settlement in a blockchain. A payment channel is a state channel where
the state being altered is the balance of a virtual currency.</p>








<div id="id226" data-type="sect2" data-pdf-bookmark="State Channels—Basic Concepts and Terminology">
<h2>State Channels—Basic Concepts and Terminology</h2>

<p>A state channel<a data-type="indexterm" data-primary="payment channels" data-secondary="state channels" id="payment-channel-state" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="state channels" id="state-channel-terminology" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="transactions" data-secondary="state channels" id="transaction-state" target="_blank" rel="noopener noreferrer"></a> is
established between two parties through a transaction that locks a
shared state on the blockchain. This is called <a data-type="indexterm" data-primary="funding transactions" id="id1392" target="_blank" rel="noopener noreferrer"></a>the <em>funding transaction</em>.
This single transaction must be transmitted to
the network and mined to establish the channel. In the example of a
payment channel, the locked state is the initial balance (in currency)
of the channel.</p>

<p>The two parties then exchange signed transactions, <a data-type="indexterm" data-primary="commitment transactions" id="id1393" target="_blank" rel="noopener noreferrer"></a>called <em>commitment
transactions</em>, that alter the initial state. These transactions are
valid transactions in that they <em>could</em> be submitted for settlement by
either party, but instead are held offchain by each party pending the
channel closure. State updates can be created as fast as each party can
create, sign, and transmit a transaction to the other party. In practice
this means that dozens of transactions per second can be exchanged.</p>

<p>When exchanging commitment transactions the two parties also discourage
use of the previous states, so that the most up-to-date commitment transaction
is always the best one to be redeemed. This discourages either party
from cheating by unilaterally closing the channel with a prior
state that is more favorable to them than the current state. We will
examine the various mechanisms that can be used to discourage
publication of prior states in the rest of this chapter.</p>

<p>Finally, the channel can be closed either cooperatively, by <a data-type="indexterm" data-primary="settlement transactions" id="id1394" target="_blank" rel="noopener noreferrer"></a>submitting a
final <em>settlement transaction</em> to the blockchain, or unilaterally, by
either party submitting the last commitment transaction to the
blockchain. A unilateral close option is needed in case one of the
parties unexpectedly disconnects. The settlement transaction represents
the final state of the channel and is settled on the blockchain.</p>

<p>In the entire lifetime of the channel, only two transactions need to be
submitted for mining on the blockchain: the funding and settlement
transactions. In between these two states, the two parties can exchange
any number of commitment transactions that are never seen by anyone
else or submitted to the blockchain.</p>

<p><a data-type="xref" href="#payment_channel" target="_blank" rel="noopener noreferrer">Figure&nbsp;14-1</a> illustrates a payment channel between Bob and Alice,
showing the funding, commitment, and settlement <a data-type="indexterm" data-primary="payment channels" data-secondary="state channels" data-startref="payment-channel-state" id="id1395" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="state channels" data-startref="state-channel-terminology" id="id1396" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="transactions" data-secondary="state channels" data-startref="transaction-state" id="id1397" target="_blank" rel="noopener noreferrer"></a>transactions.</p>

<figure><div id="payment_channel">
<p><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098150082/files/assets/mbc3_1401.png" alt="" width="356" height="800"></p><h6><span>Figure 14-1. </span>A payment channel between Bob and Alice, showing the funding, commitment, and settlement transactions.</h6>
</div></figure>
</div>








<div id="id283" data-type="sect2" data-pdf-bookmark="Simple Payment Channel Example">
<h2>Simple Payment Channel Example</h2>

<p>To
explain <a data-type="indexterm" data-primary="payment channels" data-secondary="example of" id="payment-channel-example" target="_blank" rel="noopener noreferrer"></a>state channels, we start with a very simple example. We
demonstrate a one-way channel, meaning that value is flowing in one
direction only. We will also start with the naive assumption that no one
is trying to cheat to keep things simple. Once we have the basic
channel idea explained, we will then look at what it takes to make it
trustless so that neither party <em>can</em> cheat, even if they are trying to.</p>

<p>For this example we will assume two participants: Emma and Fabian.
Fabian offers a video streaming service that is billed by the second
using a micropayment channel. Fabian charges 0.01 millibit (0.00001 BTC)
per second of video, equivalent to 36 millibits (0.036 BTC) per hour of
video. Emma is a user who purchases this streaming video service from
Fabian. <a data-type="xref" href="#emma_fabian_streaming_video" target="_blank" rel="noopener noreferrer">Figure&nbsp;14-2</a> shows Emma buying the video
streaming service from Fabian using a payment channel.</p>

<figure><div id="emma_fabian_streaming_video">
<p><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098150082/files/assets/mbc3_1402.png" alt="" width="600" height="450"></p><h6><span>Figure 14-2. </span>Emma purchases streaming video from Fabian with a payment channel, paying for each second of video.</h6>
</div></figure>

<p>In this example, Fabian and Emma are using special software that handles
both the payment channel and the video streaming. Emma is running the
software in her browser; Fabian is running it on a server. The software
includes basic Bitcoin wallet functionality and can create and sign
Bitcoin transactions. Both the concept and the term “payment channel”
are completely hidden from the users. What they see is video that is
paid for by the second.</p>

<p>To set up the payment channel, Emma and Fabian establish a 2-of-2
multisignature address, with each of them holding one of the keys. From
Emma’s perspective, the software in her browser presents a QR code with
the address, and asks her to submit a “deposit”
for up to 1 hour of video. The address is then funded by Emma. Emma’s
transaction, paying to the multisignature address, is the funding or
anchor transaction for the payment channel.</p>

<p>For this example, let’s say that Emma funds the channel with 36
millibits (0.036 BTC). This will allow Emma to consume <em>up to</em> 1 hour of
streaming video. The funding transaction in this case sets the maximum
amount that can be transmitted in this channel, setting the <em>channel
capacity</em>.</p>

<p>The funding transaction consumes one or more inputs from Emma’s wallet,
sourcing the funds. It creates one output with an amount of 36 millibits
paid to the multisignature 2-of-2 address controlled jointly between
Emma and Fabian. It may have additional outputs for change back to
Emma’s wallet.</p>

<p>After the funding transaction is confirmed to a sufficient depth, Emma can start streaming
video. Emma’s software creates and signs a commitment transaction that
changes the channel balance to credit 0.01 millibit to Fabian’s address
and refund 35.99 millibits back to Emma. The transaction signed by Emma
consumes the 36 millibits output created by the funding transaction and
creates two outputs: one for her refund, the other for Fabian’s payment.
The transaction is only partially signed—it requires two
signatures (2-of-2), but only has Emma’s signature. When Fabian’s server
receives this transaction, it adds the second signature (for the 2-of-2
input) and returns it to Emma together with 1 second worth of video. Now
both parties have a fully signed commitment transaction that either can
redeem, representing the correct up-to-date balance of the channel.
Neither party broadcasts this transaction to the network.</p>

<p>In the next round, Emma’s software creates and signs another commitment
transaction (commitment #2) that consumes the <em>same</em> 2-of-2 output from
the funding transaction. The second commitment transaction allocates one
output of 0.02 millibits to Fabian’s address and one output of 35.98
millibits back to Emma’s address. This new transaction is payment for
two cumulative seconds of video. Fabian’s software signs and returns the
second commitment transaction, together with another second of video.</p>

<p>In this way, Emma’s software continues to send commitment transactions
to Fabian’s server in exchange for streaming video. The balance of the
channel gradually accumulates in favor of Fabian as Emma consumes more
seconds of video. Let’s say Emma watches 600 seconds (10 minutes) of
video, creating and signing 600 commitment transactions. The last
commitment transaction (#600) will have two outputs, splitting the
balance of the channel, 6 millibits to Fabian and 30 millibits to Emma.</p>

<p>Finally, Emma clicks “Stop” to stop streaming video. Either Fabian or
Emma can now transmit the final state transaction for settlement. This
last transaction is the <em>settlement transaction</em> and pays Fabian for all
the video Emma consumed, refunding the remainder of the funding
transaction to Emma.</p>

<p><a data-type="xref" href="#video_payment_channel" target="_blank" rel="noopener noreferrer">Figure&nbsp;14-3</a> shows the channel between Emma and Fabian and
the commitment transactions that update the balance of the channel.</p>

<p>In the end, only two transactions are recorded on the blockchain: the
funding transaction that established the channel and a settlement
transaction that allocated the final balance correctly between<a data-type="indexterm" data-primary="payment channels" data-secondary="example of" data-startref="payment-channel-example" id="id1398" target="_blank" rel="noopener noreferrer"></a> the two
participants.</p>

<figure><div id="video_payment_channel">
<p><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098150082/files/assets/mbc3_1403.png" alt="" width="353" height="800"></p><h6><span>Figure 14-3. </span>Emma’s payment channel with Fabian, showing the commitment transactions that update the balance of the channel.</h6>
</div></figure>
</div>








<div id="id227" data-type="sect2" data-pdf-bookmark="Making Trustless Channels">
<h2>Making Trustless Channels</h2>

<p>The channel <a data-type="indexterm" data-primary="payment channels" data-secondary="trustless channels" id="payment-channel-trustless" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="trustless channels" id="trustless-channel" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="timelocks" data-secondary="trustless channels" id="timelock-trustless" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="commitment transactions" data-secondary="trustless channels" id="commit-trustless" target="_blank" rel="noopener noreferrer"></a>we just described works, but only if both
parties cooperate, without any failures or attempts to cheat. Let’s look
at some of the scenarios that break this channel and see what is needed
to fix those:</p>

<ul>
<li>
<p>Once the funding transaction happens, Emma needs Fabian’s signature to
get any money back. If Fabian disappears, Emma’s funds are locked in a
2-of-2 and effectively lost. This channel, as constructed, leads to a
loss of funds if one of the parties becomes unavailable before there is at
least one commitment transaction signed by both parties.</p>
</li>
<li>
<p>While the channel is running, Emma can take any of the commitment
transactions Fabian has countersigned and transmit one to the
blockchain. Why pay for 600 seconds of video if she can transmit
commitment transaction #1 and only pay for 1 second of video? The
channel fails because Emma can cheat by broadcasting a prior
commitment that is in her favor.</p>
</li>
</ul>

<p>Both of these problems can be solved with timelocks—let’s look at
how we could use transaction-level timelocks.</p>

<p>Emma cannot risk funding a 2-of-2 multisig unless she has a guaranteed
refund. To solve this problem, Emma constructs the funding and refund
transaction at the same time. She signs the funding transaction but
doesn’t transmit it to anyone. Emma transmits only the refund
transaction to Fabian and obtains his signature.</p>

<p>The refund transaction acts as the first commitment transaction, and its
timelock establishes the upper bound for the channel’s life. In this
case, Emma could set the lock time to 30 days or 4,320 blocks into the
future. All subsequent commitment transactions must have a shorter
timelock so they can be redeemed before the refund transaction.</p>

<p>Now that Emma has a fully signed refund transaction, she can confidently
transmit the signed funding transaction knowing that she can eventually,
after the timelock expires, redeem the refund transaction even if Fabian
disappears.</p>

<p>Every commitment transaction the parties exchange during the life of the
channel will be timelocked into the future. But the delay will be
slightly shorter for each commitment, so the most recent commitment can
be redeemed before the prior commitment it invalidates. Because of the
lock time, neither party can successfully propagate any of the
commitment transactions until their timelock expires. If all goes well,
they will cooperate and close the channel gracefully with a settlement
transaction, making it unnecessary to transmit an intermediate
commitment transaction. If not, the most recent commitment transaction
can be propagated to settle the account and invalidate all prior
commitment transactions.</p>

<p>For example, if commitment transaction #1 is timelocked to 4,320 blocks
in the future, then commitment transaction #2 is timelocked to 4,319
blocks in the future. Commitment transaction #600 can be spent 600
blocks before commitment transaction #1 becomes valid.</p>

<p><a data-type="xref" href="#timelocked_commitments" target="_blank" rel="noopener noreferrer">Figure&nbsp;14-4</a> shows each commitment transaction setting a
shorter timelock, allowing it to be spent before the previous
commitments become valid.</p>

<figure><div id="timelocked_commitments">
<p><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098150082/files/assets/mbc3_1404.png" alt="" width="600" height="214"></p><h6><span>Figure 14-4. </span>Each commitment sets a shorter timelock, allowing it to be spent before the previous commitments become valid.</h6>
</div></figure>

<p>Each subsequent commitment transaction must have a shorter timelock so
that it may be broadcast before its predecessors and before the refund
transaction. The ability to broadcast a commitment earlier ensures it
will be able to spend the funding output and preclude any other
commitment transaction from being redeemed by spending the output. The
guarantees offered by the Bitcoin blockchain, preventing double-spends
and enforcing timelocks, effectively allow each commitment transaction
to invalidate its predecessors.</p>

<p>State channels use timelocks to enforce smart contracts across a time
dimension. In this example we saw how the time dimension guarantees that
the most recent commitment transaction becomes valid before any earlier
commitments. Thus, the most recent commitment transaction can be
transmitted, spending the inputs and invalidating prior commitment
transactions. The enforcement of smart contracts with absolute timelocks
protects against cheating by one of the parties. This implementation
needs nothing more than absolute transaction-level lock time.
Next, we will see how script-level timelocks,
<code>CHECKLOCKTIMEVERIFY</code> and <code>CHECKSEQUENCEVERIFY</code>, can be used to
construct more flexible, useful, and sophisticated state channels.</p>

<p>Timelocks are not the only way to invalidate prior commitment
transactions. In the next sections we will see how a revocation key can
be used to achieve the same result. Timelocks are effective, but they
have two distinct disadvantages. By establishing a maximum timelock when
the channel is first opened, they limit the lifetime of the channel.
Worse, they force channel implementations to strike a balance between
allowing long-lived channels and forcing one of the participants to wait
a very long time for a refund in case of premature closure. For example,
if you allow the channel to remain open for 30 days by setting the
refund timelock to 30 days, if one of the parties disappears immediately,
the other party must wait 30 days for a refund. The more distant the
endpoint, the more distant the refund.</p>

<p>The second problem is that since each subsequent commitment transaction
must decrement the timelock, there is an explicit limit on the number of
commitment transactions that can be exchanged between the parties. For
example, a 30-day channel, setting a timelock of 4,320 blocks into the
future, can only accommodate 4,320 intermediate commitment transactions
before it must be closed. There is a danger in setting the timelock
commitment transaction interval at 1 block. By setting the timelock
interval between commitment transactions to 1 block, a developer is
creating a very high burden for the channel participants who have to be
vigilant, remain online and watching, and be ready to transmit the right
commitment transaction at any time.</p>

<p>In the preceding example of a single-direction channel, it’s easy to
eliminate the per-commitment timelock.  After Emma receives the
signature on the timelocked refund transaction from Fabian, no timelocks
are placed on the commitment transactions.  Instead, Emma sends her
signature on each commitment transaction to Fabian but Fabian doesn’t
send her any of his signatures on the commitment transactions.  That
means only Fabian has both signatures for a commitment transaction, so
only he can broadcast one of those commitments.  When Emma finishes
streaming video, Fabian will always prefer to broadcast the transaction
that pays him the most—​which will be the latest state.  This
construction in called a Spillman-style payment channel, which was first
described and implemented in 2013, although they are only safe to use
with witness (segwit) transactions, which didn’t become available until
2017.</p>

<p>Now that we understand how timelocks can be used to invalidate prior
commitments, we can see the difference between closing the channel
cooperatively and closing it unilaterally by broadcasting a commitment
transaction. All commitment transactions in our prior example were timelocked, therefore
broadcasting a commitment transaction will always involve waiting until
the timelock has expired. But if the two parties agree on what the final
balance is and know they both hold commitment transactions that will
eventually make that balance a reality, they can construct a settlement
transaction without a timelock representing that same balance. In a
cooperative close, either party takes the most recent commitment
transaction and builds a settlement transaction that is identical in
every way except that it omits the timelock. Both parties can sign this
settlement transaction knowing there is no way to cheat and get a more
favorable balance. By cooperatively signing and transmitting the
settlement transaction, they can close the channel and redeem their
balance immediately. Worst case, one of the parties can be petty, refuse
to cooperate, and force the other party to do a unilateral close with
the most recent commitment transaction. If they do that, they have
to wait for their funds <a data-type="indexterm" data-primary="payment channels" data-secondary="trustless channels" data-startref="payment-channel-trustless" id="id1399" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="trustless channels" data-startref="trustless-channel" id="id1400" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="timelocks" data-secondary="trustless channels" data-startref="timelock-trustless" id="id1401" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="commitment transactions" data-secondary="trustless channels" data-startref="commit-trustless" id="id1402" target="_blank" rel="noopener noreferrer"></a>too.</p>
</div>








<div id="id228" data-type="sect2" data-pdf-bookmark="Asymmetric Revocable Commitments">
<h2>Asymmetric Revocable Commitments</h2>

<p>Another way<a data-type="indexterm" data-primary="payment channels" data-secondary="asymmetric revocable commitments" id="payment-channel-revoke" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="asymmetric revocable commitments" id="asymmetric-revoke-commit" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="commitment transactions" data-secondary="asymmetric revocable commitments" id="commit-revoke" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="revocable commitments" id="revoke-commit" target="_blank" rel="noopener noreferrer"></a> to handle the prior commitment states
is to explicitly revoke them. However, this is not easy to achieve. A
key characteristic of Bitcoin is that once a transaction is valid, it
remains valid and does not expire. The only way to cancel a transaction
is to get a conflicting transaction confirmed.
That’s why we used timelocks in the simple payment channel
example to ensure that more recent commitments could be spent
before older commitments were valid. However, sequencing commitments in
time creates a number of constraints that make payment channels
difficult to use.</p>

<p>Even though a transaction cannot be canceled, it can be constructed in
such a way as to make it undesirable to use. The way we do that is by
giving each party a <em>revocation key</em> that can be used to punish the
other party if they try to cheat. This mechanism for revoking prior
commitment transactions was first proposed as part of the LN.</p>

<p>To explain revocation keys, we will construct a more complex payment
channel between two exchanges run by Hitesh and Irene. Hitesh and Irene
run Bitcoin exchanges in India and the USA, respectively. Customers of
Hitesh’s Indian exchange often send payments to customers of Irene’s USA
exchange and vice versa. Currently, these transactions occur on the
Bitcoin blockchain, but this means paying fees and waiting several
blocks for confirmations. Setting up a payment channel between the
exchanges will significantly reduce the cost and accelerate the
transaction flow.</p>

<p>Hitesh and Irene start the channel by collaboratively constructing a
funding transaction, each funding the channel with 5 bitcoin.  Before
they sign the funding transaction, they must sign the first set of
commitments (called the <em>refund</em>) that assigns the
initial balance of 5 bitcoin for Hitesh and 5 bitcoin for Irene. The
funding transaction locks the channel state in a 2-of-2 multisig, just
like in the example of a simple channel.</p>

<p>The funding transaction may have one or more inputs from Hitesh (adding
up to 5 bitcoins or more), and one or more inputs from Irene (adding up
to 5 bitcoins or more). The inputs have to slightly exceed the channel
capacity in order to cover the transaction fees. The transaction has one
output that locks the 10 total bitcoins to a 2-of-2 multisig address
controlled by both Hitesh and Irene. The funding transaction may also
have one or more outputs returning change to Hitesh and Irene if their
inputs exceeded their intended channel contribution. This is a single
transaction with inputs offered and signed by two parties. It has to be
constructed in collaboration and signed by each party before it is
transmitted.</p>

<p>Now, instead of creating a single commitment transaction that both
parties sign, Hitesh and Irene create two different commitment
transactions that are <em>asymmetric</em>.</p>

<p>Hitesh has a commitment transaction with two outputs. The first output
pays Irene the 5 bitcoins she is owed <em>immediately</em>. The second output
pays Hitesh the 5 bitcoins he is owed, but only after a timelock of 1,000
blocks. The transaction outputs look like this:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">Input: 2-of-2 funding output, signed by Irene

Output 0 &lt;5 bitcoins&gt;:
    &lt;Irene's Public Key&gt; CHECKSIG

Output 1 &lt;5 bitcoins&gt;:
    &lt;1000 blocks&gt;
    CHECKSEQUENCEVERIFY
    DROP
    &lt;Hitesh's Public Key&gt; CHECKSIG</pre></div>

<p>Irene has a different commitment transaction with two outputs. The first
output pays Hitesh the 5 bitcoins he is owed immediately. The second
output pays Irene the 5 bitcoins she is owed but only after a timelock of
1,000 blocks. The commitment transaction Irene holds (signed by Hitesh)
looks like this:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">Input: 2-of-2 funding output, signed by Hitesh

Output 0 &lt;5 bitcoins&gt;:
    &lt;Hitesh's Public Key&gt; CHECKSIG

Output 1 &lt;5 bitcoins&gt;:
    &lt;1000 blocks&gt;
    CHECKSEQUENCEVERIFY
    DROP
    &lt;Irene's Public Key&gt; CHECKSIG</pre></div>

<p>This way, each party has a commitment transaction, spending the 2-of-2
funding output. This input is signed by the <em>other</em> party. At any time
the party holding the transaction can also sign (completing the 2-of-2)
and broadcast. However, if they broadcast the commitment transaction, it
pays the other party immediately, whereas they have to wait for a
timelock to expire. By imposing a delay on the redemption of one of the
outputs, we put each party at a slight disadvantage when they choose to
unilaterally broadcast a commitment transaction. But a time delay alone
isn’t enough to encourage fair conduct.</p>

<p><a data-type="xref" href="#asymmetric_commitments" target="_blank" rel="noopener noreferrer">Figure&nbsp;14-5</a> shows two asymmetric commitment transactions,
where the output paying the holder of the commitment is delayed.</p>

<figure><div id="asymmetric_commitments">
<p><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098150082/files/assets/mbc3_1405.png" alt="" width="600" height="440"></p><h6><span>Figure 14-5. </span>Two asymmetric commitment transactions with delayed payment for the party holding the transaction.</h6>
</div></figure>

<p>Now we introduce the final element of this scheme: a revocation key that
prevents a cheater from broadcasting an expired commitment. The
revocation key allows the wronged party to punish the cheater by taking
the entire balance of the channel.</p>

<p>The revocation key is composed of two secrets, each half generated
independently by each channel participant. It is similar to a 2-of-2
multisig, but constructed using elliptic curve arithmetic, so that both
parties know the revocation public key but each party knows only half
the revocation secret key.</p>

<p>In each round, both parties reveal their half of the revocation secret
to the other party, thereby giving the other party (who now has both
halves) the means to claim the penalty output if this revoked
transaction is ever broadcast.</p>

<p>Each of the commitment transactions has a “delayed” output. The
redemption script for that output allows one party to redeem it after
1,000 blocks, <em>or</em> the other party to redeem it if they have a revocation
key, penalizing transmission of a revoked commitment.</p>

<p>So when Hitesh creates a commitment transaction for Irene to sign, he
makes the second output payable to himself after 1,000 blocks or to the
revocation public key (of which he only knows half the secret). Hitesh
constructs this transaction. He will only reveal his half of the
revocation secret to Irene when he is ready to move to a new channel
state and wants to revoke this commitment.</p>

<p>The second output’s script looks like this:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">Output 0 &lt;5 bitcoins&gt;:
    &lt;Irene's Public Key&gt; CHECKSIG

Output 1 &lt;5 bitcoins&gt;:
IF
    # Revocation penalty output
    &lt;Revocation Public Key&gt;
ELSE
    &lt;1000 blocks&gt;
    CHECKSEQUENCEVERIFY
    DROP
    &lt;Hitesh's Public Key&gt;
ENDIF
CHECKSIG</pre></div>

<p>Irene can confidently sign this transaction since if transmitted, it
will immediately pay her what she is owed. Hitesh holds the transaction
but knows that if he transmits it in a unilateral channel closing, he
will have to wait 1,000 blocks to get paid.</p>

<p>After the channel is advanced to the next state, Hitesh has to <em>revoke</em>
this commitment transaction before Irene will agree to sign any further
commitment transactions. To do that, all he has to do is send his half of
the <em>revocation key</em> to Irene. Once Irene has both halves of the
revocation secret key for this commitment, she can sign a future
commitment with confidence. She knows that if Hitesh tries to cheat by
publishing the prior commitment, she can use the revocation key to
redeem Hitesh’s delayed output. <em>If Hitesh cheats, Irene gets BOTH
outputs</em>. Meanwhile, Hitesh only has half the revocation secret for that
revocation public key and can’t redeem the output until 1,000 blocks.
Irene will be able to redeem the output and punish Hitesh before the
1,000 blocks have elapsed.</p>

<p>The revocation protocol is bilateral, meaning that in each round, as the
channel state is advanced, the two parties exchange new commitments,
exchange revocation secrets for the previous commitments, and sign each
other’s new commitment transactions. After they accept a new state, they
make the prior state impossible to use by giving each other the
necessary revocation secrets to punish any cheating.</p>

<p>Let’s look at an example of how it works. One of Irene’s customers wants
to send 2 bitcoins to one of Hitesh’s customers. To transmit 2 bitcoins
across the channel, Hitesh and Irene must advance the channel state to
reflect the new balance. They will commit to a new state (state number
2) where the channel’s 10 bitcoins are split, 7 bitcoins to Hitesh and 3
bitcoins to Irene. To advance the state of the channel, they will each
create new commitment transactions reflecting the new channel balance.</p>

<p>As before, these commitment transactions are asymmetric so the
commitment transaction each party holds forces them to wait if they
redeem it. Crucially, before signing new commitment transactions, they
must first exchange revocation keys to invalidate any outdated commitments.
In this particular case, Hitesh’s interests are aligned with the real
state of the channel and therefore he has no reason to broadcast a prior
state. However, for Irene, state number 1 leaves her with a higher
balance than state 2. When Irene gives Hitesh the revocation key for her
prior commitment transaction (state number 1), she is effectively
revoking her ability to profit from regressing the channel to a prior
state because with the revocation key, Hitesh can redeem both outputs of
the prior commitment transaction without delay. Meaning if Irene
broadcasts the prior state, Hitesh can exercise his right to take all of
the outputs.</p>

<p>Importantly, the revocation doesn’t happen automatically. While Hitesh
has the ability to punish Irene for cheating, he has to watch the
blockchain diligently for signs of cheating. If he sees a prior
commitment transaction broadcast, he has 1,000 blocks to take action and
use the revocation key to thwart Irene’s cheating and punish her by
taking the entire balance, all 10 bitcoins.</p>

<p>Asymmetric revocable commitments with relative time locks (<code>CSV</code>) are a
much better way to implement payment channels and a very significant
innovation in this technology.  With this construct, the channel can
remain open indefinitely and can have billions of intermediate
commitment transactions. In implementations of LN, the commitment state is identified by a 48-bit index, allowing
more than 281 trillion (2.8 × 10<sup>14</sup>) state transitions in <a data-type="indexterm" data-primary="payment channels" data-secondary="asymmetric revocable commitments" data-startref="payment-channel-revoke" id="id1403" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="asymmetric revocable commitments" data-startref="asymmetric-revoke-commit" id="id1404" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="commitment transactions" data-secondary="asymmetric revocable commitments" data-startref="commit-revoke" id="id1405" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="revocable commitments" data-startref="revoke-commit" id="id1406" target="_blank" rel="noopener noreferrer"></a>any single
channel.</p>
</div>








<div id="id229" data-type="sect2" data-pdf-bookmark="Hash Time Lock Contracts (HTLC)">
<h2>Hash Time Lock Contracts (HTLC)</h2>

<p>Payment channels <a data-type="indexterm" data-primary="payment channels" data-secondary="HTLC (Hash Time Lock Contract)" id="payment-channel-htlc" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="HTLC (Hash Time Lock Contract)" id="htlc" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="Hash Time Lock Contract (HTLC)" id="hash-time-lock-contract" target="_blank" rel="noopener noreferrer"></a>can be further
extended with a special type of smart contract that allows the
participants to commit funds to a redeemable secret, with an expiration
time. This feature is called a <em>hash time lock contract</em>, or <em>HTLC</em>, and
is used in both bidirectional and routed payment channels.</p>

<p>Let’s first explain the “hash” part of the HTLC. To create an HTLC, the
intended recipient of the payment will first create a secret <em>R</em>. They
then calculate the hash of this secret <em>H</em>:</p>


<p>This produces a hash <em>H</em> that can be included in an output’s
script. Whoever knows the secret can use it to redeem the output. The
secret <em>R</em> is also referred to as a <em>preimage</em> to the hash function. The
preimage is just the data that is used as input to a hash function.</p>

<p>The second part of an HTLC is the “time lock” component. If the secret
is not revealed, the payer of the HTLC can get a “refund” after some
time. This is achieved with an absolute timelock using
<code>CHECKLOCKTIMEVERIFY</code>.</p>

<p>The script implementing an HTLC might look like this:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">IF
    # Payment if you have the secret R
    HASH160 &lt;H&gt; EQUALVERIFY
    &lt;Receiver Public Key&gt; CHECKSIG
ELSE
    # Refund after timeout.
    &lt;lock time&gt; CHECKLOCKTIMEVERIFY DROP
    &lt;Payer Public Key&gt; CHECKSIG
ENDIF</pre></div>

<p>Anyone who knows the secret <em>R</em>, which when hashed equals to <em>H</em>, can
redeem this output by exercising the first clause of the <code>IF</code> flow.</p>

<p>If the secret is not revealed and the HTLC claimed after a certain
number of blocks, the payer can claim a refund using the second clause in
the <code>IF</code> flow.</p>

<p>This is a basic implementation of an HTLC. This type of HTLC can be
redeemed by <em>anyone</em> who has the secret <em>R</em>. An HTLC can take many
different forms with slight variations to the script. For example,
adding a <code>CHECKSIG</code> operator and a public key in the first clause
restricts redemption of the hash to a particular recipient, who must also
know the<a data-type="indexterm" data-primary="Bitcoin" data-secondary="as application platform" data-tertiary="payment channels" data-secondary-sortas="application platform" data-startref="bitcoin-app-platform-payment" id="id1407" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="application platform, Bitcoin as" data-secondary="payment channels" data-startref="app-platform-payment" id="id1408" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="payment channels" data-startref="payment-channel" id="id1409" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="payment channels" data-secondary="HTLC (Hash Time Lock Contract)" data-startref="payment-channel-htlc" id="id1410" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="HTLC (Hash Time Lock Contract)" data-startref="htlc" id="id1411" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="Hash Time Lock Contract (HTLC)" data-startref="hash-time-lock-contract" id="id1412" target="_blank" rel="noopener noreferrer"></a> secret <em>R</em>.</p>
</div>
</div>






<div id="lightning_network" data-type="sect1" data-pdf-bookmark="Routed Payment Channels (Lightning Network)">
<h2>Routed Payment Channels (Lightning Network)</h2>

<p>The<a data-type="indexterm" data-primary="LN" data-see="Lightning Network" id="id1413" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="Bitcoin" data-secondary="as application platform" data-tertiary="routed payment channels (Lightning Network)" data-secondary-sortas="application platform" id="bitcoin-app-platform-ln" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="application platform, Bitcoin as" data-secondary="routed payment channels (Lightning Network)" id="app-platform-ln" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="payment channels" data-secondary="Lightning Network" id="payment-channel-ln" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="Lightning Network (LN)" id="lightning" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="routed payment channels" data-see="Lightning Network" id="id1414" target="_blank" rel="noopener noreferrer"></a> Lightning Network (LN) is a proposed routed network of
bidirectional payment channels connected end-to-end. A network like this
can allow any participant to route a payment from channel to channel
without trusting any of the intermediaries. The LN was
<a href="https://oreil.ly/NM8LC" target="_blank" rel="noopener noreferrer">first described by
Joseph Poon and Thadeus Dryja in February 2015</a>, building on the concept
of payment channels as proposed and elaborated upon by many others.</p>

<p>“Lightning Network” refers to a specific design for a routed payment
channel network, which has now been implemented by at least five
different open source teams. The independent implementations are coordinated by a set of
interoperability standards described in the
<a href="https://oreil.ly/lIGIA" target="_blank" rel="noopener noreferrer"><em>Basics of Lightning Technology (BOLT)</em> repository</a>.</p>








<div id="id284" data-type="sect2" data-pdf-bookmark="Basic Lightning Network Example">
<h2>Basic Lightning Network Example</h2>

<p>Let’s <a data-type="indexterm" data-primary="payment channels" data-secondary="Lightning Network" data-tertiary="example of" id="payment-channel-ln-example" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="Lightning Network (LN)" data-secondary="example of" id="lightning-example" target="_blank" rel="noopener noreferrer"></a>see how this works.</p>

<p>In this example, we have five participants: Alice, Bob, Carol, Diana,
and Eric. These five participants have opened payment channels with each
other, in pairs. Alice has a payment channel with Bob. Bob is connected
to Carol, Carol to Diana, and Diana to Eric. For simplicity let’s assume
each channel is funded with 2 bitcoins by each participant, for a total
capacity of 4 bitcoins in each channel.</p>

<p><a data-type="xref" href="#lightning_network_fig" target="_blank" rel="noopener noreferrer">Figure&nbsp;14-6</a> shows five participants in an LN, connected by bidirectional payment channels that can be linked
to make a payment from Alice to Eric (see <a data-type="xref" href="#lightning_network" target="_blank" rel="noopener noreferrer">“Routed Payment Channels (Lightning Network)”</a>).</p>

<figure><div id="lightning_network_fig">
<p><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098150082/files/assets/mbc3_1406.png" alt="" width="600" height="570"></p><h6><span>Figure 14-6. </span>A series of bidirectional payment channels linked to form an LN that can route a payment from Alice to Eric.</h6>
</div></figure>

<p>Alice wants to pay Eric 1 bitcoin. However, Alice is not connected to
Eric by a payment channel. Creating a payment channel requires a funding
transaction, which must be committed to the Bitcoin blockchain. Alice
does not want to open a new payment channel and commit more of her
funds. Is there a way to pay Eric indirectly?</p>

<p><a data-type="xref" href="#ln_payment_process" target="_blank" rel="noopener noreferrer">Figure&nbsp;14-7</a> shows the step-by-step process of routing a
payment from Alice to Eric, through a series of HTLC commitments on the
payment channels connecting the participants.</p>

<figure><div id="ln_payment_process">
<p><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098150082/files/assets/mbc3_1407.png" alt="" width="600" height="589"></p><h6><span>Figure 14-7. </span>Step-by-step payment routing through an LN.</h6>
</div></figure>

<p>Alice is running an LN node that is keeping track of
her payment channel to Bob and has the ability to discover routes
between payment channels. Alice’s LN node also has the ability to
connect over the internet to Eric’s LN node. Eric’s LN node creates a
secret <code>R</code> using a random number generator. Eric’s node does not reveal
this secret to anyone. Instead, Eric’s node calculates a hash <code>H</code> of the
secret <code>R</code> and transmits this hash to Alice’s node in the form of an
invoice (see <a data-type="xref" href="#ln_payment_process" target="_blank" rel="noopener noreferrer">Figure&nbsp;14-7</a>, 
<span>step 1).</span></p>

<p>Now Alice’s LN node constructs a route between Alice’s LN node and
Eric’s LN node. The pathfinding algorithm used will be examined in more
detail later, but for now let’s assume that Alice’s node can find an
efficient route.</p>

<p>Alice’s node then constructs an HTLC, payable to the hash <code>H</code>, with a
10-block refund timeout (current block + 10), for an amount of 1.003
bitcoins (see <a data-type="xref" href="#ln_payment_process" target="_blank" rel="noopener noreferrer">Figure&nbsp;14-7</a>, step 2). The extra 0.003 will be
used to compensate the intermediate nodes for their participation in
this payment route. Alice offers this HTLC to Bob, deducting 1.003
bitcoins from her channel balance with Bob and committing it to the HTLC.
The HTLC has the following meaning: <em>“Alice is committing 1.003 bitcoins of her
channel balance to be paid to Bob if Bob knows the secret, or refunded
back to Alice’s balance if 10 blocks elapse.”</em> The channel balance
between Alice and Bob is now expressed by commitment transactions with
three outputs: 2 bitcoins balance to Bob, 0.997 bitcoins balance to Alice,
1.003 bitcoins committed in Alice’s HTLC. Alice’s balance is reduced by
the amount committed to the HTLC.</p>

<p>Bob now has a commitment that if he is able to get the secret <code>R</code> within
the next 10 blocks, he can claim the 1.003 bitcoins locked by Alice. With this
commitment in hand, Bob’s node constructs an HTLC on his payment channel
with Carol. Bob’s HTLC commits 1.002 bitcoins to hash <code>H</code> for 9 blocks,
which Carol can redeem if she has secret <code>R</code> (see <a data-type="xref" href="#ln_payment_process" target="_blank" rel="noopener noreferrer">Figure&nbsp;14-7</a>
step 3). Bob knows that if Carol can claim his HTLC, she has to produce
<code>R</code>. If Bob has <code>R</code> in nine blocks, he can use it to claim Alice’s HTLC
to him. He also makes 0.001 bitcoins for committing his channel balance
for nine blocks. If Carol is unable to claim his HTLC and he is unable
to claim Alice’s HTLC, everything reverts back to the prior channel
balances and no one is at a loss. The channel balance between Bob and
Carol is now: 2 to Carol, 0.998 to Bob, 1.002 committed by Bob to the
HTLC.</p>

<p>Carol now has a commitment that if she gets <code>R</code> within the next nine
blocks, she can claim 1.002 bitcoins locked by Bob. Now she can make an
HTLC commitment on her channel with Diana. She commits an HTLC of 1.001
bitcoins to hash <code>H</code>, for eight blocks, which Diana can redeem if she has
secret <code>R</code> (see <a data-type="xref" href="#ln_payment_process" target="_blank" rel="noopener noreferrer">Figure&nbsp;14-7</a>, step 4). From Carol’s
perspective, if this works she is 0.001 bitcoins better off and if it
doesn’t she loses nothing. Her HTLC to Diana is only viable if <code>R</code> is
revealed, at which point she can claim the HTLC from Bob. The channel
balance between Carol and Diana is now: 2 to Diana, 0.999 to Carol,
1.001 committed by Carol to the HTLC.</p>

<p>Finally, Diana can offer an HTLC to Eric, committing 1 bitcoin for seven
blocks to hash <code>H</code> (see <a data-type="xref" href="#ln_payment_process" target="_blank" rel="noopener noreferrer">Figure&nbsp;14-7</a>, step 5). The channel
balance between Diana and Eric is now: 2 to Eric, 1 to Diana, 1
committed by Diana to the HTLC.</p>

<p>However, at this hop in the route, Eric <em>has</em> secret <code>R</code>. He can
therefore claim the HTLC offered by Diana. He sends <code>R</code> to Diana and
claims the 1 bitcoin, adding it to his channel balance (see
<a data-type="xref" href="#ln_payment_process" target="_blank" rel="noopener noreferrer">Figure&nbsp;14-7</a>, step 6). The channel balance is now: 1 to Diana,
3 to Eric.</p>

<p>Now, Diana has secret <code>R</code>. Therefore, she can now claim the HTLC from
Carol. Diana transmits <code>R</code> to Carol and adds the 1.001 bitcoins to her
channel balance (see <a data-type="xref" href="#ln_payment_process" target="_blank" rel="noopener noreferrer">Figure&nbsp;14-7</a>, step 7). Now the channel
balance between Carol and Diana is: 0.999 to Carol, 3.001 to Diana.
Diana has “earned” 0.001 for participating in this payment route.</p>

<p>Flowing back through the route, the secret <code>R</code> allows each participant
to claim the outstanding HTLCs. Carol claims 1.002 from Bob, setting the
balance on their channel to: 0.998 to Bob, 3.002 to Carol (see
<a data-type="xref" href="#ln_payment_process" target="_blank" rel="noopener noreferrer">Figure&nbsp;14-7</a>, step 8). Finally, Bob claims the HTLC from Alice
(see <a data-type="xref" href="#ln_payment_process" target="_blank" rel="noopener noreferrer">Figure&nbsp;14-7</a>, step 9). Their channel balance is updated
as: 0.997 to Alice, 3.003 to Bob.</p>

<p>Alice has paid Eric 1 bitcoin without opening a channel to Eric. None of
the intermediate parties in the payment route had to trust each other.
For the short-term commitment of their funds in the channel they are
able to earn a small fee, with the only risk being a small delay in
refund if the channel was closed or the routed payment<a data-type="indexterm" data-primary="payment channels" data-secondary="Lightning Network" data-tertiary="example of" data-startref="payment-channel-ln-example" id="id1415" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="Lightning Network (LN)" data-secondary="example of" data-startref="lightning-example" id="id1416" target="_blank" rel="noopener noreferrer"></a> failed.</p>
</div>








<div id="id231" data-type="sect2" data-pdf-bookmark="Lightning Network Transport and Pathfinding">
<h2>Lightning Network Transport and Pathfinding</h2>

<p>All <a data-type="indexterm" data-primary="payment channels" data-secondary="Lightning Network" data-tertiary="pathfinding" id="payment-channel-ln-path" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="Lightning Network (LN)" data-secondary="pathfinding" id="lightning-path" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="pathfinding in Lightning Network" id="path-lightning" target="_blank" rel="noopener noreferrer"></a>communications
between LN nodes are encrypted point-to-point. In addition, nodes have a
long-term public key that they use as an
identifier and to authenticate each other.</p>

<p>Whenever a node wishes to send a payment to another node, it must first
construct a <em>path</em> through the network by connecting payment channels
with sufficient capacity. Nodes advertise routing information, including
what channels they have open, how much capacity each channel has, and
what fees they charge to route payments. The routing information can be
shared in a variety of ways, and different pathfinding protocols have
emerged as LN technology has advanced.
Current implementations of
route discovery use a P2P model where nodes propagate channel
announcements to their peers in a “flooding” model, similar to how
Bitcoin propagates transactions.</p>
<p>
In our previous example, Alice’s node uses one of these route discovery
mechanisms to find one or more paths connecting her node to Eric’s node.
Once Alice’s node has constructed a path, she will initialize that path
through the network by propagating a series of encrypted and nested
instructions to connect each of the adjacent payment channels.
</p>

<p>
Importantly, this path is only known to Alice’s node. All other
participants in the payment route see only the adjacent nodes. From
Carol’s perspective, this looks like a payment from Bob to Diana. Carol
does not know that Bob is actually relaying a payment from Alice. She
also doesn’t know that Diana will be relaying a payment to Eric.</p>

<p>This is a critical feature of the LN because it ensures
privacy of payments and makes it difficult to apply surveillance,
censorship, or blacklists. But how does Alice establish this payment
path without revealing anything to the intermediary nodes?</p>

<p>The LN implements an onion-routed protocol based on a
scheme called <a href="https://oreil.ly/fuCiK" target="_blank" rel="noopener noreferrer">Sphinx</a>. This routing protocol
ensures that a payment sender can construct and communicate a path
through the LN such that:</p>
<ul>
<li> Intermediate nodes can verify and decrypt their portion of route
  information and find the next hop.</li>

<li> Other than the previous and next hops, they cannot learn about any
  other nodes that are part of the path.</li>

<li>They cannot identify the length of the payment path or their own
  position in that path.</li>

<li>Each part of the path is encrypted in such a way that a network-level
  attacker cannot associate the packets from different parts of the path
  to each other.</li>

<li><p>Unlike Tor (an onion-routed anonymization protocol on the internet),
  there are no “exit nodes” that can be placed under surveillance. The
  payments do not need to be transmitted to the Bitcoin blockchain; the
  nodes just update channel balances.</p>
  </li>
  </ul>

<p>Using this onion-routed protocol, Alice wraps each element of the path
in a layer of encryption, starting with the end and working backward.
She encrypts a message to Eric with Eric’s public key. This message is
wrapped in a message encrypted to Diana, identifying Eric as the next
recipient. The message to Diana is wrapped in a message encrypted to
Carol’s public key and identifying Diana as the next recipient. The
message to Carol is encrypted to Bob’s key. Thus, Alice has constructed
this encrypted multilayer “onion” of messages. She sends this to Bob,
who can only decrypt and unwrap the outer layer. Inside, Bob finds a
message addressed to Carol that he can forward to Carol but cannot
decipher himself. Following the path, the messages get forwarded,
decrypted, forwarded, etc., all the way to Eric. Each participant knows
only the previous and next node in each hop.</p>

<p>Each element of the path contains information on the HTLC that must be
extended to the next hop, the amount that is being sent, the fee to
include, and the CLTV lock time (in blocks) expiration of the HTLC. As
the route information propagates, the nodes make HTLC commitments
forward to the next hop.</p>

<p>At this point, you might be wondering how it is possible that the nodes
do not know the length of the path and their position in that path.
After all, they receive a message and forward it to the next hop.
Doesn’t it get shorter, allowing them to deduce the path size and their
position? To prevent this, the packet size is fixed and
padded with random data. Each node sees the next hop and a fixed-length
encrypted message to forward. Only the final recipient sees that there
is no next hop. To everyone else it seems as if there are always <a data-type="indexterm" data-primary="payment channels" data-secondary="Lightning Network" data-tertiary="pathfinding" data-startref="payment-channel-ln-path" id="id1417" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="Lightning Network (LN)" data-secondary="pathfinding" data-startref="lightning-path" id="id1418" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="pathfinding in Lightning Network" data-startref="path-lightning" id="id1419" target="_blank" rel="noopener noreferrer"></a>more
hops to go.</p>
</div>








<div id="id232" data-type="sect2" data-pdf-bookmark="Lightning Network Benefits">
<h2>Lightning Network Benefits</h2>

<p>An<a data-type="indexterm" data-primary="payment channels" data-secondary="Lightning Network" data-tertiary="benefits of" id="payment-channel-ln-benefits" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="Lightning Network (LN)" data-secondary="benefits of" id="lightning-benefits" target="_blank" rel="noopener noreferrer"></a> LN is a
second-layer routing technology. It can be applied to any blockchain
that supports some basic capabilities, such as multisignature
transactions, timelocks, and basic smart contracts.</p>

<p>LN is layered on top of the Bitcoin network, giving
Bitcoin a significant increase in capacity, privacy,
granularity, and speed, without sacrificing the principles of trustless
operation without intermediaries:</p>
<dl>
<dt>Privacy</dt>
<dd>
<p>LN payments are much more private than payments
on the Bitcoin blockchain, as they are not public. While participants in
a route can see payments propagated across their channels, they do not
know the sender or recipient.</p>
</dd>
<dt>Fungibility</dt>
<dd>
<p>An LN makes it much more difficult to apply
surveillance and blacklists on Bitcoin, increasing the fungibility of
the currency.</p>
</dd>
<dt>Speed</dt>
<dd>
<p>Bitcoin transactions using LN are settled in
milliseconds, rather than minutes or hours, as HTLCs are cleared without
committing transactions to a block.</p>
</dd>
<dt>Granularity</dt>
<dd>
<p>An LN can enable payments at least as small
as the Bitcoin “dust” limit, perhaps even smaller.</p>
</dd>
<dt>Capacity</dt>
<dd>
<p>An LN increases the capacity of the Bitcoin
system by several orders of magnitude. The upper bound
to the number of payments per second that can be routed over a Lightning
Network depends only on the capacity and speed of each node.</p>
</dd>
<dt>Trustless Operation</dt>
<dd>
<p>An LN uses Bitcoin transactions
between nodes that operate as peers without trusting each other. Thus, an LN preserves the principles of the Bitcoin system, while
expanding its operating parameters <a data-type="indexterm" data-primary="Bitcoin" data-secondary="as application platform" data-tertiary="routed payment channels (Lightning Network)" data-secondary-sortas="application platform" data-startref="bitcoin-app-platform-ln" id="id1420" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="application platform, Bitcoin as" data-secondary="routed payment channels (Lightning Network)" data-startref="app-platform-ln" id="id1421" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="payment channels" data-secondary="Lightning Network" data-startref="payment-channel-ln" id="id1422" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="Lightning Network (LN)" data-startref="lightning" id="id1423" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="payment channels" data-secondary="Lightning Network" data-tertiary="benefits of" data-startref="payment-channel-ln-benefits" id="id1424" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="Lightning Network (LN)" data-secondary="benefits of" data-startref="lightning-benefits" id="id1425" target="_blank" rel="noopener noreferrer"></a>significantly.</p>
</dd>
</dl>

<p>We have examined just a few of the emerging applications that can be
built using the Bitcoin blockchain as a trust platform. These
applications expand the scope of Bitcoin beyond payments.</p>

<p>Now that you have reached the end of this book, what will you do with
the knowledge you have gained?  Millions of people, perhaps billions,
know the name “Bitcoin,” but only a small percentage of them know as
much about how Bitcoin works as you now do.  That knowledge is precious.
Even more precious are the people, such as yourself, who are so
interested in Bitcoin that you are willing to read several hundred pages
about it.</p>

<p>If you haven’t already begun doing so, please consider contributing to
Bitcoin in some way.  You can run a full node to validate the Bitcoin
payments you receive, build applications that make it easier for other
people to use Bitcoin, or help educate other people about Bitcoin and
its potential.  You can even take the rare step of contributing to open
source Bitcoin infrastructure software, such as Bitcoin Core, carefully
working with a small number of incredibly smart people to build tools
that no one will ever pay for but that billions may one day depend upon.</p>

<p>Whatever your Bitcoin journey, we thank you for making <em>Mastering
Bitcoin</em> a part 
<span>of it.</span></p>
</div>
</div>
</div></div>
  <span></span> <!-- for IntersectionObserver -->
  
  
  
  


<style id="note-styling">
    .note {
      position: absolute;
      z-index: 10;
      border: none;
      outline: none;
      font-family: inherit;
      font-size: inherit;
      padding: 5px;
      min-width: 32px;
      min-height: 32px;
    }
    .note:focus {
      z-index: 11;
    }
    .note[type="0"] {
      background-color: #fff740;
      color: #2c2c2d;
    }
    .note[type="0"]::placeholder {
      color: #868226;
    }
    .note[type="1"] {
      background-color: #feff9c;
      color: #2c2c2d;
    }
    .note[type="1"]::placeholder {
      color: #6d6d3d;
    }
    .note[type="2"] {
      background-color: #ff65a3;
      color: #2c2c2d;
    }
    .note[type="2"]::placeholder {
      color: #65263f;
    }
    .note[type="3"] {
      background-color: #ff7eb9;
      color: #2c2c2d;
    }
    .note[type="3"]::placeholder {
      color: #562b3f;
    }
    .note[type="4"] {
      background-color: #7afcff;
      color: #295c5d;
    }
    .note[type="4"]::placeholder {
      color: #377677;
    }</style></body><style>body {
      font-size:  19px;
      font-family: Georgia, 'Times New Roman', serif;
      width: 600px;
    }
    p {
      text-align: justify
    }
    .page {
      line-height: 28.5px;
      column-count: unset;
    }
    h1, h2, h3 {
      line-height: initial;
    }</style></html>