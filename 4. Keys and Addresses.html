<!DOCTYPE html>
<html><head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <base target="_blank">
  <style>
/* latin */
@font-face {
  font-family: 'Comic Neue';
  font-style: normal;
  font-weight: 400;
  src: url(fonts/4UaHrEJDsxBrF37olUeD96rp57F2IwM.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
/* latin */
@font-face {
  font-family: 'Lexend Deca';
  font-style: normal;
  font-weight: 400;
  src: url(fonts/K2FifZFYk-dHSE0UPPuwQ7CrD94i-NCKm-U48M1wqxnDirZPl3v-.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
/* latin */
@font-face {
  font-family: 'Poppins';
  font-style: normal;
  font-weight: 400;
  src: url(fonts/pxiEyp8kv8JHgFVrJJfecnFHGPc.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

:root {
  --fg: #000; /* foreground  */
  --bg: #fff; /* background  */
  --bd: #000; /* border  */
  --lk: #006fa5; /* link */
  --lkv: #d33bf0; /* link visited */
  --hg: #ffff81; /* highlight  */
}
html {
  overflow: overlay;
}
body {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  margin: 30px auto 0 auto;
  padding: 10px;
  position: relative;

  color: var(--fg);
  border-color: var(--bd);
  background-color: var(--bg);
}
body[data-mode$="dark"] {
  --lk: #0096de;
}
body[data-mode="light"] {
  color-scheme: light;
  --fg: #222;
  --bd: #222;
  --bg: whitesmoke;
}
body[data-mode="dark"] {
  color-scheme: dark;
  --fg: #eee;
  --bd: #eee;
  --bg: #333;
}
body[data-mode="sepia"] {
  color-scheme: light;
  --fg: #5b4636;
  --bd: #5b4636;
  --bg: #f4ecd8;
}
body[data-mode="solarized-light"] {
  color-scheme: light;
  --fg: #586e75;
  --bd: #586e75;
  --bg: #fdf6e3;
}
body[data-mode="nord-light"] {
  color-scheme: light;
  --fg: #2e3440;
  --bd: #2e3440;
  --bg: #e5e9f0;
}
body[data-mode="groove-dark"] {
  color-scheme: dark;
  --fg: #cec4ac;
  --bd: #cec4ac;
  --bg: #282828;
}
body[data-mode="solarized-dark"] {
  color-scheme: dark;
  --fg: #839496;
  --bd: #839496;
  --bg: #002b36;
}
body[data-mode="nord-dark"] {
  color-scheme: dark;
  --fg: #e5e9f0;
  --bd: #e5e9f0;
  --bg: #2e3440;
}

@media print {
  body[data-mode] {
    --fg: #000;
    --bd: #000;
    --bg: #fff;

    width: unset;
    padding: 0;
    margin: 0;
  }
}
body[data-loaded=true] {
  
}
img {
  max-width: 100%;
  height: auto;
}
img:not([width])[src$=".svg"] {
  max-width: 100px;
}
body[data-images=false] canvas,
body[data-images=false] svg,
body[data-images=false] img {
  display: none;
}
svg:not([width]):not([height]) {
  max-width: 25vmin;
}
a {
  color: var(--lk);
  text-decoration: none;
}
a:visited {
  color: var(--lkv);
}

hr {
  background-color: var(--bd);
  height: 1px;
  border: 0;
}
#reader-domain {
  font-family: Helvetica, Arial, sans-serif;
  text-decoration: none;
  border-bottom-color: currentcolor;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  width: 100%;
  display: inline-block;
  direction: ltr;
}
#reader-domain > span:first-child {
  font-size: 1.1em;
}
#reader-domain > span:last-child {
  font-size: 0.8em;
}
#reader-title {
  font-size: 1.6em;
  line-height: 1.25em;
  width: 100%;
  margin: 20px 0;
  padding: 0;
}
#reader-credits,
#doi,
#published-time,
#reader-estimated-time {
  font-size: 0.85em;
  line-height: 1.48em;
  margin: 0 0 10px 0;
  padding: 0;
}
#reader-credits:not(:empty)::after {
  content: ' ⋮ ';
}
#published-time:not(:empty)::before {
  content: ' ⋮ ';
}
#doi-json {
  overflow: hidden;
}
#doi-json code {
  overflow: auto;
  max-height: 400px;
}
#published-time:empty,
#reader-credits:empty {
  display: none;
}
mark.hghlght {
  background-color: var(--hg);
}
body:not([data-columns="1"]) .page :is(h1, h2) {
  column-span: all;
  background-color: rgba(125, 125, 125, 0.1);
  padding: 10px;
}
.hidden {
  display: none;
}
</style>
  <style id="user-css">body {
  padding-bottom: 64px;
}
pre {
  white-space: pre-wrap;
}
pre code {
  background-color: #eff0f1;
  color: #393318;
  font-family: monospace;
  display: block;
  padding: 5px 10px;
}
body[data-mode="dark"] pre code {
  background-color: #585858;
  color: #e8e8e8;
}

/* CSS for sans-serif fonts */
body[data-font=sans-serif] {}
/* CSS for serif fonts */
body[data-font=serif] {}

/* CSS for "sepia" theme */
body[data-mode=sepia] {}
/* CSS for "light" theme */
body[data-mode=light] {}
/* CSS for "dark" theme */
body[data-mode=dark] {}</style>
<title>4. Keys and Addresses</title><title>4. Keys and Addresses :: Reader View</title></head>
<body tabindex="1" data-images="true" data-mode="groove-dark" data-font="serif" data-columns="1" data-loaded="true">
  <span></span> <!-- for IntersectionObserver -->
  <a id="reader-domain" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch04.html">
    <span>learning.oreilly.com</span>
    <span>/library/view/mastering-bitcoin-3rd/9781098150082/ch04.html</span>
  </a>
  <h1 dir="auto" id="reader-title">4. Keys and Addresses</h1>
  <span dir="auto" id="reader-credits"></span>
  <span dir="auto" id="reader-estimated-time">60-76 minutes</span>
  <span dir="auto" id="published-time"></span>
  <hr>
  <div id="readability-page-1" class="page"><div id="sbo-rt-content" data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 4. Keys and Addresses">
<h2><span>Chapter 4. </span>Keys and Addresses</h2>


<p>Alice wants to pay Bob, but the thousands of Bitcoin full nodes who
will verify her transaction don’t know who Alice or Bob are—​and we want
to keep it that way to protect their privacy.  Alice needs to
communicate that Bob should receive some of her bitcoins without tying
any aspect of that transaction to Bob’s real-world identity or to other
Bitcoin payments that Bob receives.  The method Alice uses must ensure
that only Bob can further spend the bitcoins he receives.</p>

<p>The original Bitcoin paper describes a very simple scheme for achieving
those goals, shown in <a data-type="xref" href="#pay-to-pure-pubkey" target="_blank" rel="noopener noreferrer">Figure&nbsp;4-1</a>.</p>

<figure><div id="pay-to-pure-pubkey">
<p><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098150082/files/assets/mbc3_aain01.png" alt="" width="545" height="321"></p><h6><span>Figure 4-1. </span>Transaction chain from original Bitcoin paper.</h6>
</div></figure>

<p>A receiver like Bob
accepts bitcoins to a public key in a transaction that is signed by the
spender (like Alice).  The bitcoins that Alice is spending had been
previously received to one of her public keys, and she uses the
corresponding private key to generate her signature.  Full nodes can
verify that Alice’s signature commits to the output of a hash function
that itself commits to Bob’s public key and other transaction details.</p>

<p>We’ll examine public keys, private keys, signatures, and hash functions
in this chapter, and then use all of them together to describe
the addresses used by modern Bitcoin software.</p>






<div id="id45" data-type="sect1" data-pdf-bookmark="Public Key Cryptography">
<h2>Public Key Cryptography</h2>

<p>Public <a data-type="indexterm" data-primary="public key cryptography" id="pub-key" target="_blank" rel="noopener noreferrer"></a>key
cryptography was invented in the 1970s and is a mathematical foundation
for modern computer and information security.</p>

<p>Since the invention of public key cryptography, several suitable
mathematical functions, such as prime number exponentiation and elliptic
curve multiplication, have been discovered. These mathematical functions
are easy to calculate in
one direction and infeasible to calculate in the opposite direction
using the computers and algorithms available today.
Based on these mathematical functions, cryptography enables the creation
of unforgeable digital signatures. Bitcoin uses
elliptic curve addition and multiplication as the basis for its cryptography.</p>

<p>In Bitcoin, we can use public key cryptography to create a <a data-type="indexterm" data-primary="key pairs" id="key-pair" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="public keys" data-secondary="purpose of" id="id620" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="private keys" data-secondary="purpose of" id="id621" target="_blank" rel="noopener noreferrer"></a>key pair that
controls access to bitcoins. The key pair consists of a private key
and a public key derived from the private key. The public key is used to
receive funds, and the private key is used to sign transactions to spend
the funds.</p>

<p>There is a mathematical relationship between the public and the private
key that allows the private key to be used to generate signatures on
messages. These signatures can be validated against the public key without
revealing the private key.</p>
<div data-type="tip"><h6>Tip</h6>
<p>In some wallet
implementations, the private and public keys are stored together as a
<em>key pair</em> for convenience. However, the public key can be calculated
from the private key, so storing only the private key is also possible.</p>
</div>

<p>A Bitcoin wallet contains a collection of key
pairs, each consisting of a private key and a public key. The private
key (<em>k</em>) is a number, usually derived from a number picked at random.
From the private key, we
use elliptic curve multiplication, a one-way cryptographic function, to
generate a public key (<em>K</em>).</p>









<div id="private_keys" data-type="sect2" data-pdf-bookmark="Private Keys">
<h2>Private Keys</h2>

<p>A
private <a data-type="indexterm" data-primary="private keys" data-secondary="generating" id="private-key-generate" target="_blank" rel="noopener noreferrer"></a>key is simply a number, picked at random.  Control
over the private key is the root of user control over all funds
associated with the corresponding Bitcoin public key. The private key is
used to create signatures that are used to spend bitcoins by proving
control of funds used in a transaction. The private key must remain
secret at all times because revealing it to third parties is equivalent
to giving them control over the bitcoins secured by that key. The private
key must also be backed up and protected from accidental loss because
if it’s lost, it cannot be recovered and the funds secured by it are
forever lost too.</p>
<div data-type="tip"><h6>Tip</h6>
<p>A Bitcoin private key is just a number. You can pick your private keys
randomly using just a coin, pencil, and paper: toss a coin 256 times and
you have the binary digits of a random private key you can use in a
Bitcoin wallet. The public key can then be generated from the private
key.  Be careful, though, as any process that’s less than completely
random can significantly reduce the security of your private key and the
bitcoins it controls.</p>
</div>

<p>The first and most important step in generating keys is to find a secure
source of randomness (which computer scientists <a data-type="indexterm" data-primary="entropy" id="id626" target="_blank" rel="noopener noreferrer"></a>call <em>entropy</em>). Creating a Bitcoin key is almost
the same as “Pick a number between 1 and 2<sup>256</sup>.” The exact method you
use to pick that number does not matter as long as it is not predictable
or repeatable. Bitcoin software uses cryptographically secure random
number generators to produce 256 bits of entropy.</p>

<p>More precisely, the private key can be any number between 0 and <em>n</em> -
1 inclusive, where <em>n</em> is a constant (<em>n</em> = 1.1578 × 10<sup>77</sup>, slightly less
than 2<sup>256</sup>) defined as the order of the elliptic curve used in Bitcoin
(see <a data-type="xref" href="#elliptic_curve" target="_blank" rel="noopener noreferrer">“Elliptic Curve Cryptography Explained”</a>). To create such a key, we randomly pick a
256-bit number and check that it is less than <em>n</em>. In programming terms,
this is usually achieved by feeding a larger string of random bits,
collected from a cryptographically secure source of randomness, into the
SHA256 hash algorithm, which will conveniently produce a 256-bit value
that can be interpreted as a number.
If the result is less than <em>n</em>, we have a suitable private key.
Otherwise, we simply try again with another random number.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Do not write your own code to create a random
number or use a “simple” random number generator offered by your
programming language. Use a cryptographically secure pseudorandom number
generator (CSPRNG) with a seed from a source of sufficient entropy.
Study the documentation of the random number generator library you
choose to make sure it is cryptographically secure. Correct
implementation of the CSPRNG is critical to the security of the keys.</p>
</div>

<p>The following is a randomly generated private key (<em>k</em>) shown in
hexadecimal format (256 bits shown as 64 hexadecimal digits, each 4
bits):</p>

<div data-testid="custom pre block"><pre data-type="programlisting">1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD</pre></div>
<div data-type="tip"><h6>Tip</h6>
<p>The size of Bitcoin’s private key space (2<sup>256</sup>) is an unfathomably
large number. It is approximately 10<sup>77</sup> in decimal. For comparison, the
visible universe is estimated to<a data-type="indexterm" data-primary="private keys" data-secondary="generating" data-startref="private-key-generate" id="id627" target="_blank" rel="noopener noreferrer"></a> contain 10<sup>80</sup> atoms.</p>
</div>
</div>








<div id="elliptic_curve" data-type="sect2" data-pdf-bookmark="Elliptic Curve Cryptography Explained">
<h2>Elliptic Curve Cryptography Explained</h2>

<p>Elliptic curve cryptography (ECC) is<a data-type="indexterm" data-primary="public key cryptography" data-secondary="elliptic curve cryptography as" id="pub-key-ecc" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="elliptic curve cryptography (ECC)" id="ecc" target="_blank" rel="noopener noreferrer"></a> a type of asymmetric
or public key cryptography based on the discrete logarithm problem as
expressed by addition and multiplication on the points of an elliptic
curve.</p>

<p><a data-type="xref" href="#ecc-curve" target="_blank" rel="noopener noreferrer">Figure&nbsp;4-2</a> is an example of an elliptic curve, similar to that used
by Bitcoin.</p>

<figure><div id="ecc-curve">
<p><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098150082/files/assets/mbc3_0402.png" alt="" width="600" height="602"></p><h6><span>Figure 4-2. </span>An elliptic curve.</h6>
</div></figure>

<p>Bitcoin uses a specific elliptic curve and set of mathematical
constants, as defined in a standard called <code>secp256k1</code>, established by
the National Institute of Standards and Technology (NIST). The
<code>secp256k1</code> curve is defined by the following function, which produces
an elliptic curve:</p>


<p>or</p>


<p>The <em>mod p</em> (modulo prime number <em>p</em>) indicates that this curve is over a
finite field of prime order <em>p</em>, also written as , where <em>p</em> = 2<sup>256</sup> – 2<sup>32</sup> – 2<sup>9</sup> – 2<sup>8</sup> – 2<sup>7</sup> – 2<sup>6</sup> –
2<sup>4</sup> – 1, a very large prime number.</p>

<p>Because this curve is defined over a finite field of prime order instead
of over the real numbers, it looks like a pattern of dots scattered in
two dimensions, which makes it difficult to visualize. However, the math
is identical to that of an elliptic curve over real numbers. As an
example, <a data-type="xref" href="#ecc-over-F17-math" target="_blank" rel="noopener noreferrer">Figure&nbsp;4-3</a> shows the same elliptic curve over a much
smaller finite field of prime order 17, showing a pattern of dots on a
grid. The <code>secp256k1</code> Bitcoin elliptic curve can be thought of as a much
more complex pattern of dots on a unfathomably large grid.</p>

<figure><div id="ecc-over-F17-math">
<p><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098150082/files/assets/mbc3_0403.png" alt="" width="600" height="614"></p><h6><span>Figure 4-3. </span>Elliptic curve cryptography: visualizing an elliptic curve over F(p), with p=17.</h6>
</div></figure>

<p>So, for example, the following is a point P with coordinates (x, y) that
is a point on the <code>secp256k1</code> curve:</p>

<div data-testid="custom pre block"><pre data-type="programlisting" data-code-language="python"><code>P</code> <code>=</code>
<code>(</code><code>55066263022277343669578718895168534326250603453777594175500187360389116729240</code><code>,</code>
<code>32670510020758816978083085130507043184471273380659243275938904335757337482424</code><code>)</code></pre></div>

<p><a data-type="xref" href="#example_4_1" target="_blank" rel="noopener noreferrer">Example&nbsp;4-1</a> shows how you can check this yourself using Python.</p>
<div id="example_4_1" data-type="example">
<h5><span>Example 4-1. </span>Using Python to confirm that this point is on the elliptic curve</h5>

<div data-testid="custom pre block"><pre data-type="programlisting" data-code-language="pycon"><code>Python 3.10.6 (main, Nov 14 2022, 16:10:14) [GCC 11.3.0] on linux</code>
<code>Type "help", "copyright", "credits" or "license" for more information.</code>
<code>&gt; p = 115792089237316195423570985008687907853269984665640564039457584007908834671663</code>
<code>&gt; x = 55066263022277343669578718895168534326250603453777594175500187360389116729240</code>
<code>&gt; y = 32670510020758816978083085130507043184471273380659243275938904335757337482424</code>
<code>&gt; (x ** 3 + 7 - y**2) % p</code>
<code>0</code></pre></div></div>

<p>In elliptic curve math, there is a point called the “point at infinity,”
which roughly corresponds to the role of zero in addition. On computers,
it’s sometimes represented by x = y = 0 (which doesn’t satisfy the
elliptic curve equation, but it’s an easy separate case that can be
checked).</p>

<p>There is also a + operator, called “addition,” which has some
properties similar to the traditional addition of real numbers that
gradeschool children learn. Given two points P<sub>1</sub> and P<sub>2</sub> on the
elliptic curve, there is a third point P<sub>3</sub> = P<sub>1</sub> + P<sub>2</sub>, also on the
elliptic curve.</p>

<p>Geometrically, this third point P<sub>3</sub> is calculated by drawing a line
between P<sub>1</sub> and P<sub>2</sub>. This line will intersect the elliptic curve in
exactly one additional place. Call this point P<sub>3</sub>' = (x, y). Then
reflect in the x-axis to get P<sub>3</sub> = (x, –y).</p>

<p>There are a couple of special cases that explain the need for the “point
at infinity.”</p>

<p>If P<sub>1</sub> and P<sub>2</sub> are the same point, the line “between” P<sub>1</sub> and P<sub>2</sub>
should extend to be the tangent on the curve at this point P<sub>1</sub>. This
tangent will intersect the curve in exactly one new point. You can use
techniques from calculus to determine the slope of the tangent line.
These techniques curiously work, even though we are restricting our
interest to points on the curve with two integer coordinates!</p>

<p>In some cases (i.e., if P<sub>1</sub> and P<sub>2</sub> have the same x values but
different y values), the tangent line will be exactly vertical, in which
case P<sub>3</sub> = “point at infinity.”</p>

<p>If P<sub>1</sub> is the “point at infinity,” then P<sub>1</sub> + P<sub>2</sub> = P<sub>2</sub>. Similarly,
if P<sub>2</sub> is the point at infinity, then P<sub>1</sub> + P<sub>2</sub> = P<sub>1</sub>. This shows
how the point at infinity plays the role of zero.</p>

<p>It turns out that + is associative, which means that (A +
B) + C = A + (B + C). That means we can write A
+ B + C without parentheses and without ambiguity.</p>

<p>Now that we have defined addition, we can define multiplication in the
standard way that extends addition. For a point P on the elliptic curve,
if k is a whole number, then kP = P + P + P + …​ + P (k times). Note
that k is sometimes confusingly called an “exponent” in <a data-type="indexterm" data-primary="public key cryptography" data-secondary="elliptic curve cryptography as" data-startref="pub-key-ecc" id="id628" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="elliptic curve cryptography (ECC)" data-startref="ecc" id="id629" target="_blank" rel="noopener noreferrer"></a>this case.</p>
</div>








<div id="public_key_derivation" data-type="sect2" data-pdf-bookmark="Public Keys">
<h2>Public Keys</h2>

<p>The <a data-type="indexterm" data-primary="public keys" data-secondary="generating" id="public-key-generate" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="elliptic curve multiplication" id="elliptic-multiply" target="_blank" rel="noopener noreferrer"></a>public key is calculated from
the private key using elliptic curve multiplication, which is
irreversible: <em>K</em> = <em>k</em> × <em>G</em>, where <em>k</em> is the private key, <em>G</em> is a
constant point called the <em>generator point</em>, and <em>K</em> is the resulting
public key. The reverse operation, known as “finding the discrete
logarithm”—calculating <em>k</em> if you know <em>K</em>—is as difficult as trying
all possible values of <em>k</em> (i.e., a brute-force search). Before we
demonstrate how to generate a public key from a private key, let’s look
at elliptic curve cryptography in a bit more detail.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Elliptic curve multiplication is a type of function that cryptographers
call a “trap door” function: it is easy to do in one direction
(multiplication) and impossible to do in the reverse direction
(division). Someone with a private key can easily create the public
key and then share it with the world knowing that no one can reverse the
function and calculate the private key from the public key. This
mathematical trick becomes the basis for unforgeable and secure digital
signatures that prove control over bitcoin funds.</p>
</div>

<p>Starting with a private key in the
form of a randomly generated number <em>k</em>, we multiply it by a
predetermined point on the curve called the <em>generator point</em> <em>G</em> to
produce another point somewhere else on the curve, which is the
corresponding public key <em>K</em>. The generator point is specified as part
of the <code>secp256k1</code> standard and is always the same for all keys in
bitcoin:</p>


<p>where <em>k</em> is the private key, <em>G</em> is the generator point, and <em>K</em> is the
resulting public key, a point on the curve. Because the generator point
is always the same for all Bitcoin users, a private key <em>k</em> multiplied
with <em>G</em> will always result in the same public key <em>K</em>. The relationship
between <em>k</em> and <em>K</em> is fixed but can only be calculated in one
direction, from <em>k</em> to <em>K</em>. That’s why a Bitcoin public key (<em>K</em>) can be
shared with anyone and does not reveal the user’s private key (<em>k</em>).</p>
<div data-type="tip"><h6>Tip</h6>
<p>A private key can be converted into a public key, but a public key
cannot be converted back into a private key because the math only works
one way.</p>
</div>

<p>Implementing the elliptic curve multiplication, we take the private key
<em>k</em> generated previously and multiply it with the generator point <em>G</em> to
find the public key <em>K</em>:</p>

<div data-testid="custom pre block"><pre data-type="programlisting" data-code-language="python"><code>K</code> <code>=</code> <code>1E99423</code><code>A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD</code> <code>×</code> <code>G</code></pre></div>

<p>Public key <em>K</em> is defined as a point <em>K</em> = (<em>x</em>, <em>y</em>):</p>


<p>where,</p>

<div data-testid="custom pre block"><pre data-type="programlisting">x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB</pre></div>

<p>To visualize multiplication of a point with an integer, we will use the
simpler elliptic curve over real numbers—remember, the math is
the same. Our goal is to find the multiple <em>kG</em> of the generator point
<em>G</em>, which is the same as adding <em>G</em> to itself, <em>k</em> times in a row. In
elliptic curves, adding a point to itself is the equivalent of drawing a
tangent line on the point and finding where it intersects the curve
again, then reflecting that point on the x-axis.</p>

<p><a data-type="xref" href="#ecc_illustrated" target="_blank" rel="noopener noreferrer">Figure&nbsp;4-4</a> shows the process for deriving <em>G</em>, <em>2G</em>, <em>4G</em>, as a
geometric operation on the curve.</p>


<figure><div id="ecc_illustrated">
<p><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098150082/files/assets/mbc3_0404.png" alt="" width="600" height="601"></p><h6><span>Figure 4-4. </span>Elliptic curve cryptography: visualizing the multiplication of a point G by an integer k on an elliptic curve.</h6>
</div></figure>
</div>
</div>






<div id="id49" data-type="sect1" data-pdf-bookmark="Output and Input Scripts">
<h2>Output and Input Scripts</h2>

<p>Although<a data-type="indexterm" data-primary="public key cryptography" data-secondary="input/output scripts" id="pub-key-input-output" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="input scripts" id="input-script" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="output scripts" id="output-script" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="scripts" data-secondary="input/output" id="script-input-output" target="_blank" rel="noopener noreferrer"></a> the illustration from the original Bitcoin paper, <a data-type="xref" href="#pay-to-pure-pubkey" target="_blank" rel="noopener noreferrer">Figure&nbsp;4-1</a>,
shows public keys (pubkeys) and signatures (sigs) being used directly,
the first version of Bitcoin instead had payments sent to a field called
<em>output script</em> and had spends of those bitcoins authorized by a field called <em>input script</em>.
These fields allow additional operations to be performed in addition to
(or instead of) verifying that a signature corresponds to a public key.
For example, an output script can contain two public keys and require two
corresponding signatures be placed in the spending input script.</p>

<p>Later, in <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch07.html#tx_script" target="_blank" rel="noopener noreferrer">“Transaction Scripts and Script Language”</a>, we’ll learn about scripts in detail.  For now,
all we need to understand is that bitcoins are received to an
output script that acts like a public key, and bitcoin spending is
authorized by an input script that acts like a <a data-type="indexterm" data-primary="public key cryptography" data-secondary="input/output scripts" data-startref="pub-key-input-output" id="id632" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="input scripts" data-startref="input-script" id="id633" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="output scripts" data-startref="output-script" id="id634" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="scripts" data-secondary="input/output" data-startref="script-input-output" id="id635" target="_blank" rel="noopener noreferrer"></a>signature.</p>
</div>






<div id="p2pk" data-type="sect1" data-pdf-bookmark="IP Addresses: The Original Address for Bitcoin (P2PK)">
<h2>IP Addresses: The Original Address for Bitcoin (P2PK)</h2>

<p>We’ve <a data-type="indexterm" data-primary="public key cryptography" data-secondary="IP address payments and" id="pub-key-ipaddress" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="IP addresses for Bitcoin payments" id="ipaddress-payment" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="payments" data-secondary="via IP addresses" id="payment-ipaddress" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="P2PK (pay to public key)" id="p2pk-ch4" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="addresses" data-secondary="P2PK (pay to public key)" id="address-p2pk-ch4" target="_blank" rel="noopener noreferrer"></a>established that Alice can pay Bob by assigning some of her
bitcoins to one of Bob’s public keys.  But how does Alice get one of
Bob’s public keys?  Bob could just give her a copy, but let’s look again
at the public key we worked with in <a data-type="xref" href="#public_key_derivation" target="_blank" rel="noopener noreferrer">“Public Keys”</a>.  Notice
that it’s quite long.  Imagine Bob trying to read that to Alice over the
phone:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB</pre></div>

<p>Instead of direct public key entry, the earliest version of Bitcoin
software allowed a spender to enter the receiver’s IP address, as shown in <a data-type="xref" href="#bitcoin_01_send" target="_blank" rel="noopener noreferrer">Figure&nbsp;4-5</a>.  This
feature was later removed—​there are many problems
with using IP addresses—​but a quick description of it will help us
better understand why certain features may have been added to the
Bitcoin protocol.</p>

<figure></figure>

<p>If Alice entered Bob’s IP address in Bitcoin 0.1, her full node would
establish a connection with his full node and receive a new public key
from Bob’s wallet that his node had never previously given anyone.  This
being a new public key was important to ensure that different
transactions paying Bob couldn’t be connected together by someone
looking at the blockchain and noticing that all of the transactions paid
the same public key.</p>

<p>Using the public key her node received from Bob’s node, Alice’s wallet
would construct a transaction output paying a very simple output script:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">&lt;Bob's public key&gt; OP_CHECKSIG</pre></div>

<p>Bob would later be able to spend that output with an input script consisting
entirely of his signature:</p>



<p>To figure out what an output and input script are doing, you can
combine them together (input script first) and then note that each piece of
data (shown in angle brackets) is placed at the top of a list of items,
called a stack.  When an operation code (opcode) is encountered, it uses
items from the stack, starting with the topmost items.  Let’s look at
how that works by beginning with the combined script:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">&lt;Bob's signature&gt; &lt;Bob's public key&gt; OP_CHECKSIG</pre></div>

<p>For this script, Bob’s signature is put on the stack, then Bob’s public
key is placed on top of it.  The <code>OP_CHECKSIG</code> operation consumes two
elements, starting with the public key and followed by the signature,
removing them from the stack.  It verifies the signature corresponds to
the public key and also commits to (signs) the various fields in the
transaction.  If the signature is correct, <code>OP_CHECKSIG</code> replaces itself
on the stack with the value 1; if the signature was not correct, it
replaces itself with a 0.  If there’s a nonzero item on top of the stack at the
end of evaluation, the script passes.  If all scripts in a transaction
pass, and all of the other details about the transaction are valid, then
full nodes will consider the transaction to be valid.</p>

<p>In short, the preceding script uses the same public key and signature
described in the original paper but adds in the complexity of two script
fields and an opcode.  That seems like extra work here, but we’ll begin
to see the benefits when we look at the following section.</p>

<p>This type of output is known today as <em>pay to public key</em>, or <em>P2PK</em> for
short.  It was never widely used for payments, and no widely used
program has supported IP address payments for almost<a data-type="indexterm" data-primary="public key cryptography" data-secondary="IP address payments and" data-startref="pub-key-ipaddress" id="id636" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="IP addresses for Bitcoin payments" data-startref="ipaddress-payment" id="id637" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="payments" data-secondary="via IP addresses" data-startref="payment-ipaddress" id="id638" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="P2PK (pay to public key)" data-startref="p2pk-ch4" id="id639" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="addresses" data-secondary="P2PK (pay to public key)" data-startref="address-p2pk-ch4" id="id640" target="_blank" rel="noopener noreferrer"></a> a decade.</p>
</div>






<div id="addresses_for_p2pkh" data-type="sect1" data-pdf-bookmark="Legacy Addresses for P2PKH">
<h2>Legacy Addresses for P2PKH</h2>

<p>Entering <a data-type="indexterm" data-primary="public key cryptography" data-secondary="hash functions and" id="pub-key-hash" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="hash functions" data-secondary="Bitcoin payments and" id="hash-payment" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="payments" data-secondary="with hash functions" data-secondary-sortas="hash functions" id="payment-hash" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="P2PKH (pay to public key hash)" id="p2pkh-legacy" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="addresses" data-secondary="P2PKH (pay to public key hash)" id="address-p2pkh-legacy" target="_blank" rel="noopener noreferrer"></a>the IP address of the person you want to pay has a number of
advantages, but it also has a number of downsides.  One particular
downside is that the receiver needs their wallet to be online at their
IP address, and it needs to be accessible from the outside world.  For
a lot of people, that isn’t an option.  They turn their computers off at
night, their laptops go to sleep, they’re behind firewalls, or they’re
using Network Address Translation (NAT).</p>

<p>This brings us back to the problem of receivers like Bob having to give
spenders like Alice a long public key.  The shortest version of Bitcoin
public keys known to the developers of early Bitcoin were 65 bytes, the
equivalent of 130 characters when written in hexadecimal.  However, Bitcoin
already contains several data structures much larger than 65 bytes
that need to be securely referenced in other parts of Bitcoin using the
smallest amount of data that was secure.</p>

<p>Bitcoin accomplishes that with a <em>hash function</em>, a function that takes
a potentially large amount of data, scrambles it (hashes it), and outputs a
fixed amount of data.  A cryptographic hash function will always produce
the same output when given the same input, and a secure function will
also make it impractical for somebody to choose a different input that
produces a previously-seen output.  That makes the <a data-type="indexterm" data-primary="commitments" id="commitment" target="_blank" rel="noopener noreferrer"></a>output a <em>commitment</em>
to the input.  It’s a promise that, in practice, only input <em>x</em> will
produce output <em>X</em>.</p>

<p>For example, imagine I want to ask you a question and also give you my
answer in a form that you can’t read immediately.  Let’s say the
question is, “in what year did Satoshi Nakamoto start working on
Bitcoin?”  I’ll give you a commitment to my answer in the form of
output from the<a data-type="indexterm" data-primary="SHA256 hash function" id="id641" target="_blank" rel="noopener noreferrer"></a> SHA256 hash function, the function most commonly used in
Bitcoin:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">94d7a772612c8f2f2ec609d41f5bd3d04a5aa1dfe3582f04af517d396a302e4e</pre></div>

<p>Later, after you tell me your guess to the answer of the question, I can
reveal my answer and prove to you that my answer, as input to the hash
function, produces exactly the same output I gave you earlier:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">$ echo "2007.  He said about a year and a half before Oct 2008" | sha256sum
94d7a772612c8f2f2ec609d41f5bd3d04a5aa1dfe3582f04af517d396a302e4e</pre></div>

<p>Now imagine that we ask Bob the question, “what is your public key?” Bob
can use a hash function to give us a cryptographically secure commitment
to his public key.  If he later reveals his key, and we verify it
produces the same commitment he previously gave us, we can be sure it
was the exact same key that was used to create that earlier commitment.</p>

<p>The SHA256 hash function is considered to be very secure and produces
256 bits (32 bytes) of output, less than half the size of original
Bitcoin public keys.  However, there are other slightly less secure hash
functions that produce smaller output, such as the <a data-type="indexterm" data-primary="RIPEMD-160 hash function" id="id642" target="_blank" rel="noopener noreferrer"></a>RIPEMD-160 hash
function whose output is 160 bits (20 bytes).  For reasons Satoshi
Nakamoto never stated, the original version of Bitcoin made commitments
to public keys by first hashing the key with SHA256 and then hashing
that output with RIPEMD-160; this produced a 20-byte commitment to the
public key.</p>

<p>We can look at that algorithmically.
Starting with the public key <em>K</em>, we compute the SHA256 hash and then
compute the RIPEMD-160 hash of the result, producing a 160-bit (20-byte)
number:</p>


<p>where <em>K</em> is the public key and <em>A</em> is the resulting commitment.</p>

<p>Now that we understand how to make a commitment to a public key, we need
to figure out how to use it in a transaction.  Consider the following
output script:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">OP_DUP OP_HASH160 &lt;Bob's commitment&gt; OP_EQUAL OP_CHECKSIG</pre></div>

<p>And also the following input script:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">&lt;Bob's signature&gt; &lt;Bob's public key&gt;</pre></div>

<p>Together, they form the following script:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">&lt;sig&gt; &lt;pubkey&gt; OP_DUP OP_HASH160 &lt;commitment&gt; OP_EQUALVERIFY OP_CHECKSIG</pre></div>

<p>As we did in <a data-type="xref" href="#p2pk" target="_blank" rel="noopener noreferrer">“IP Addresses: The Original Address for Bitcoin (P2PK)”</a>, we start putting items on the stack.  Bob’s
signature goes on first; his public key is then placed on top of the
stack.  The <code>OP_DUP</code> operation duplicates the top item, so the top and
second-to-top item on the stack are now both Bob’s public key.  The
<code>OP_HASH160</code> operation consumes (removes) the top public key and
replaces it with the result of hashing it with <code>RIPEMD160(SHA256(K))</code>,
so now the top of the stack is a hash of Bob’s public key.  Next, the
commitment to Bob’s public key is added to the top of the stack.  The
<code>OP_EQUALVERIFY</code> operation consumes the top two items and verifies that
they are equal; that should be the case if the public key Bob provided
in the input script is the same public key used to create the commitment in
the output script that Alice paid.  If <code>OP_EQUALVERIFY</code> fails, the whole
script fails.  Finally, we’re left with a stack containing just Bob’s
signature and his public key; the <code>OP_CHECKSIG</code> opcode verifies they
correspond with each other and that the signature commits to the
transaction.</p>

<p>Although this process of paying to a public key hash (<em>P2PKH</em>) may seem
convoluted, it allows Alice’s payment to
Bob to contain only a 20 byte commitment to his public key instead of
the key itself, which would’ve been 65 bytes in the original version of
Bitcoin.  That’s a lot less data for Bob to have to communicate to
Alice.</p>

<p>However, we haven’t yet discussed how Bob gets those 20 bytes from his
Bitcoin wallet to Alice’s wallet.  There are commonly used encodings for
byte values, such as hexadecimal, but any mistake made in copying a
commitment would result in the bitcoins being sent to an unspendable
output, causing them to be lost forever.  In the next section, we’ll
look at compact encoding and reliable <a data-type="indexterm" data-primary="public key cryptography" data-secondary="hash functions and" data-startref="pub-key-hash" id="id643" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="hash functions" data-secondary="Bitcoin payments and" data-startref="hash-payment" id="id644" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="payments" data-secondary="with hash functions" data-secondary-sortas="hash functions" data-startref="payment-hash" id="id645" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="P2PKH (pay to public key hash)" data-startref="p2pkh-legacy" id="id646" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="addresses" data-secondary="P2PKH (pay to public key hash)" data-startref="address-p2pkh-legacy" id="id647" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="commitments" data-startref="commitment" id="id648" target="_blank" rel="noopener noreferrer"></a>checksums.</p>
</div>






<div id="base58" data-type="sect1" data-pdf-bookmark="Base58check Encoding">
<h2>Base58check Encoding</h2>

<p>In order<a data-type="indexterm" data-primary="public key cryptography" data-secondary="base58check encoding" id="pub-key-base58" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="base58check encoding" id="base58-ch4" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="encoding" data-secondary="base58check" id="encode-base58" target="_blank" rel="noopener noreferrer"></a> to represent long numbers in a compact way,
using fewer symbols, many computer systems use mixed-alphanumeric
representations with a base (or radix) higher than 10. For example,
whereas the traditional decimal system uses 10 numerals, 0 through 9,
the hexadecimal system uses 16, with the letters A through F as the six
additional symbols. A number represented in hexadecimal format is
shorter than the equivalent decimal representation. Even more compact,
base64 representation <a data-type="indexterm" data-primary="base64 encoding" id="id649" target="_blank" rel="noopener noreferrer"></a>uses 26 lowercase letters, 26 capital letters, 10
numerals, and 2 more characters such as “+” and “/” to
transmit binary data over text-based media such as email.</p>

<p>Base58 is a similar encoding to
base64, using upper- and lowercase letters and numbers,
but omitting some characters that are frequently mistaken for one
another and can appear identical when displayed in certain fonts.
Specifically, base58 is base64 without the 0 (number zero), O (capital
o), l (lower L), I (capital i), and the symbols “+” and
“/.” Or, more simply, it is a set of lowercase and capital letters and
numbers without the four (0, O, l, I) just mentioned. <a data-type="xref" href="#base58alphabet" target="_blank" rel="noopener noreferrer">Example&nbsp;4-2</a>
shows the full base58 alphabet.</p>
<div id="base58alphabet" data-type="example">
<h5><span>Example 4-2. </span>Bitcoin’s base58 alphabet</h5>

<div data-testid="custom pre block"><pre data-type="programlisting">123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz</pre></div></div>

<p>To add extra security against typos or transcription errors, base58check
includes<a data-type="indexterm" data-primary="checksums" id="id650" target="_blank" rel="noopener noreferrer"></a> a <em>checksum</em> encoded in the base58 alphabet. The checksum is an
additional four bytes
added to the end of the data that is being encoded. The checksum is
derived from the hash of the encoded data and can therefore be used to
detect transcription and typing errors. When presented with
base58check code, the decoding software will calculate the checksum of
the data and compare it to the checksum included in the code. If the two
do not match, an error has been introduced and the base58check data is
invalid. This prevents a mistyped Bitcoin address from being accepted by
the wallet software as a valid destination, an error that would
otherwise result in loss of funds.</p>

<p>To convert data (a number) into a base58check format, we first add a
prefix to the data, called <a data-type="indexterm" data-primary="version prefixes" id="version-prefix" target="_blank" rel="noopener noreferrer"></a>the “version byte,” which serves to easily
identify the type of data that is encoded. For example, the prefix zero
(0x00 in hex) indicates that the data should be used as the commitment (hash) in
a legacy P2PKH output script.  A list of common version prefixes is shown
in <a data-type="xref" href="#base58check_versions" target="_blank" rel="noopener noreferrer">Table&nbsp;4-1</a>.</p>

<p>Next, we compute the “double-SHA” checksum, meaning we apply the SHA256
hash-algorithm twice on the previous result (the prefix concatenated
with the data):</p>

<div data-testid="custom pre block"><pre data-type="programlisting">checksum = SHA256(SHA256(prefix||data))</pre></div>

<p>From the resulting 32-byte hash (hash-of-a-hash), we take only the first
four bytes. These four bytes serve as the error-checking code, or
checksum. The checksum is appended to the end.</p>

<p>The result is composed of three items: a prefix, the data, and a
checksum. This result is encoded using the base58 alphabet described
previously. <a data-type="xref" href="#base58check_encoding" target="_blank" rel="noopener noreferrer">Figure&nbsp;4-6</a> illustrates the base58check
encoding process.</p>

<figure><div id="base58check_encoding">
<p><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098150082/files/assets/mbc3_0406.png" alt="" width="600" height="494"></p><h6><span>Figure 4-6. </span>Base58check encoding: a base58, versioned, and checksummed format for unambiguously encoding bitcoin data.</h6>
</div></figure>
<p>
In Bitcoin, other data besides public key commitments are presented to the user in
base58check encoding to make that data compact, easy to read, and easy to detect
errors. The version prefix in base58check encoding is used to create
easily distinguishable formats, which when encoded in base58 contain
specific characters at the beginning of the base58check-encoded payload.
These characters make it easy for humans to identify the type of data
that is encoded and how to use it. This is what differentiates, for
example, a base58check-encoded Bitcoin address that starts with a 1 from
a base58check-encoded private key wallet import format (WIF) that starts with a 5. Some example
version prefixes and the resulting base58 characters are shown in
<a data-type="xref" href="#base58check_versions" target="_blank" rel="noopener noreferrer">Table&nbsp;4-1</a>.
</p>
<table id="base58check_versions"><caption><span>Table 4-1. </span>Base58check version prefix and encoded result examples</caption><thead><tr><th>Type</th><th>Version prefix (hex)</th><th>Base58 result prefix</th></tr></thead><tbody><tr><td><p>Address for pay to public key hash (P2PKH)</p></td><td><p>0x00</p></td><td><p>1</p></td></tr><tr><td><p>Address for pay to script hash (P2SH)</p></td><td><p>0x05</p></td><td><p>3</p></td></tr><tr><td><p>Testnet Address for P2PKH</p></td><td><p>0x6F</p></td><td><p>m or n</p></td></tr><tr><td><p>Testnet Address for P2SH</p></td><td><p>0xC4</p></td><td><p>2</p></td></tr><tr><td><p>Private Key WIF</p></td><td><p>0x80</p></td><td><p>5, K, or L</p></td></tr><tr><td><p>BIP32 Extended Public Key</p></td><td><p>0x0488B21E</p></td><td><p>xpub</p></td></tr></tbody></table>

<p>Combining public keys, hash-based commitments, and base58check
encoding, <a data-type="xref" href="#pubkey_to_address" target="_blank" rel="noopener noreferrer">Figure&nbsp;4-7</a> illustrates the conversion of a public key
into a Bitcoin <a data-type="indexterm" data-primary="public key cryptography" data-secondary="base58check encoding" data-startref="pub-key-base58" id="id651" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="base58check encoding" data-startref="base58-ch4" id="id652" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="encoding" data-secondary="base58check" data-startref="encode-base58" id="id653" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="version prefixes" data-startref="version-prefix" id="id654" target="_blank" rel="noopener noreferrer"></a>address.</p>

<figure><div id="pubkey_to_address">
<p><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098150082/files/assets/mbc3_0407.png" alt="" width="600" height="713"></p><h6><span>Figure 4-7. </span>Public key to Bitcoin address: conversion of a public key to a Bitcoin address.</h6>
</div></figure>
</div>






<div id="comp_pub" data-type="sect1" data-pdf-bookmark="Compressed Public Keys">
<h2>Compressed Public Keys</h2>

<p>When <a data-type="indexterm" data-primary="public key cryptography" data-secondary="compressed public keys" id="pub-key-compress" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="compressed public keys" id="compress-pub-key" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="uncompressed public keys" id="uncompress-pub-key" target="_blank" rel="noopener noreferrer"></a>Bitcoin was first authored, its developers only knew how to create
65-byte public keys.  However, a later developer became aware of an
alternative encoding for public keys that used only 33 bytes and which
was backward compatible with all Bitcoin full nodes at the time,
so there was no need to change the Bitcoin protocol.  Those 33-byte
public keys are known as <em>compressed public keys</em>, and the original 65-byte keys are known as <em>uncompressed public keys</em>.  Using smaller public keys
results in smaller transactions, allowing more payments to be made in the same
block.</p>

<p>As we saw in the section <a data-type="xref" href="#public_key_derivation" target="_blank" rel="noopener noreferrer">“Public Keys”</a>, a public key is a point 
<span>(x, y)</span> on an
elliptic curve. Because the curve expresses a mathematical function, a
point on the curve represents a solution to the equation and, therefore,
if we know the <em>x</em> coordinate, we can calculate the <em>y</em> coordinate by
solving the equation 
<span>y<sup>2</sup> mod p = (x<sup>3</sup> + 7) mod p.</span> That allows us to
store only the <em>x</em> coordinate of the public key point, omitting the <em>y</em>
coordinate and reducing the size of the key and the space required to
store it by 256 bits. An almost 50% reduction in size in every
transaction adds up to a lot of data saved over time!</p>

<p>Here is the public key generated by the private key we created in
<a data-type="xref" href="#public_key_derivation" target="_blank" rel="noopener noreferrer">“Public Keys”</a>:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB</pre></div>

<p>Here’s the same public key shown as a 520-bit number (130 hex digits)
with the prefix <code>04</code> followed by <code>x</code> and then <code>y</code> coordinates, as <code>04 x
y</code>:</p>
<div data-testid="custom pre block"><pre data-type="programlisting">K = 04F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A\
    07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB
</pre></div>

<p>Whereas uncompressed public keys have a prefix of <code>04</code>, compressed
public keys start with either a <code>02</code> or a <code>03</code> prefix. Let’s look at why
there are two possible prefixes: because the left side of the equation
is <em>y</em><sup>2</sup>, the solution for <em>y</em> is a square root, which can have a
positive or negative value. Visually, this means that the resulting <em>y</em>
coordinate can be above or below the x-axis. As you can see from the
graph of the elliptic curve in <a data-type="xref" href="#ecc-curve" target="_blank" rel="noopener noreferrer">Figure&nbsp;4-2</a>, the curve is symmetric,
meaning it is reflected like a mirror by the x-axis. So, while we can
omit the <em>y</em> coordinate, we have to store the <em>sign</em> of <em>y</em> (positive or
negative); in other words, we have to remember if it was above or
below the x-axis because each of those options represents a different
point and a different public key. When calculating the elliptic curve in
binary arithmetic on the finite field of prime order p, the <em>y</em>
coordinate is either even or odd, which corresponds to the
positive/negative sign as explained earlier. Therefore, to distinguish
between the two possible values of <em>y</em>, we store a compressed public key
with the prefix <code>02</code> if the <em>y</em> is even, and <code>03</code> if it is odd, allowing
the software to correctly deduce the <em>y</em> coordinate from the <em>x</em>
coordinate and uncompress the public key to the full coordinates of the
point. Public key compression is illustrated in <a data-type="xref" href="#pubkey_compression" target="_blank" rel="noopener noreferrer">Figure&nbsp;4-8</a>.</p>

<figure><div id="pubkey_compression">
<p><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098150082/files/assets/mbc3_0408.png" alt="" width="600" height="726"></p><h6><span>Figure 4-8. </span>Public key compression.</h6>
</div></figure>

<p>Here’s the same public key generated in <a data-type="xref" href="#public_key_derivation" target="_blank" rel="noopener noreferrer">“Public Keys”</a>, shown as a compressed
public key stored in 264 bits (66 hex digits) with the prefix <code>03</code>
indicating the <em>y</em> coordinate is odd:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">K = 03F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A</pre></div>

<p>This compressed public key corresponds to the same private key, meaning
it is generated from the same private key. However, it looks different
from the uncompressed public key. More importantly, if we convert this
compressed public key to a commitment using the HASH160
function (<code>RIPEMD160(SHA256(K))</code>), it will produce a <em>different</em>
commitment than the uncompressed public key, leading to a different
address. This can be confusing because it means that a single private
key can produce a public key expressed in two different formats
(compressed and uncompressed) that produce two different Bitcoin
addresses. However, the private key is identical for both Bitcoin
addresses.</p>

<p>Compressed public keys are now the default in almost all Bitcoin
software and were required when using certain new features added
in later protocol upgrades.</p>

<p>However, some software still needs to support uncompressed public keys,
such as a wallet application importing private keys from an older
wallet.  When the new wallet scans the blockchain for old P2PKH outputs
and inputs, it needs to know whether to scan the 65-byte keys (and
commitments to those keys) or 33-byte keys (and their commitments).  Failure
to scan for the correct type can lead to the user not being able to
spend their full balance.  To resolve this issue, when private keys are
exported from a wallet, the WIF that is used to
represent them is implemented slightly differently in newer Bitcoin
wallets to indicate that these private keys have been used to produce<a data-type="indexterm" data-primary="public key cryptography" data-secondary="compressed public keys" data-startref="pub-key-compress" id="id655" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="compressed public keys" data-startref="compress-pub-key" id="id656" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="uncompressed public keys" data-startref="uncompress-pub-key" id="id657" target="_blank" rel="noopener noreferrer"></a>
compressed public keys.</p>
</div>






<div id="addresses_for_p2sh" data-type="sect1" data-pdf-bookmark="Legacy Pay to Script Hash (P2SH)">
<h2>Legacy Pay to Script Hash (P2SH)</h2>

<p>As we’ve <a data-type="indexterm" data-primary="public key cryptography" data-secondary="hash functions and" id="pub-key-hash2" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="hash functions" data-secondary="Bitcoin payments and" id="hash-payment2" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="payments" data-secondary="with hash functions" data-secondary-sortas="hash functions" id="payment-hash2" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="P2SH (pay to script hash)" id="p2sh-ch4" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="addresses" data-secondary="P2SH (pay to script hash)" id="address-p2sh-ch4" target="_blank" rel="noopener noreferrer"></a>seen in preceding sections, someone receiving bitcoins (like
Bob) can require that payments to him contain certain constraints in their
output script.  Bob will need to fulfill those constraints using an
input script when he spends those bitcoins.  In <a data-type="xref" href="#p2pk" target="_blank" rel="noopener noreferrer">“IP Addresses: The Original Address for Bitcoin (P2PK)”</a>, the constraint
was simply that the input script needed to provide an appropriate
signature.  In <a data-type="xref" href="#addresses_for_p2pkh" target="_blank" rel="noopener noreferrer">“Legacy Addresses for P2PKH”</a>, an appropriate public key also needed to be
provided.</p>
<p>
For a spender (like Alice) to place the constraints Bob wants
in the output script she uses to pay him, Bob needs to communicate those
constraints to her.  This is similar to the problem of Bob needing to
communicate his public key to her.  Like that problem, where
public keys can be fairly large, the constraints Bob uses can also be
quite large—potentially thousands of bytes.  That’s not only thousands
of bytes that need to be communicated to Alice, but thousands of bytes
for which she needs to pay transaction fees every time she wants to spend money to Bob.  However, the solution of using hash functions to create
small commitments to large amounts of data also applies here.
</p>

<p>The BIP16 upgrade to the Bitcoin protocol in 2012 allows an
output script to <a data-type="indexterm" data-primary="redeem scripts" id="redeem-script" target="_blank" rel="noopener noreferrer"></a>commit to a <em>redemption script</em> (<em>redeem script</em>).  When
Bob spends his bitcoins, his input script needs to provide a redeem script
that matches the commitment and also any data necessary to satisfy the
redeem script (such as signatures).  Let’s start by imagining Bob wants
to require two signatures to spend his bitcoins, one signature from his
desktop wallet and one from a hardware signing device.  He puts those
conditions into a redeem script:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">&lt;public key 1&gt; OP_CHECKSIGVERIFY &lt;public key 2&gt; OP_CHECKSIG</pre></div>

<p>He then creates a commitment to the redeem script using the same
HASH160 mechanism used for P2PKH commitments, <code>RIPEMD160(SHA256(script))</code>.
That commitment is placed into the output script using a special
template:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">OP_HASH160 &lt;commitment&gt; OP_EQUAL</pre></div>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>When using pay to script hash (P2SH), you must use the specific P2SH template
with no extra data or conditions in the output script.  If the
output script is not exactly <code>OP_HASH160 &lt;20 bytes&gt; OP_EQUAL</code>, the
redeem script will not be used and any bitcoins may either be unspendable
or spendable by anyone (meaning anyone can take them).</p>
</div>

<p>When Bob goes to spend the payment he received to the commitment for his
script, he uses an input script that includes the redeem script, with it
serialized as a single data element.  He also provides the signatures
he needs to satisfy the redeem script, putting them in the order that
they will be consumed by the opcodes:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">&lt;signature2&gt; &lt;signature1&gt; &lt;redeem script&gt;</pre></div>

<p>When Bitcoin full nodes receive Bob’s spend, they’ll verify that the
serialized redeem script will hash to the same value as the commitment.
Then they’ll replace it on the stack with its deserialized value:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">&lt;signature2&gt; &lt;signature1&gt; &lt;pubkey1&gt; OP_CHECKSIGVERIFY &lt;pubkey2&gt; OP_CHECKSIG</pre></div>

<p>The script is executed and, if it passes and all of the other
transaction details are correct, the transaction is valid.</p>

<p>Addresses for P2SH are also created with
base58check.  The version prefix is set to 5, which results in an
encoded address starting with a <code>3</code>. An example of a P2SH address is
<code>3F6i6kwkevjR7AsAd4te2YB2zZyASEm1HM</code>.</p>
<div data-type="tip"><h6>Tip</h6>
<p>P2SH is not necessarily the same as a multisignature
transaction. A P2SH address <em>most often</em> represents a multisignature
script, but it might also represent a script encoding other types of
transactions.</p>
</div>

<p>P2PKH and P2SH are the only two script templates used with base58check
encoding.  They are now known as legacy addresses and have become less
common over time.
Legacy addresses were supplanted by the bech32 family of <a data-type="indexterm" data-primary="redeem scripts" data-startref="redeem-script" id="id658" target="_blank" rel="noopener noreferrer"></a>addresses.</p>

</div>






<div id="id55" data-type="sect1" data-pdf-bookmark="Bech32 Addresses">
<h2>Bech32 Addresses</h2>

<p>In 2017, the <a data-type="indexterm" data-primary="public key cryptography" data-secondary="bech32 addresses" data-tertiary="advantages of" id="pub-key-bech32-adv" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="addresses" data-secondary="bech32" data-tertiary="advantages of" id="address-bech32-adv" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="bech32 addresses" data-secondary="advantages of" id="bech32-adv" target="_blank" rel="noopener noreferrer"></a>Bitcoin protocol was upgraded.  When the upgrade is used,
it prevents transaction
identifiers (txids) from being changed without the consent of a spending
user (or a quorum of signers when multiple signatures are required).
The upgrade, <a data-type="indexterm" data-primary="segregated witness (segwit)" id="segwit-bech32" target="_blank" rel="noopener noreferrer"></a>called <em>segregated witness</em> (or <em>segwit</em> for short),  also
provided additional capacity for transaction data in blocks and several
other benefits.  However, users wanting direct access to segwit’s
benefits had to accept payments to new output scripts.</p>

<p>As mentioned in <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch07.html#p2sh" target="_blank" rel="noopener noreferrer">“Pay to Script Hash”</a>, one of the advantages of the P2SH output type
was that a spender (such as Alice) didn’t need to know the details of
the script the receiver (such as Bob) used.  The segwit upgrade was
designed to use this mechanism, allowing users to
immediately begin accessing many of the new benefits by using a P2SH
address.  But for Bob to gain access to all of the benefits, he would
need Alice’s wallet to pay him using a different type of script.  That
would require Alice’s wallet to upgrade to support the new scripts.</p>

<p>At first, Bitcoin developers proposed BIP142, which would continue using
base58check with a new version byte, similar to the P2SH upgrade.  But
getting all wallets to upgrade to new scripts with a new base58check
version was expected to require almost as much work as getting them to
upgrade to an entirely new address format, so several Bitcoin
contributors set out to design the best possible address format.  They
identified several problems<a data-type="indexterm" data-primary="public key cryptography" data-secondary="base58check encoding" id="id667" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="base58check encoding" id="id668" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="encoding" data-secondary="base58check" id="id669" target="_blank" rel="noopener noreferrer"></a> with base58check:</p>

<ul>
<li>
<p>Its mixed-case presentation made it inconvenient to read aloud or
transcribe.  Try reading one of the legacy addresses in this chapter
to a friend who you have transcribe it.  Notice how you have to prefix
every letter with the words “uppercase” and “lowercase.”  Also, note
when you review their writing that the uppercase and lowercase
versions of some letters can look similar in many people’s
handwriting.</p>
</li>
<li>
<p>It can detect errors, but it can’t help users correct those errors.
For example, if you accidentally transpose two characters when manually
entering an address, your wallet will almost certainly warn that a
mistake exists, but it won’t help you figure out where the error is
located.  It might take you several frustrating minutes to eventually
discover the mistake.</p>
</li>
<li>
<p>A mixed-case alphabet also requires extra space to encode in QR codes,
which are commonly used to share addresses and invoices
between wallets.  That extra space means QR codes need to be larger at
the same resolution or they become harder to scan quickly.</p>
</li>
</ul>

<ul>
<li>
<p>It requires every spender wallet upgrade to support new protocol
features like P2SH and segwit.  Although the upgrades themselves might
not require much code, experience shows that many wallet authors are
busy with other work and can sometimes delay upgrading for years.
This adversely affects everyone who wants to use the new features.</p>
</li>
</ul>

<p>The developers working on an address format for segwit found solutions
for each of these problems in a new address format called
bech32 (pronounced with a soft “ch”, as in “besh thirty-two”).  The
“bech” stands for BCH, the initials of the three individuals who
discovered the cyclic code in 1959 and 1960 upon which bech32 is based.
The “32” stands for the number of characters in the bech32 alphabet
(similar to the 58 in base58check):</p>

<ul>
<li>
<p>Bech32 uses only numbers and a single case of letters (preferably
rendered in lowercase).  Despite its alphabet being almost half the
size of the base58check alphabet, a bech32 address for a pay to witness public key hash (P2WPKH) script
is only slightly longer than a legacy address for an equivalent P2PKH
script.</p>
</li>
<li>
<p>Bech32 can both detect and help correct errors.  In an address of an
expected length, it is mathematically guaranteed to detect any error
affecting four characters or less; that’s more reliable than
base58check.  For longer errors, it will fail to detect them less than
one time in a billion, which is roughly the same reliability as
base58check.  Even better, for an address typed with just a few
errors, it can tell the user where those errors occurred, allowing them to
quickly correct minor transcription mistakes.  See <a data-type="xref" href="#bech32_typo_detection" target="_blank" rel="noopener noreferrer">Example&nbsp;4-3</a>
for an example of an address entered with errors.</p>
<div id="bech32_typo_detection" data-type="example">
<h5><span>Example 4-3. </span>Bech32 typo detection</h5>

<p>Address:
  bc1p9nh05ha8wrljf7ru236aw<u><strong>n</strong></u>4t2x0d5ctkkywm<u><strong>v</strong></u>9sclnm4t0av2vgs4k3au7</p>

<p>Detected errors shown in bold and underlined.  Generated using the
<a href="https://oreil.ly/paWIx" target="_blank" rel="noopener noreferrer">bech32 address decoder demo</a>.</p></div>
</li>
<li>
<p>Bech32 is preferably written with only lowercase characters, but those
lowercase characters can be replaced with uppercase characters before
encoding an address in a QR code.  This allows the use of a special QR
encoding mode that uses less space.  Notice the difference in size and
complexity of the two QR codes for the same address in
<a data-type="xref" href="#bech32_qrcode_uc_lc" target="_blank" rel="noopener noreferrer">Figure&nbsp;4-9</a>.</p>

<figure><div id="bech32_qrcode_uc_lc">
<p><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098150082/files/assets/mbc3_0409.png" alt="" width="319" height="244"></p><h6><span>Figure 4-9. </span>The same bech32 address QR encoded in lowercase and uppercase.</h6>
</div></figure>
</li>
<li>
<p>Bech32 takes advantage of an upgrade mechanism designed as part of
segwit to make it possible for spender wallets to be able to pay
output types that aren’t in use yet.  The goal was to allow developers
to build a wallet today that allows spending to a bech32 address
and have that wallet remain able to spend to bech32 addresses for
users of new features added in future protocol upgrades.  It was
hoped that we might never again need to go through the system-wide
upgrade cycles necessary to allow people to fully use P2SH and<a data-type="indexterm" data-primary="public key cryptography" data-secondary="bech32 addresses" data-tertiary="advantages of" data-startref="pub-key-bech32-adv" id="id670" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="addresses" data-secondary="bech32" data-tertiary="advantages of" data-startref="address-bech32-adv" id="id671" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="bech32 addresses" data-secondary="advantages of" data-startref="bech32-adv" id="id672" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="segregated witness (segwit)" data-startref="segwit-bech32" id="id673" target="_blank" rel="noopener noreferrer"></a> segwit.</p>
</li>
</ul>








<div id="id246" data-type="sect2" data-pdf-bookmark="Problems with Bech32 Addresses">
<h2>Problems with Bech32 Addresses</h2>

<p>Bech32 addresses<a data-type="indexterm" data-primary="public key cryptography" data-secondary="bech32 addresses" data-tertiary="problems with" id="pub-key-bech32-prob" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="addresses" data-secondary="bech32" data-tertiary="problems with" id="address-bech32-prob" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="bech32 addresses" data-secondary="problems with" id="bech32-prob" target="_blank" rel="noopener noreferrer"></a> would have been a success in every area except for one
problem.  The mathematical guarantees about their ability to detect
errors only apply if the length of the address you enter into a wallet
is the same length of the original address.  If you add or remove any
characters during transcription, the guarantee doesn’t apply and your
wallet may spend funds to a wrong address.  However, even without the
guarantee, it was thought that it would be very unlikely that a user adding
or removing characters would produce a string with a valid checksum, ensuring
users’ funds were safe.</p>

<p>Unfortunately, the choice for one of the constants in the bech32
algorithm just happened to make it very easy to add or remove the letter
“q” in the penultimate position of an address that ends with the letter
“p.”  In those cases, you can also add or remove the letter “q” multiple
times.  This will be caught by the checksum some of the time, but it
will be missed far more often than the one-in-a-billion expectations for
bech32’s substitution errors.  For an example, see <a data-type="xref" href="#bech32_length_extension_example" target="_blank" rel="noopener noreferrer">Example&nbsp;4-4</a>.</p>
<div id="bech32_length_extension_example" data-type="example">
<h5><span>Example 4-4. </span>Extending the length of bech32 address without invalidating its checksum</h5>

<div data-testid="custom pre block"><pre data-type="programlisting">Intended bech32 address:
bc1pqqqsq9txsqp

Incorrect addresses with a valid checksum:
bc1pqqqsq9txsqqqqp
bc1pqqqsq9txsqqqqqqp
bc1pqqqsq9txsqqqqqqqqp
bc1pqqqsq9txsqqqqqqqqqp
bc1pqqqsq9txsqqqqqqqqqqqp</pre></div></div>

<p>For the initial version of segwit (version 0), this wasn’t a practical
concern.  Only two valid lengths were defined for v0 segwit outputs: 22
bytes and 34 bytes.  Those correspond to bech32 addresses that are 42 characters
or 62 characters long, so someone would need to add or remove the letter “q”
from the penultimate position of a bech32 address 20 times in order to
send money to an invalid address without a wallet being able to detect
it.  However, it would become a problem for users in the future if
a segwit-based upgrade were ever to be <a data-type="indexterm" data-primary="public key cryptography" data-secondary="bech32 addresses" data-tertiary="problems with" data-startref="pub-key-bech32-prob" id="id674" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="addresses" data-secondary="bech32" data-tertiary="problems with" data-startref="address-bech32-prob" id="id675" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="bech32 addresses" data-secondary="problems with" data-startref="bech32-prob" id="id676" target="_blank" rel="noopener noreferrer"></a>implemented.</p>
</div>








<div id="id56" data-type="sect2" data-pdf-bookmark="Bech32m">
<h2>Bech32m</h2>

<p>Although<a data-type="indexterm" data-primary="public key cryptography" data-secondary="bech32 addresses" data-tertiary="bech32m" id="pub-key-bech32-bech32m" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="bech32 addresses" data-secondary="bech32m" id="bech32-bech32m" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="addresses" data-secondary="bech32m" id="address-bech32m" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="bech32m addresses" id="bech32m" target="_blank" rel="noopener noreferrer"></a> bech32 worked well for segwit v0, developers didn’t want to
unnecessarily constrain output sizes in later versions of segwit.
Without constraints, adding or removing a single “q” in a bech32 address
could result in a user accidentally sending their money to an
output that was either unspendable or spendable by anyone (allowing
those bitcoins to be taken by anyone).  Developers exhaustively analyzed the bech32
problem and found that changing a single constant in their algorithm
would eliminate the problem, ensuring that any insertion or deletion of
up to five characters will only fail to be detected less often than one
time in a billion.</p>

<p>The version of bech32 with a single different constant is known as
bech32 modified (bech32m).  All of the characters in bech32 and bech32m
addresses for the same underlying data will be identical except for the
last six (the checksum).  That means a wallet will need to know which
version is in use in order to validate the checksum, but both address
types contain an internal version byte that makes determining that easy.</p>

<p>To work with both bech32 and<a data-type="indexterm" data-primary="encoding" data-secondary="bech32m addresses" id="encode-bech32m" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="decoding" data-secondary="addresses" data-see="addresses" id="id677" target="_blank" rel="noopener noreferrer"></a> bech32m, we’ll look at the encoding and parsing rules for
bech32m Bitcoin addresses since they encompass the ability to parse
bech32 addresses and are the current recommended address format for
Bitcoin wallets.</p>

<p>Bech32m addresses start with a human readable part (HRP).  There are
rules in BIP173 for creating your own HRPs, but for Bitcoin you only
need to know about the HRPs already chosen, shown in
<a data-type="xref" href="#bech32_hrps_for_bitcoin" target="_blank" rel="noopener noreferrer">Table&nbsp;4-2</a>.</p>
<table id="bech32_hrps_for_bitcoin"><caption><span>Table 4-2. </span>Bech32 HRPs for Bitcoin</caption><thead><tr><th>HRPs</th><th>Network</th></tr></thead><tbody><tr><td><p>bc</p></td><td><p>Bitcoin mainnet</p></td></tr><tr><td><p>tb</p></td><td><p>Bitcoin testnet</p></td></tr></tbody></table>

<p>The HRP is followed by a separator, the number “1.”  Earlier proposals
for a protocol separator used a colon but some operating systems and
applications that allow a user to double-click a word to highlight
it for copy and pasting won’t extend the highlighting to and past a
colon.  A number ensured double-click highlighting would work with any
program that supports bech32m strings in general (which include other
numbers).  The number “1” was chosen because bech32 strings don’t
otherwise use it in order to prevent accidental transliteration between
the number “1” and the lowercase letter “l.”</p>

<p>The other part of a bech32m address is called the “data part.”  There
are three elements to this part:</p>
<dl>
<dt>Witness version</dt>
<dd>
<p>A single byte that encodes as a single character
in a bech32m Bitcoin address immediately following the separator.
This letter represents the segwit version.  The letter “q” is the
encoding of “0” for segwit v0, the initial version of segwit where
bech32 addresses were introduced.  The letter “p” is the encoding of
“1” for segwit v1 (also called taproot) where bech32m began to be
used.  There are seventeen possible versions of segwit and it’s
required for Bitcoin that the first byte of a bech32m data part decode
to the number 0 through 16 (inclusive).</p>
</dd>
<dt>Witness program</dt>
<dd>
<p>From 2 to 40 bytes.  For segwit v0, this witness program
must be either 20 or 32 bytes; no other length is valid.  For segwit
v1, the only defined length as of this writing is 32 bytes but other
lengths may be defined later.</p>
</dd>
<dt>Checksum</dt>
<dd>
<p>Exactly 6 characters.  This is created using a BCH code, a type of
error correction code (although for Bitcoin addresses, we’ll see later
that it’s essential to use the checksum only for error detection—​not
correction).</p>
</dd>
</dl>

<p>Let’s illustrate these rules by walking through an example of creating
bech32 and bech32m addresses.  For all of the following examples, we’ll use the
<a href="https://oreil.ly/gpTT6" target="_blank" rel="noopener noreferrer">bech32m reference code
for Python</a>.</p>

<p>We’ll start by generating four output scripts, one for each of the
different segwit outputs in use at the time of publication, plus one for
a future segwit version that doesn’t yet have a defined meaning.  The
scripts are listed in <a data-type="xref" href="#scripts_for_diff_segwit_outputs" target="_blank" rel="noopener noreferrer">Table&nbsp;4-3</a>.</p>
<table id="scripts_for_diff_segwit_outputs"><caption><span>Table 4-3. </span>Scripts for different types of segwit outputs</caption><thead><tr><th>Output type</th><th>Example script</th></tr></thead><tbody><tr><td><p>P2WPKH</p></td><td><p><code>OP_0 2b626ed108ad00a944bb2922a309844611d25468</code></p></td></tr><tr><td><p>P2WSH</p></td><td><p><code>OP_0 648a32e50b6fb7c5233b228f60a6a2ca4158400268844c4bc295ed5e8c3d626f</code></p></td></tr><tr><td><p>P2TR</p></td><td><p><code>OP_1 2ceefa5fa770ff24f87c5475d76eab519eda6176b11dbe1618fcf755bfac5311</code></p></td></tr><tr><td><p>Future Example</p></td><td><p><code>OP_16 0000</code></p></td></tr></tbody></table>

<p>For the P2WPKH output, the witness program contains a commitment constructed in exactly the same
way as the commitment for a P2PKH output seen in <a data-type="xref" href="#addresses_for_p2pkh" target="_blank" rel="noopener noreferrer">“Legacy Addresses for P2PKH”</a>.  A public key is passed into a SHA256 hash
function.  The resultant 32-byte digest is then passed into a RIPEMD-160
hash function.  The digest of that function (the commitment) is placed
in the witness program.</p>

<p>For the pay to witness script hash (P2WSH) output, we don’t use the P2SH algorithm.  Instead we take
the script, pass it into a SHA256 hash function, and use the 32-byte
digest of that function in the witness program.  For P2SH, the SHA256
digest was hashed again with RIPEMD-160, but that may not be secure in
some cases; for details, see <a data-type="xref" href="#p2sh_collision_attacks" target="_blank" rel="noopener noreferrer">“P2SH Collision Attacks”</a>.  A result of
using SHA256 without RIPEMD-160 is that P2WSH commitments are 32 bytes
(256 bits) instead of 20 bytes (160 bits).</p>

<p>For the pay-to-taproot (P2TR) output, the witness program is a point on
the secp256k1 curve.  It may be a simple public key, but in most cases
it should be a public key that commits to some additional data.  We’ll
learn more about that commitment in <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch07.html#taproot" target="_blank" rel="noopener noreferrer">“Taproot”</a>.</p>
<p>
For the example of a future segwit version, we simply use the highest
possible segwit version number (16) and the smallest allowed witness
program (2 bytes) with a null value.</p>

<p>Now that we know the version number and the witness program, we can
convert each of them into a bech32 address.  Let’s use the bech32m reference
library for Python to quickly generate those addresses, and then take a
deeper look at what’s happening:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">$ github="https://raw.githubusercontent.com"
$ wget $github/sipa/bech32/master/ref/python/segwit_addr.py

$ python
&gt;&gt;&gt; from segwit_addr import *
&gt;&gt;&gt; from binascii import unhexlify

&gt;&gt;&gt; help(encode)
encode(hrp, witver, witprog)
    Encode a segwit address.

&gt;&gt;&gt; encode('bc', 0, unhexlify('2b626ed108ad00a944bb2922a309844611d25468'))
'bc1q9d3xa5gg45q2j39m9y32xzvygcgay4rgc6aaee'
&gt;&gt;&gt; encode('bc', 0,
unhexlify('648a32e50b6fb7c5233b228f60a6a2ca4158400268844c4bc295ed5e8c3d626f'))
'bc1qvj9r9egtd7mu2gemy28kpf4zefq4ssqzdzzycj7zjhk4arpavfhsct5a3p'
&gt;&gt;&gt; encode('bc', 1,
unhexlify('2ceefa5fa770ff24f87c5475d76eab519eda6176b11dbe1618fcf755bfac5311'))
'bc1p9nh05ha8wrljf7ru236awm4t2x0d5ctkkywmu9sclnm4t0av2vgs4k3au7'
&gt;&gt;&gt; encode('bc', 16, unhexlify('0000'))
'bc1sqqqqkfw08p'</pre></div>

<p>If we open the file <em>segwit_addr.py</em> and look at what the code is doing,
the first thing we will notice
is the sole difference between bech32 (used for segwit v0) and bech32m
(used for later segwit versions) is the constant:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">BECH32_CONSTANT = 1
BECH32M_CONSTANT = 0x2bc830a3</pre></div>

<p>Next we notice the code that produces the checksum.  In the final step of the
checksum, the appropriate constant is merged into the value using an xor
operation.  That single value is the only difference between bech32 and
bech32m.</p>

<p>With the checksum created, each 5-bit character in the data part
(including the witness version, witness program, and checksum) is
converted to alphanumeric characters.</p>

<p>For decoding back into an output script, we work in reverse.  First let’s
use the reference library to decode two of our addresses:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">&gt;&gt;&gt; help(decode)
decode(hrp, addr)
    Decode a segwit address.

&gt;&gt;&gt; _ = decode("bc", "bc1q9d3xa5gg45q2j39m9y32xzvygcgay4rgc6aaee")
&gt;&gt;&gt;  _[0], bytes(_[1]).hex()
(0, '2b626ed108ad00a944bb2922a309844611d25468')
&gt;&gt;&gt; _ = decode("bc",
        "bc1p9nh05ha8wrljf7ru236awm4t2x0d5ctkkywmu9sclnm4t0av2vgs4k3au7")
&gt;&gt;&gt; _[0], bytes(_[1]).hex()
(1, '2ceefa5fa770ff24f87c5475d76eab519eda6176b11dbe1618fcf755bfac5311')</pre></div>

<p>We get back both the witness version and the witness program.  Those can
be inserted into the template for our output script:</p>



<p>For example:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">OP_0 2b626ed108ad00a944bb2922a309844611d25468
OP_1 2ceefa5fa770ff24f87c5475d76eab519eda6176b11dbe1618fcf755bfac5311</pre></div>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>One
possible mistake here to be aware of is that a witness version of <code>0</code> is
for <code>OP_0</code>, which uses the byte 0x00—​but a witness version of <code>1</code> uses
<code>OP_1</code>, which is byte 0x51.  Witness versions <code>2</code> through <code>16</code> use 0x52
through 0x60, respectively.</p>
</div>

<p>When implementing bech32m encoding or decoding, we very strongly
recommend that you use the test vectors provided in BIP350.  We also ask
that you ensure your code passes the test vectors related to paying future segwit
versions that haven’t been defined yet.  This will help make your
software usable for many years to come even if you aren’t able to add
support for new Bitcoin features as soon as they become <a data-type="indexterm" data-primary="public key cryptography" data-secondary="bech32 addresses" data-tertiary="bech32m" data-startref="pub-key-bech32-bech32m" id="id678" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="bech32 addresses" data-secondary="bech32m" data-startref="bech32-bech32m" id="id679" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="addresses" data-secondary="bech32m" data-startref="address-bech32m" id="id680" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="bech32m addresses" data-startref="bech32m" id="id681" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="encoding" data-secondary="bech32m addresses" data-startref="encode-bech32m" id="id682" target="_blank" rel="noopener noreferrer"></a>available.</p>
</div>








<div id="priv_formats" data-type="sect2" data-pdf-bookmark="Private Key Formats">
<h2>Private Key Formats</h2>

<p>The <a data-type="indexterm" data-primary="private keys" data-secondary="formats" id="private-key-format" target="_blank" rel="noopener noreferrer"></a>private key
can be represented in a number of different formats, all of which
correspond to the same 256-bit number. <a data-type="xref" href="#table_4-2" target="_blank" rel="noopener noreferrer">Table&nbsp;4-4</a> shows several common
formats used to represent private keys. Different formats are used in
different circumstances. Hexadecimal and raw binary formats are used
internally in software and rarely shown to users. The WIF is used for
import/export of keys between wallets and often used in QR code
(barcode) representations of private keys.</p>

<table id="table_4-2"><caption><span>Table 4-4. </span>Private key representations (encoding formats)</caption><thead><tr><th>Type</th><th>Prefix</th><th>Description</th></tr></thead><tbody><tr><td><p>Hex</p></td><td><p>None</p></td><td><p>64 hexadecimal digits</p></td></tr><tr><td><p>WIF</p></td><td><p>5</p></td><td><p>Base58check encoding: base58 with version prefix of 128 and 32-bit checksum</p></td></tr><tr><td><p>WIF-compressed</p></td><td><p>K or L</p></td><td><p>As above, with added suffix 0x01 before encoding</p></td></tr></tbody></table>

<p><a data-type="xref" href="#table_4-3" target="_blank" rel="noopener noreferrer">Table&nbsp;4-5</a> shows the private key generated in several different formats.</p>
<table id="table_4-3"><caption><span>Table 4-5. </span>Example: Same key, different formats</caption><thead><tr><th>Format</th><th>Private key</th></tr></thead><tbody><tr><td><p>Hex</p></td><td><p>1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd</p></td></tr><tr><td><p>WIF</p></td><td><p>5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</p></td></tr><tr><td><p>WIF-compressed</p></td><td><p>KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</p></td></tr></tbody></table>

<p>All of these representations are different ways of showing the same
number, the same private key. They look different, but any one format
can easily be converted to any other<a data-type="indexterm" data-primary="private keys" data-secondary="formats" data-startref="private-key-format" id="id685" target="_blank" rel="noopener noreferrer"></a> format.</p>
</div>








<div id="comp_priv" data-type="sect2" data-pdf-bookmark="Compressed Private Keys">
<h2>Compressed Private Keys</h2>

<p>The commonly<a data-type="indexterm" data-primary="private keys" data-secondary="compressed" id="private-key-compress" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="compressed private keys" id="compress-private-key" target="_blank" rel="noopener noreferrer"></a> used term “compressed private key” is a misnomer, because when a private
key is exported as WIF-compressed, it is actually one byte <em>longer</em> than
an “uncompressed” private key. That is because the private key has an
added one-byte suffix (shown as 01 in hex in <a data-type="xref" href="#table_4-4" target="_blank" rel="noopener noreferrer">Table&nbsp;4-6</a>), which
signifies that the private key is from a newer wallet and should only be
used to produce compressed public keys. Private keys are not themselves
compressed and cannot be compressed. The term <em>compressed private key</em>
really means “private key from which only compressed public keys should
be derived,” whereas <em>uncompressed private key</em> really means “private
key from which only uncompressed public keys should be derived.” You
should only refer to the export format as “WIF-compressed” or “WIF” and
not refer to the private key itself as “compressed” to avoid further
confusion</p>

<p><a data-type="xref" href="#table_4-4" target="_blank" rel="noopener noreferrer">Table&nbsp;4-6</a> shows the same key, encoded in WIF and WIF-compressed formats.</p>
<table id="table_4-4"><caption><span>Table 4-6. </span>Example: Same key, different formats</caption><thead><tr><th>Format</th><th>Private key</th></tr></thead><tbody><tr><td><p>Hex</p></td><td><p>1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD</p></td></tr><tr><td><p>WIF</p></td><td><p>5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</p></td></tr><tr><td><p>Hex-compressed</p></td><td><p>1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD01</p></td></tr><tr><td><p>WIF-compressed</p></td><td><p>KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</p></td></tr></tbody></table>

<p>Notice that the hex-compressed private key format has one extra byte at
the end (01 in hex). While the base58 encoding version prefix is the
same (0x80) for both WIF and WIF-compressed formats, the addition of one
byte on the end of the number causes the first character of the base58
encoding to change from a 5 to either a <em>K</em> or <em>L</em>. Think of this as the
base58 equivalent of the decimal encoding difference between the number
100 and the number 99. While 100 is one digit longer than 99, it also
has a prefix of 1 instead of a prefix of 9. As the length changes, it
affects the prefix. In base58, the prefix 5 changes to a <em>K</em> or <em>L</em> as
the length of the number increases by one byte.</p>

<p>Remember, these formats are <em>not</em> used interchangeably. In a newer
wallet that implements compressed public keys, the private keys will
only ever be exported as WIF-compressed (with a <em>K</em> or <em>L</em> prefix). If
the wallet is an older implementation and does not use compressed public
keys, the private keys will only ever be exported as WIF (with a 5
prefix). The goal here is to signal to the wallet importing these
private keys whether it must search the blockchain for compressed or
uncompressed public keys and addresses.</p>

<p>If a Bitcoin wallet is able to implement compressed public keys, it will
use those in all transactions. The private keys in the wallet will be
used to derive the public key points on the curve, which will be
compressed. The compressed public keys will be used to produce Bitcoin
addresses and those will be used in transactions. When exporting private
keys from a new wallet that implements compressed public keys, the WIF
is modified, with the addition of a one-byte suffix <code>01</code> to the private
key. The resulting base58check-encoded private key is called a
“compressed WIF” and starts with the letter <em>K</em> or <em>L</em> instead of
starting with “5,” as is the case with WIF-encoded (uncompressed) keys
from<a data-type="indexterm" data-primary="private keys" data-secondary="compressed" data-startref="private-key-compress" id="id686" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="compressed private keys" data-startref="compress-private-key" id="id687" target="_blank" rel="noopener noreferrer"></a> older wallets.</p>
</div>
</div>






<div id="id409" data-type="sect1" data-pdf-bookmark="Advanced Keys and Addresses">
<h2>Advanced Keys and Addresses</h2>

<p>In the
following sections we will look at advanced forms of keys and addresses,
such as vanity addresses and paper wallets.</p>








<div id="id58" data-type="sect2" data-pdf-bookmark="Vanity Addresses">
<h2>Vanity Addresses</h2>

<p>Vanity<a data-type="indexterm" data-primary="public key cryptography" data-secondary="vanity addresses" id="pub-key-vanity" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="vanity addresses" id="vanity-addr" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="addresses" data-secondary="vanity" id="address-vanity" target="_blank" rel="noopener noreferrer"></a> addresses are valid Bitcoin
addresses that contain human-readable messages. For example,
<code>1LoveBPzzD72PUXLzCkYAtGFYmK5vYNR33</code> is a valid address that contains
the letters forming the word “Love” as the first four base58 letters.
Vanity addresses require generating and testing billions of candidate
private keys until a Bitcoin address with the desired pattern is found.
Although there are some optimizations in the vanity generation
algorithm, the process essentially involves picking a private key at
random, deriving the public key, deriving the Bitcoin address, and
checking to see if it matches the desired vanity pattern, repeating
billions of times until a match is found.</p>

<p>Once a vanity address matching the desired pattern is found, the private
key from which it was derived can be used by the owner to spend bitcoins
in exactly the same way as any other address. Vanity addresses are no
less or more secure than any other address. They depend on the same
elliptic curve cryptography (ECC) and secure hash algorithm (SHA) as any other address. You can
no more easily find the private key of an address starting with a vanity
pattern than you can any other address.</p>

<p>Eugenia is a children’s
charity director operating in the Philippines. Let’s say that Eugenia is
organizing a fundraising drive and wants to use a vanity Bitcoin
address to publicize the fundraising. Eugenia will create a vanity
address that starts with “1Kids” to promote the children’s charity
fundraiser. Let’s see how this vanity address will be created and what
it means for the security of Eugenia’s charity.</p>










<div id="id59" data-type="sect3" data-pdf-bookmark="Generating vanity addresses">
<h3>Generating vanity addresses</h3>

<p>It’s important to realize that a Bitcoin address is simply a number
represented by symbols in the base58 alphabet. The search for a pattern
like “1Kids” can be seen as searching for an address in the range from
<code>1Kids11111111111111111111111111111</code> to
<code>1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz</code>. There are approximately 58<sup>29</sup>
(approximately 1.4 × 10<sup>51</sup>) addresses in that range, all starting with
“1Kids.” <a data-type="xref" href="#table_4-11" target="_blank" rel="noopener noreferrer">Table&nbsp;4-7</a> shows the range of addresses that have the
prefix 1Kids.</p>
<table id="table_4-11"><caption><span>Table 4-7. </span>The range of vanity addresses starting with “1Kids”</caption><tbody><tr><td><p><strong>From</strong></p></td><td><p><code>1Kids11111111111111111111111111111</code></p></td></tr><tr><td></td><td><p><code>1Kids11111111111111111111111111112</code></p></td></tr><tr><td></td><td><p><code>1Kids11111111111111111111111111113</code></p></td></tr><tr><td></td><td><p><code>…​</code></p></td></tr><tr><td><p><strong>To</strong></p></td><td><p><code>1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz</code></p></td></tr></tbody></table>

<p>Let’s look at the pattern “1Kids” as a number and see how frequently we
might find this pattern in a Bitcoin address (see <a data-type="xref" href="#table_4-12" target="_blank" rel="noopener noreferrer">Table&nbsp;4-8</a>). An
average desktop computer PC, without any specialized hardware, can
search approximately 100,000 keys per second.</p>
<table id="table_4-12"><caption><span>Table 4-8. </span>The frequency of a vanity pattern (1KidsCharity) and average search time on a desktop PC</caption><thead><tr><th>Length</th><th>Pattern</th><th>Frequency</th><th>Average search time</th></tr></thead><tbody><tr><td><p>1</p></td><td><p>1K</p></td><td><p>1 in 58 keys</p></td><td><p>&lt; 1 milliseconds</p></td></tr><tr><td><p>2</p></td><td><p>1Ki</p></td><td><p>1 in 3,364</p></td><td><p>50 milliseconds</p></td></tr><tr><td><p>3</p></td><td><p>1Kid</p></td><td><p>1 in 195,000</p></td><td><p>&lt; 2 seconds</p></td></tr><tr><td><p>4</p></td><td><p>1Kids</p></td><td><p>1 in 11 million</p></td><td><p>1 minute</p></td></tr><tr><td><p>5</p></td><td><p>1KidsC</p></td><td><p>1 in 656 million</p></td><td><p>1 hour</p></td></tr><tr><td><p>6</p></td><td><p>1KidsCh</p></td><td><p>1 in 38 billion</p></td><td><p>2 days</p></td></tr><tr><td><p>7</p></td><td><p>1KidsCha</p></td><td><p>1 in 2.2 trillion</p></td><td><p>3–4 months</p></td></tr><tr><td><p>8</p></td><td><p>1KidsChar</p></td><td><p>1 in 128 trillion</p></td><td><p>13–18 years</p></td></tr><tr><td><p>9</p></td><td><p>1KidsChari</p></td><td><p>1 in 7 quadrillion</p></td><td><p>800 years</p></td></tr><tr><td><p>10</p></td><td><p>1KidsCharit</p></td><td><p>1 in 400 quadrillion</p></td><td><p>46,000 years</p></td></tr><tr><td><p>11</p></td><td><p>1KidsCharity</p></td><td><p>1 in 23 quintillion</p></td><td><p>2.5 million years</p></td></tr></tbody></table>

<p>As you can see, Eugenia won’t be creating the vanity address
“1KidsCharity” anytime soon, even if she had access to several thousand
computers. Each additional character increases the difficulty by a
factor of 58. Patterns with more than seven characters are usually found
by specialized hardware, such as custom-built desktops with multiple
graphics processing units (GPUs).
Vanity searches on GPU systems are many orders of magnitude
faster than on a general-purpose CPU.</p>

<p>Another<a data-type="indexterm" data-primary="vanity pools" id="id688" target="_blank" rel="noopener noreferrer"></a> way to find a vanity address is to outsource the work to a pool
of vanity miners. A <a href="https://oreil.ly/99K81" target="_blank" rel="noopener noreferrer">vanity pool</a> is a service that
allows those with fast hardware to earn bitcoin searching for vanity
addresses for others. For a fee, Eugenia can outsource the search for a
seven-character pattern vanity address and get results in a few hours
instead of having to run a CPU search for months.</p>

<p>Generating a vanity address is a brute-force exercise: try a random key,
check the resulting address to see if it matches the desired pattern,
repeat until successful.</p>
</div>










<div id="id60" data-type="sect3" data-pdf-bookmark="Vanity address security and privacy">
<h3>Vanity address security and privacy</h3>

<p>Vanity addresses<a data-type="indexterm" data-primary="privacy" data-secondary="vanity addresses" id="privacy-vanity" target="_blank" rel="noopener noreferrer"></a> were popular in the
early years of Bitcoin but have almost entirely disappeared from use as
of 2023.  There are two likely causes for this trend:</p>
<dl>
<dt>Deterministic wallets</dt>
<dd>
<p>As we saw in <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch01.html#recovery_code_intro" target="_blank" rel="noopener noreferrer">“Recovery Codes”</a>, it’s possible to
back up every key in most modern wallets by simply writing down a few
words or characters.  This is achieved by deriving every key in the
wallet from those words or characters using a deterministic algorithm.
It’s not possible to use vanity addresses with a deterministic wallet
unless the user backs up additional data for every vanity address they
create.  More practically, most wallets using deterministic key
generation simply don’t allow importing a private key or key tweak from
a vanity generator.</p>
</dd>
<dt>Avoiding address reuse</dt>
<dd>
<p>Using a vanity address to receive multiple
payments to the same address creates a link between all of those
payments.  This might be acceptable to Eugenia if her nonprofit needs
to report its income and expenditures to a tax authority anyway.
However, it also reduces the privacy of people who either pay Eugenia or
receive payments from her.  For example, Alice may want to donate
anonymously and Bob may not want his other customers to know that he
gives discount pricing to Eugenia.</p>
</dd>
</dl>

<p>We don’t expect to see many vanity addresses in
the future unless the preceding problems are<a data-type="indexterm" data-primary="addresses" data-secondary="vanity" data-startref="address-vanity" id="id689" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="vanity addresses" data-startref="vanity-addr" id="id690" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="public key cryptography" data-secondary="vanity addresses" data-startref="pub-key-vanity" id="id691" target="_blank" rel="noopener noreferrer"></a> solved.</p>
</div>
</div>








<div id="paper_wallets" data-type="sect2" data-pdf-bookmark="Paper Wallets">
<h2>Paper Wallets</h2>

<p>Paper wallets<a data-type="indexterm" data-primary="public key cryptography" data-secondary="paper wallets" id="pub-key-paper" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="paper wallets" id="paper-wallet" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="wallets" data-secondary="paper" id="wallet-paper" target="_blank" rel="noopener noreferrer"></a> are private keys printed on paper.
Often the paper wallet also includes the corresponding Bitcoin address
for convenience, but this is not necessary because it can be derived
from the private key.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Paper wallets are an OBSOLETE technology and are dangerous for most
users. There are many subtle pitfalls involved in generating them, not least of which is the possibility that the generating code is compromised
with a “back door.” Many bitcoins have been stolen this way. Paper
wallets are shown here for informational purposes only and should not be
used for storing bitcoin. Use a recovery code to back up your
keys, possibly with a hardware signing device to store keys and sign transactions. DO NOT
USE PAPER 
<span>WALLETS.</span></p>
</div>

<p>Paper wallets come in many designs and sizes, with many different
features. <a data-type="xref" href="#paper_wallet_simple" target="_blank" rel="noopener noreferrer">Figure&nbsp;4-10</a> shows a sample paper wallet.</p>

<figure><div id="paper_wallet_simple">
<p><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098150082/files/assets/mbc3_0410.png" alt="" width="600" height="322"></p><h6><span>Figure 4-10. </span>An example of a simple paper wallet.</h6>
</div></figure>

<p>Some are intended to be given as gifts and have seasonal themes, such as
Christmas and New Year’s. Others are designed for storage in a
bank vault or safe with the private key hidden in some way, either with
opaque scratch-off stickers or folded and sealed with tamper-proof
adhesive foil.  Other designs feature additional copies of the key and
address, in the form of detachable stubs similar to ticket stubs,
allowing you to store multiple copies to protect against fire, flood, or
other natural disasters.</p>

<p>From the original public-key focused design of Bitcoin to modern addresses
and scripts like bech32m and pay to taproot—​and even addresses for
future Bitcoin upgrades—​you’ve learned how the Bitcoin protocol allows
spenders to identify the wallets that should receive their payments.
But when it’s actually your wallet receiving the payments, you’re going
to want the assurance that you’ll still have access to that money even
if something happens to your wallet data.  In the next chapter, we’ll
look at how Bitcoin wallets are designed to protect their funds <a data-type="indexterm" data-primary="public key cryptography" data-secondary="paper wallets" data-startref="pub-key-paper" id="id692" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="paper wallets" data-startref="paper-wallet" id="id693" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="wallets" data-secondary="paper" data-startref="wallet-paper" id="id694" target="_blank" rel="noopener noreferrer"></a>from a
variety of threats.</p>
</div>
</div>
</div></div>
  <span></span> <!-- for IntersectionObserver -->
  
  
  
  


<style id="note-styling">
    .note {
      position: absolute;
      z-index: 10;
      border: none;
      outline: none;
      font-family: inherit;
      font-size: inherit;
      padding: 5px;
      min-width: 32px;
      min-height: 32px;
    }
    .note:focus {
      z-index: 11;
    }
    .note[type="0"] {
      background-color: #fff740;
      color: #2c2c2d;
    }
    .note[type="0"]::placeholder {
      color: #868226;
    }
    .note[type="1"] {
      background-color: #feff9c;
      color: #2c2c2d;
    }
    .note[type="1"]::placeholder {
      color: #6d6d3d;
    }
    .note[type="2"] {
      background-color: #ff65a3;
      color: #2c2c2d;
    }
    .note[type="2"]::placeholder {
      color: #65263f;
    }
    .note[type="3"] {
      background-color: #ff7eb9;
      color: #2c2c2d;
    }
    .note[type="3"]::placeholder {
      color: #562b3f;
    }
    .note[type="4"] {
      background-color: #7afcff;
      color: #295c5d;
    }
    .note[type="4"]::placeholder {
      color: #377677;
    }</style><div id="chapters-container">
      <style>
        #chapters {
          display: grid;
          grid-template-columns: 1fr 1fr;
          margin: 2ch 0;
        }
        #chapters a {
          cursor: pointer;
        }
        #chapters a[href=""] {
          opacity: 0.5;
          pointer-events: none;
          color: inherit;
        }
        #chapters a:first-child {
          justify-self: start;
        }
        #chapters a:last-child {
          justify-self: end;
        }
      </style>
      <hr>
      <div id="chapters">
        <a href="" title="move to the previous chapter (Ctrl/Command + PageUp)">Previous Chapter</a>
        <a href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch05.html" title="move to the next chapter (Ctrl/Command + PageDown)">Next Chapter</a>
      </div>
    </div></body><style>body {
      font-size:  19px;
      font-family: Georgia, 'Times New Roman', serif;
      width: 600px;
    }
    p {
      text-align: justify
    }
    .page {
      line-height: 28.5px;
      column-count: unset;
    }
    h1, h2, h3 {
      line-height: initial;
    }</style></html>