<!DOCTYPE html>
<html><head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <base target="_blank">
  <style>
/* latin */
@font-face {
  font-family: 'Comic Neue';
  font-style: normal;
  font-weight: 400;
  src: url(fonts/4UaHrEJDsxBrF37olUeD96rp57F2IwM.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
/* latin */
@font-face {
  font-family: 'Lexend Deca';
  font-style: normal;
  font-weight: 400;
  src: url(fonts/K2FifZFYk-dHSE0UPPuwQ7CrD94i-NCKm-U48M1wqxnDirZPl3v-.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
/* latin */
@font-face {
  font-family: 'Poppins';
  font-style: normal;
  font-weight: 400;
  src: url(fonts/pxiEyp8kv8JHgFVrJJfecnFHGPc.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

:root {
  --fg: #000; /* foreground  */
  --bg: #fff; /* background  */
  --bd: #000; /* border  */
  --lk: #006fa5; /* link */
  --lkv: #d33bf0; /* link visited */
  --hg: #ffff81; /* highlight  */
}
html {
  overflow: overlay;
}
body {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  margin: 30px auto 0 auto;
  padding: 10px;
  position: relative;

  color: var(--fg);
  border-color: var(--bd);
  background-color: var(--bg);
}
body[data-mode$="dark"] {
  --lk: #0096de;
}
body[data-mode="light"] {
  color-scheme: light;
  --fg: #222;
  --bd: #222;
  --bg: whitesmoke;
}
body[data-mode="dark"] {
  color-scheme: dark;
  --fg: #eee;
  --bd: #eee;
  --bg: #333;
}
body[data-mode="sepia"] {
  color-scheme: light;
  --fg: #5b4636;
  --bd: #5b4636;
  --bg: #f4ecd8;
}
body[data-mode="solarized-light"] {
  color-scheme: light;
  --fg: #586e75;
  --bd: #586e75;
  --bg: #fdf6e3;
}
body[data-mode="nord-light"] {
  color-scheme: light;
  --fg: #2e3440;
  --bd: #2e3440;
  --bg: #e5e9f0;
}
body[data-mode="groove-dark"] {
  color-scheme: dark;
  --fg: #cec4ac;
  --bd: #cec4ac;
  --bg: #282828;
}
body[data-mode="solarized-dark"] {
  color-scheme: dark;
  --fg: #839496;
  --bd: #839496;
  --bg: #002b36;
}
body[data-mode="nord-dark"] {
  color-scheme: dark;
  --fg: #e5e9f0;
  --bd: #e5e9f0;
  --bg: #2e3440;
}

@media print {
  body[data-mode] {
    --fg: #000;
    --bd: #000;
    --bg: #fff;

    width: unset;
    padding: 0;
    margin: 0;
  }
}
body[data-loaded=true] {
  
}
img {
  max-width: 100%;
  height: auto;
}
img:not([width])[src$=".svg"] {
  max-width: 100px;
}
body[data-images=false] canvas,
body[data-images=false] svg,
body[data-images=false] img {
  display: none;
}
svg:not([width]):not([height]) {
  max-width: 25vmin;
}
a {
  color: var(--lk);
  text-decoration: none;
}
a:visited {
  color: var(--lkv);
}

hr {
  background-color: var(--bd);
  height: 1px;
  border: 0;
}
#reader-domain {
  font-family: Helvetica, Arial, sans-serif;
  text-decoration: none;
  border-bottom-color: currentcolor;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  width: 100%;
  display: inline-block;
  direction: ltr;
}
#reader-domain > span:first-child {
  font-size: 1.1em;
}
#reader-domain > span:last-child {
  font-size: 0.8em;
}
#reader-title {
  font-size: 1.6em;
  line-height: 1.25em;
  width: 100%;
  margin: 20px 0;
  padding: 0;
}
#reader-credits,
#doi,
#published-time,
#reader-estimated-time {
  font-size: 0.85em;
  line-height: 1.48em;
  margin: 0 0 10px 0;
  padding: 0;
}
#reader-credits:not(:empty)::after {
  content: ' ⋮ ';
}
#published-time:not(:empty)::before {
  content: ' ⋮ ';
}
#doi-json {
  overflow: hidden;
}
#doi-json code {
  overflow: auto;
  max-height: 400px;
}
#published-time:empty,
#reader-credits:empty {
  display: none;
}
mark.hghlght {
  background-color: var(--hg);
}
body:not([data-columns="1"]) .page :is(h1, h2) {
  column-span: all;
  background-color: rgba(125, 125, 125, 0.1);
  padding: 10px;
}
.hidden {
  display: none;
}
</style>
  <style id="user-css">body {
  padding-bottom: 64px;
}
pre {
  white-space: pre-wrap;
}
pre code {
  background-color: #eff0f1;
  color: #393318;
  font-family: monospace;
  display: block;
  padding: 5px 10px;
}
body[data-mode="dark"] pre code {
  background-color: #585858;
  color: #e8e8e8;
}

/* CSS for sans-serif fonts */
body[data-font=sans-serif] {}
/* CSS for serif fonts */
body[data-font=serif] {}

/* CSS for "sepia" theme */
body[data-mode=sepia] {}
/* CSS for "light" theme */
body[data-mode=light] {}
/* CSS for "dark" theme */
body[data-mode=dark] {}</style>
<title>7. Authorization and Authentication</title><title>7. Authorization and Authentication :: Reader View</title></head>
<body tabindex="1" data-images="true" data-mode="groove-dark" data-font="serif" data-columns="1" data-loaded="true">
  <span></span> <!-- for IntersectionObserver -->
  <a id="reader-domain" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch07.html">
    <span>learning.oreilly.com</span>
    <span>/library/view/mastering-bitcoin-3rd/9781098150082/ch07.html</span>
  </a>
  <h1 dir="auto" id="reader-title">7. Authorization and Authentication</h1>
  <span dir="auto" id="reader-credits"></span>
  <span dir="auto" id="reader-estimated-time">71-90 minutes</span>
  <span dir="auto" id="published-time"></span>
  <hr>
  <div id="readability-page-1" class="page"><div id="sbo-rt-content" data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 7. Authorization and Authentication">



<p>When you receive bitcoins, you have to decide who will have permission
to spend them, <a data-type="indexterm" data-primary="authorization" id="id883" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="authentication" id="id884" target="_blank" rel="noopener noreferrer"></a>called <em>authorization</em>.  You also have to decide how full
nodes will distinguish the authorized spenders from everyone else,
called <em>authentication</em>.  Your authorization instructions and the
spender proof of authentication will be checked by thousands of
independent full nodes, which all need to come to the same conclusion
that a spend was authorized and authenticated in order for the transaction
containing it to be valid.</p>

<p>The original description of Bitcoin used a public key for authorization.
Alice paid Bob by putting his public key in the output of a transaction.
Authentication came from Bob in the form of a signature that committed to a
spending transaction, such as from Bob to Carol.</p>

<p>The actual version of Bitcoin that was originally released provided a
more flexible mechanism for both authorization and authentication.
Improvements since then have only increased that flexibility.  In this
chapter, we’ll explore those features and see how they’re most commonly
used.</p>






<div id="tx_script" data-type="sect1" data-pdf-bookmark="Transaction Scripts and Script Language">
<h2>Transaction Scripts and Script Language</h2>

<p>The<a data-type="indexterm" data-primary="transaction scripts" data-see="scripts" id="id885" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="Script programming language" id="id886" target="_blank" rel="noopener noreferrer"></a> original version of Bitcoin introduced a new
programming language called <em>Script</em>, a Forth-like stack-based
language.  Both the script placed in an output and the legacy
input script used in a spending transaction are written in this scripting
language.</p>

<p>Script is a very simple language.  It requires minimal processing and
cannot easily do many of the fancy things modern programming languages
can do.</p>

<p>When legacy transactions were the
most commonly used type of transaction, the majority of transactions processed
through the Bitcoin network had the form “Payment to Bob’s Bitcoin
address” and used a script called a pay to public key hash (P2PKH) script.
However, Bitcoin transactions are not limited to the “Payment to Bob’s
Bitcoin address” script. In fact, scripts can be written to express a
vast variety of complex conditions. In order to understand these more
complex scripts, we must first understand the basics of transaction
scripts and Script language.</p>

<p>In this section, we will demonstrate the basic components of the Bitcoin
transaction scripting language and show how it can be used to express
conditions for spending and how those conditions can be satisfied.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Bitcoin transaction validation<a data-type="indexterm" data-primary="transactions" data-secondary="validating" id="id887" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="validating" data-secondary="transactions" id="id888" target="_blank" rel="noopener noreferrer"></a> is not based on
a static pattern but instead is achieved through the execution of a
scripting language. This language allows for a nearly infinite variety
of conditions to be expressed.</p>
</div>








<div id="id109" data-type="sect2" data-pdf-bookmark="Turing Incompleteness">
<h2>Turing Incompleteness</h2>

<p>The <a data-type="indexterm" data-primary="scripts" data-secondary="Turing incompleteness" id="id889" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="Turing Complete" id="id890" target="_blank" rel="noopener noreferrer"></a>Bitcoin transaction script language
contains many operators, but is deliberately limited in one important
way—​there are no loops or complex flow control capabilities other than
conditional flow control. This ensures that the language is not <em>Turing
Complete</em>, meaning that scripts have limited complexity and predictable
execution times. Script is not a general-purpose language.
These
limitations ensure that the language cannot be used to create an
infinite loop or other form of “logic bomb” that could be embedded in a
transaction in a way that causes a denial-of-service attack against the
Bitcoin network. Remember, every transaction is validated by every full
node on the Bitcoin network. A limited language prevents the transaction
validation mechanism from being used as a vulnerability.</p>
</div>








<div id="id110" data-type="sect2" data-pdf-bookmark="Stateless Verification">
<h2>Stateless Verification</h2>

<p>The <a data-type="indexterm" data-primary="scripts" data-secondary="stateless verification" id="id891" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="stateless script verification" id="id892" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="verifying" data-secondary="scripts" id="id893" target="_blank" rel="noopener noreferrer"></a>Bitcoin transaction script language is
stateless, in that there is no state prior to execution of the script
or state saved after execution of the script. All the
information needed to execute a script is contained within the script
and the transaction executing the script.  A
script will predictably execute the same way on any system. If your
system verified a script, you can be sure that every other system in the
Bitcoin network will also verify the script, meaning that a valid
transaction is valid for everyone and everyone knows this. This
predictability of outcomes is an essential benefit of the Bitcoin
system.</p>
</div>








<div id="tx_lock_unlock" data-type="sect2" data-pdf-bookmark="Script Construction">
<h2>Script Construction</h2>

<p>Bitcoin’s <a data-type="indexterm" data-primary="scripts" data-secondary="input/output" data-tertiary="constructing" id="script-input-output-construct" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="input scripts" data-secondary="constructing" id="input-script-construct" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="output scripts" data-secondary="constructing" id="output-script-construct" target="_blank" rel="noopener noreferrer"></a>legacy transaction validation engine relies on two parts of scripts
to validate transactions: an output script and an input script.</p>

<p>An output script
specifies the conditions that must be met to spend the output in the
future, such as who is authorized to spend the output and how they will
be authenticated.</p>

<p>An input script is a script that satisfies the
conditions placed in an output script and allows the output
to be spent. Input scripts are part of every transaction input. Most
of the time in legacy transactions they contain a digital signature produced by the user’s
wallet from his or her private key, but not all input scripts
must contain signatures.</p>

<p>Every Bitcoin<a data-type="indexterm" data-primary="transactions" data-secondary="validating" id="id894" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="validating" data-secondary="transactions" id="id895" target="_blank" rel="noopener noreferrer"></a> validating node will validate transactions by executing
the output and input scripts.  As we saw in
<a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch06.html#c_transactions" target="_blank" rel="noopener noreferrer">Chapter&nbsp;6</a>, each input contains an outpoint that refers to a
previous transaction output.  The input also contains an input script.  The
validation software will copy the input script, retrieve the UTXO
referenced by the input, and copy the output script from that UTXO. The
input and output scripts are then executed together. The input is
valid if the input script satisfies the output script’s conditions
(see <a data-type="xref" href="#script_exec" target="_blank" rel="noopener noreferrer">“Separate execution of output and input scripts”</a>). All the inputs are validated independently as
part of the overall validation of the transaction.</p>

<p>Note that the preceding steps involve making copies of all data.  The
original data in the previous output and current input is never changed.
In particular, the previous output is invariable and unaffected by
failed attempts to spend it.  Only a valid transaction that correctly
satisfies the conditions of the output script results in the output being
considered as “spent.”</p>

<p><a data-type="xref" href="#input_and_output_scripts_legacy" target="_blank" rel="noopener noreferrer">Figure&nbsp;7-1</a> is an example of the output and
input scripts for the most common type of legacy Bitcoin transaction (a
payment to a public key hash), showing the combined script resulting
from the concatenation of the scripts prior to
validation.</p>

<figure><div id="input_and_output_scripts_legacy">
<p><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098150082/files/assets/mbc3_0701.png" alt="" width="600" height="124"></p><h6><span>Figure 7-1. </span>Combining input and output scripts to evaluate a transaction script.</h6>
</div></figure>










<div id="id111" data-type="sect3" data-pdf-bookmark="The script execution stack">
<h3>The script execution stack</h3>

<p>Bitcoin’s <a data-type="indexterm" data-primary="scripts" data-secondary="stack" id="script-stack" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="stack" id="stack" target="_blank" rel="noopener noreferrer"></a>scripting language is called a stack-based language because it
uses a data structure called a <em>stack</em>. A stack is a very simple data
structure that can be visualized as a stack of cards. A stack has two
base operations: push and pop. Push adds an item on top of the stack. Pop
removes the top item from the stack.</p>

<p>The scripting language executes the script by processing each item from
left to right. Numbers (data constants) are pushed onto the stack.
Operators push or pop one or more parameters from the stack, act on
them, and might push a result onto the stack. For example, <code>OP_ADD</code> will
pop two items from the stack, add them, and push the resulting sum onto
the stack.</p>

<p>Conditional operators evaluate a condition, producing a boolean result
of <code>TRUE</code> or <code>FALSE</code>. For example, <code>OP_EQUAL</code> pops two items from the stack
and pushes <code>TRUE</code> (<code>TRUE</code> is represented by the number 1) if they are equal
or <code>FALSE</code> (represented by 0) if they are not equal. Bitcoin
transaction scripts usually contain a conditional operator so that they
can produce the <code>TRUE</code> result that signifies a valid <a data-type="indexterm" data-primary="scripts" data-secondary="stack" data-startref="script-stack" id="id896" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="stack" data-startref="stack" id="id897" target="_blank" rel="noopener noreferrer"></a>transaction.</p>
</div>










<div id="id252" data-type="sect3" data-pdf-bookmark="A simple script">
<h3>A simple script</h3>

<p>Now let’s <a data-type="indexterm" data-primary="scripts" data-secondary="input/output" data-tertiary="examples of" id="script-input-output-example" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="input scripts" data-secondary="examples of" id="input-script-example" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="output scripts" data-secondary="examples of" id="output-script-example" target="_blank" rel="noopener noreferrer"></a>apply what we’ve learned about scripts and stacks to some simple examples.</p>

<p>As we will see in <a data-type="xref" href="#simplemath_script" target="_blank" rel="noopener noreferrer">Figure&nbsp;7-2</a>, the script <code>2 3 OP_ADD 5 OP_EQUAL</code>
demonstrates the arithmetic addition operator <code>OP_ADD</code>, adding two
numbers and putting the result on the stack, followed by the conditional
operator <code>OP_EQUAL</code>, which checks that the resulting sum is equal to
<code>5</code>. For brevity, the <code>OP_</code> prefix may sometimes be omitted in examples
in this book. For more details on the available script operators and
functions, see <a href="https://oreil.ly/21vH9" target="_blank" rel="noopener noreferrer">Bitcoin Wiki’s script
page</a>.</p>

<p>Although most legacy output scripts refer to a public key hash (essentially, a
legacy Bitcoin address), thereby requiring proof of ownership to spend the
funds, the script does not have to be that complex. Any combination of
output and input scripts that results in a <code>TRUE</code> value is valid. The
simple arithmetic we used as an example of the scripting language is
also a valid script.</p>

<p>Use part of the arithmetic example script as the output script:</p>



<p>which can be satisfied by a transaction containing an input with the
input script:</p>



<p>The validation software combines the scripts:</p>



<p>As we see in <a data-type="xref" href="#simplemath_script" target="_blank" rel="noopener noreferrer">Figure&nbsp;7-2</a>, when
this script is executed, the result is <code>OP_TRUE</code>, making the transaction valid.  Although this is a valid transaction
output script, note that the resulting UTXO can be spent by anyone with
the arithmetic skills
to know that the number 2 satisfies the script.</p>

<figure><div id="simplemath_script">
<p><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098150082/files/assets/mbc3_0702.png" alt="" width="600" height="800"></p><h6><span>Figure 7-2. </span>Bitcoin’s script validation doing simple math.</h6>
</div></figure>
<div data-type="tip"><h6>Tip</h6>
<p>Transactions are valid if the
top result on the stack is <code>TRUE</code>, which is any
nonzero value.
Transactions are invalid if the top value on the stack is <code>FALSE</code> (the
value zero or an empty stack), the script
execution is halted explicitly by an operator (such as <code>VERIFY</code>,
<code>OP_RETURN</code>), or the script was not semantically valid (such as
containing an <code>OP_IF</code> statement that was not terminated by an <code>OP_ENDIF</code>
opcode).  For details, see <a href="https://oreil.ly/J2DXt" target="_blank" rel="noopener noreferrer">Bitcoin
Wiki’s script page</a>.</p>
</div>

<p>The following is a slightly more complex script, which calculates
2 + 7 – 3 + 1. Notice that when the script contains several operators in
a row, the stack allows the results of one operator to be acted upon by
the next operator:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">2 7 OP_ADD 3 OP_SUB 1 OP_ADD 7 OP_EQUAL</pre></div>

<p>Try validating the preceding script yourself using pencil and paper.
When the script execution ends, you should be left with a <code>TRUE</code> value
on the <a data-type="indexterm" data-primary="scripts" data-secondary="input/output" data-tertiary="examples of" data-startref="script-input-output-example" id="id898" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="input scripts" data-secondary="examples of" data-startref="input-script-example" id="id899" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="output scripts" data-secondary="examples of" data-startref="output-script-example" id="id900" target="_blank" rel="noopener noreferrer"></a>stack.</p>
</div>










<div id="script_exec" data-type="sect3" data-pdf-bookmark="Separate execution of output and input scripts">
<h3>Separate execution of output and input scripts</h3>

<p>In the <a data-type="indexterm" data-primary="scripts" data-secondary="input/output" data-tertiary="separate execution" id="id901" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="input scripts" data-secondary="separate execution from output scripts" id="id902" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="output scripts" data-secondary="separate execution from input scripts" id="id903" target="_blank" rel="noopener noreferrer"></a>original Bitcoin
client, output and input scripts were concatenated and executed
in sequence. For security reasons, this was changed in 2010 because of
a vulnerability known as the <code>1 OP_RETURN</code> bug.  In the current
implementation, the scripts are executed separately with the stack
transferred between the two executions.</p>

<p>First, the input script is executed using the stack execution
engine. If the input script is executed without errors and has
no operations left over, the stack is copied and the
output script is executed. If the result of executing the output script
with the stack data copied from the input script is <code>TRUE</code>,
the input script has succeeded in resolving the conditions imposed
by the output script and, therefore, the input is a valid authorization
to spend the UTXO. If any result other than <code>TRUE</code> remains after
execution of the combined script, the input is invalid because it has
failed to satisfy the spending conditions placed on the output.</p>
</div>
</div>








<div id="p2pkh" data-type="sect2" data-pdf-bookmark="Pay to Public Key Hash">
<h2>Pay to Public Key Hash</h2>

<p>A <a data-type="indexterm" data-primary="P2PKH (pay to public key hash)" id="id904" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="addresses" data-secondary="P2PKH (pay to public key hash)" id="id905" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="scripts" data-secondary="P2PKH (pay to public key hash)" id="id906" target="_blank" rel="noopener noreferrer"></a>pay to public key hash (P2PKH) script uses an output script that
contains a hash that commits to a public key.  P2PKH is best known as
the basis for a legacy Bitcoin address. A P2PKH output can be spent by
presenting a public key that matches the hash commitment and a digital
signature created by the corresponding private key (see
<a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch08.html#c_signatures" target="_blank" rel="noopener noreferrer">Chapter&nbsp;8</a>).  Let’s look at an example of a P2PKH output script:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">OP_DUP OP_HASH160 &lt;Key Hash&gt; OP_EQUALVERIFY OP_CHECKSIG</pre></div>

<p>The <code>Key Hash</code> is the data that would be encoded into a legacy base58check
address.  Most applications would show the <em>public key hash</em> in a script
using hexadecimal encoding and not the familiar Bitcoin
address base58check format that begins with 
<span>a “1.”</span></p>

<p>The preceding output script can be satisfied with an input script
of the form:</p>



<p>The two scripts together would form the following combined validation
script:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">&lt;Sig&gt; &lt;Pubkey&gt; OP_DUP OP_HASH160 &lt;Hash&gt; OP_EQUALVERIFY OP_CHECKSIG</pre></div>

<p>The result will be <code>TRUE</code> if the input script
has a valid signature from Bob’s private key that corresponds to
the public key hash set as an encumbrance.</p>

<p>Figures <a data-type="xref" data-xrefstyle="select: labelnumber" href="#P2PubKHash1" target="_blank" rel="noopener noreferrer">7-3</a> and <a data-type="xref" data-xrefstyle="select: labelnumber" href="#P2PubKHash2" target="_blank" rel="noopener noreferrer">7-4</a> show (in two parts) a step-by-step
execution of the combined script, which will prove this is a valid
transaction.</p>

<figure><div id="P2PubKHash1">
<p><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098150082/files/assets/mbc3_0703.png" alt="" width="600" height="499"></p><h6><span>Figure 7-3. </span>Evaluating a script for a P2PKH transaction (part 1 of 2).</h6>
</div></figure>

<figure><div id="P2PubKHash2">
<p><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098150082/files/assets/mbc3_0704.png" alt="" width="600" height="638"></p><h6><span>Figure 7-4. </span>Evaluating a script for a P2PKH transaction (part 2 of 2).</h6>
</div></figure>
</div>
</div>






<div id="multisig" data-type="sect1" data-pdf-bookmark="Scripted Multisignatures">
<h2>Scripted Multisignatures</h2>

<p>Multisignature scripts<a data-type="indexterm" data-primary="scripted multisignatures" id="script-multisignature" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="multisignature scripts" id="multi-script" target="_blank" rel="noopener noreferrer"></a> set a condition where <em>k</em> public keys
are recorded in the script and at least <em>t</em> of those must provide
signatures to spend the funds, called <em>t</em>-of-<em>k</em>.
For example, a 2-of-3 multisignature is one
where three public keys are listed as potential signers and at least two
of those must be used to create signatures for a valid transaction to
spend the funds.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Some Bitcoin documentation, including earlier editions of this book,
uses the term “m-of-n” for a traditional multisignature.  However, it’s hard
to tell “m” and “n” apart when they’re spoken, so we use the alternative
<em>t</em>-of-<em>k</em>.  Both phrases refer to the same type of signature scheme.</p>
</div>

<p>The general form of an output script setting a <em>t</em>-of-<em>k</em> multisignature
condition is:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">t &lt;Public Key 1&gt; &lt;Public Key 2&gt; ... &lt;Public Key k&gt; k OP_CHECKMULTISIG</pre></div>

<p>where <em>k</em> is the total number of listed public keys and <em>t</em> is the threshold
of required signatures to spend the output.</p>

<p>An output script setting a 2-of-3 multisignature condition looks like
this:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">2 &lt;Public Key A&gt; &lt;Public Key B&gt; &lt;Public Key C&gt; 3 OP_CHECKMULTISIG</pre></div>

<p>The preceding output script can be satisfied with an input script
containing 
<span>signatures:</span></p>

<div data-testid="custom pre block"><pre data-type="programlisting">&lt;Signature B&gt; &lt;Signature C&gt;</pre></div>

<p>or any combination of two signatures from the private keys corresponding
to the three listed public keys.</p>

<p>The two scripts together would form the combined validation script:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">&lt;Sig B&gt; &lt;Sig C&gt; 2 &lt;Pubkey A&gt; &lt;Pubkey B&gt; &lt;Pubkey C&gt; 3 OP_CHECKMULTISIG</pre></div>

<p>When executed, this combined script will evaluate to <code>TRUE</code> if
the input script has
two valid signatures from private keys that correspond to two of
the three public keys set as an encumbrance.</p>

<p>At this time, Bitcoin Core’s transaction relay policy limits multisignature output scripts to, at most, three
listed public keys, meaning you can do anything from a 1-of-1 to a
3-of-3 multisignature or any combination within that range.
You may want to check the <code>IsStandard()</code> function to see what is currently
accepted by the network. Note that the limit of three keys applies only to
standard (also known as “bare”) multisignature scripts, not to
scripts wrapped in another structure like P2SH, P2WSH, or P2TR.
P2SH multisignature scripts are limited by both policy and consensus to
15 keys, allowing for up to a 15-of-15 multisignature. We will learn about
P2SH in <a data-type="xref" href="#p2sh" target="_blank" rel="noopener noreferrer">“Pay to Script Hash”</a>.   All other scripts are consensus limited to 20 keys
per <code>OP_CHECKMULTISIG</code> or <code>OP_CHECKMULTISIGVERIFY</code> opcode, although one
script may include multiple of those opcodes.</p>








<div id="multisig_bug" data-type="sect2" data-pdf-bookmark="An Oddity in CHECKMULTISIG Execution">
<h2>An Oddity in CHECKMULTISIG Execution</h2>

<p>There <a data-type="indexterm" data-primary="OP_CHECKMULTISIG execution" id="op-checkmultisig" target="_blank" rel="noopener noreferrer"></a>is an oddity in
<code>OP_CHECKMULTISIG</code>’s execution that requires a slight workaround. When
<code>OP_CHECKMULTISIG</code> executes, it should consume <em>t</em> + <em>k</em> + 2 items on the stack as
parameters. However, due to the oddity, <code>OP_CHECKMULTISIG</code> will pop an extra
value or one value more than expected.</p>

<p>Let’s look at this in greater detail using the previous validation
example:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">&lt;Sig B&gt; &lt;Sig C&gt; 2 &lt;Pubkey A&gt; &lt;Pubkey B&gt; &lt;Pubkey C&gt; 3 OP_CHECKMULTISIG</pre></div>

<p>First, <code>OP_CHECKMULTISIG</code> pops the top item, which is <em>k</em> (in this example
“3”). Then it pops <em>k</em> items, which are the public keys that can sign;
in this example, public keys A, B, and C. Then, it pops one item, which
is <em>t</em>, the quorum (how many signatures are needed). Here <em>t</em> = 2. At this
point, <code>OP_CHECKMULTISIG</code> should pop the final <em>t</em> items, which are the
signatures, and see if they are valid. However, unfortunately, an oddity in
the implementation causes <code>OP_CHECKMULTISIG</code> to pop one more item (<em>t</em> + 1
total) than it should. The extra item is called<a data-type="indexterm" data-primary="dummy stack element" id="id907" target="_blank" rel="noopener noreferrer"></a> the <em>dummy stack
element</em>, and it is disregarded when checking the
signatures so it has no direct effect on <code>OP_CHECKMULTISIG</code> itself.
However, the dummy element must be present because, if it isn’t present
when <code>OP_CHECKMULTISIG</code> attempts to pop on an empty stack, it will cause a
stack error and script failure (marking the transaction as invalid).
Because the dummy element is disregarded, it can be anything. It became the custom early on to use <code>OP_0</code>, which later became a
relay policy rule and eventually a consensus rule (with the enforcement of BIP147).</p>

<p>Because popping the dummy element is part of the consensus rules, it must now be
replicated forever. Therefore a script should look
like this:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">OP_0 &lt;Sig B&gt; &lt;Sig C&gt; 2 &lt;Pubkey A&gt; &lt;Pubkey B&gt; &lt;Pubkey C&gt; 3 OP_CHECKMULTISIG</pre></div>

<p>Thus the input script actually used in multisig is not:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">&lt;Signature B&gt; &lt;Signature C&gt;</pre></div>

<p>but instead it is:</p>



<p>Some people believe this oddity was a bug in the original code for
Bitcoin, but a plausible alternative explanation exists.  Verifying
<em>t</em>-of-<em>k</em> signatures can require many more than <em>t</em> or <em>k</em> signature checking
operations.  Let’s consider a simple example of 1-in-5, with the
following combined script:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">&lt;dummy&gt; &lt;Sig4&gt; 1 &lt;key0&gt; &lt;key1&gt; &lt;key2&gt; &lt;key3&gt; &lt;key4&gt; 5 OP_CHECKMULTISIG</pre></div>

<p>The signature is checked first against <code>key0</code>, then <code>key1</code>, and then
the other keys before it is finally compared to its corresponding
<code>key4</code>.  That means five signature checking operations need to be
performed even though there’s only one signature.  One way to eliminate
this redundancy would have been to provide <code>OP_CHECKMULTISIG</code> a map
indicating which provided signature corresponds to which public key,
allowing the <code>OP_CHECKMULTISIG</code> operation to only perform exactly <em>t</em>
signature-checking operations.  It’s possible that Bitcoin’s original
developer added the extra element (which we now call the dummy stack
element) in the original version of Bitcoin so they could add the
feature for allowing a map to be passed in a later soft fork.  However,
that feature was never implemented, and the BIP147 update to the
consensus rules in 2017 makes it impossible to add that feature in the
future.</p>

<p>Only Bitcoin’s original developer could tell us whether the dummy stack
element was the result of a bug or a plan for a future upgrade.  In this
book, we simply call it an oddity.</p>

<p>From now on, if you see a multisig script, you should expect
to see an extra <code>OP_0</code> in the beginning, whose only purpose is as a
workaround to an oddity in the <a data-type="indexterm" data-primary="scripted multisignatures" data-startref="script-multisignature" id="id908" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="multisignature scripts" data-startref="multi-script" id="id909" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="OP_CHECKMULTISIG execution" data-startref="op-checkmultisig" id="id910" target="_blank" rel="noopener noreferrer"></a>consensus rules.</p>
</div>
</div>






<div id="p2sh" data-type="sect1" data-pdf-bookmark="Pay to Script Hash">
<h2>Pay to Script Hash</h2>

<p>Pay to script hash (P2SH) was<a data-type="indexterm" data-primary="scripts" data-secondary="P2SH (pay to script hash)" id="script-p2sh" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="addresses" data-secondary="P2SH (pay to script hash)" id="address-p2sh-ch7" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="P2SH (pay to script hash)" id="p2sh-ch7" target="_blank" rel="noopener noreferrer"></a>
introduced in 2012 as a powerful new type of operation that greatly
simplifies the use of complex scripts. To explain the need
for P2SH, let’s look at a practical example.</p>

<p>Mohammed is an electronics importer based in Dubai. Mohammed’s
company uses Bitcoin’s multisignature feature extensively for its
corporate accounts. Multisignature scripts are one of the most common
uses of Bitcoin’s advanced scripting capabilities and are a very
powerful feature. Mohammed’s company
uses a multisignature script for all customer payments.
Any payments made by customers are locked in such
a way that they require at least two signatures to release.  Mohammed,
his three partners, and their attorney can each provide one signature.
A multisignature scheme like that offers corporate governance
controls and protects against theft, embezzlement, or loss.</p>

<p>The resulting script is quite long and looks like this:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">2 &lt;Mohammed's Public Key&gt; &lt;Partner1 Public Key&gt; &lt;Partner2 Public Key&gt;
&lt;Partner3 Public Key&gt; &lt;Attorney Public Key&gt; 5 OP_CHECKMULTISIG</pre></div>

<p>Although multisignature scripts are a powerful feature, they are
cumbersome to use. Given the preceding script, Mohammed would have to
communicate this script to every customer prior to payment. Each
customer would have to use special Bitcoin wallet software with the
ability to create custom transaction scripts.
Furthermore, the resulting transaction would be about five times larger
than a simple payment transaction, because this script contains very
long public keys. The burden of that extra data would be
borne by the customer in the form of extra transaction fees. Finally, a large transaction
script like this would be carried in the UTXO set in every full
node, until it was spent. All of these issues make using complex output scripts
difficult in practice.</p>

<p>P2SH was developed to resolve these practical difficulties and to make
the use of complex scripts as easy as a payment to a single-key Bitcoin address.
With P2SH payments, the complex script is replaced with a
commitment, the digest of a cryptographic hash. When a transaction attempting
to spend the UTXO is presented later, it must contain the script that
matches the commitment in addition to the data that satisfies the script. In simple terms,
P2SH means “pay to a script matching this hash, a script that will be
presented later when this output is spent.”</p>

<p>In P2SH
transactions, the script that is replaced by a hash is <a data-type="indexterm" data-primary="redeem scripts" id="id911" target="_blank" rel="noopener noreferrer"></a>referred
to as the <em>redeem script</em> because it is presented to the system at
redemption time rather than as an output script. <a data-type="xref" href="#without_p2sh" target="_blank" rel="noopener noreferrer">Table&nbsp;7-1</a> shows
the script without P2SH and <a data-type="xref" href="#with_p2sh" target="_blank" rel="noopener noreferrer">Table&nbsp;7-2</a> shows the same script encoded
with P2SH.</p>
<table id="without_p2sh"><caption><span>Table 7-1. </span>Complex script without P2SH</caption><tbody><tr><td><p>Output script</p></td><td><p>2 PubKey1 PubKey2 PubKey3 PubKey4 PubKey5 5 OP_CHECKMULTISIG</p></td></tr><tr><td><p>Input script</p></td><td><p>Sig1 Sig2</p></td></tr></tbody></table>
<table id="with_p2sh"><caption><span>Table 7-2. </span>Complex script as P2SH</caption><tbody><tr><td><p>Redeem script</p></td><td><p>2 PubKey1 PubKey2 PubKey3 PubKey4 PubKey5 5 OP_CHECKMULTISIG</p></td></tr><tr><td><p>Output script</p></td><td><p>OP_HASH160 &lt;20-byte hash of redeem script&gt; OP_EQUAL</p></td></tr><tr><td><p>Input script</p></td><td><p>Sig1 Sig2 &lt;redeem script&gt;</p></td></tr></tbody></table>

<p>As you can see from the tables, with P2SH, the complex script that
details the conditions for spending the output (redeem script) is not
presented in the output script. Instead, only a hash of it is in the
output script, and the redeem script itself is presented later as part
of the input script when the output is spent. This shifts the burden
in fees and complexity from the spender to the receiver of the
transaction.</p>

<p>Let’s look at Mohammed’s company, the complex multisignature script, and
the resulting P2SH scripts.</p>

<p>First, the multisignature script that Mohammed’s company uses for all
incoming payments from customers:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">2 &lt;Mohammed's Public Key&gt; &lt;Partner1 Public Key&gt; &lt;Partner2 Public Key&gt;
&lt;Partner3 Public Key&gt; &lt;Attorney Public Key&gt; 5 OP_CHECKMULTISIG</pre></div>

<p>This entire script can instead be represented by a 20-byte cryptographic
hash by first applying the SHA256 hashing algorithm and then applying
the RIPEMD-160 algorithm on the result.  For example, starting with the
hash of Mohammed’s redeem script:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">54c557e07dde5bb6cb791c7a540e0a4796f5e97e</pre></div>

<p>A P2SH transaction locks the output to this hash instead of the longer
redeem script, using a special output script template:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">OP_HASH160 54c557e07dde5bb6cb791c7a540e0a4796f5e97e OP_EQUAL</pre></div>

<p>which, as you can see, is much shorter. Instead of “pay to this 5-key
multisignature script,” the P2SH equivalent transaction is “pay to a
script with this hash.” A customer making a payment to Mohammed’s
company need only include this much shorter output script in his
payment. When Mohammed and his partners want to spend this UTXO, they
must present the original redeem script (the one whose hash locked the
UTXO) and the signatures necessary to unlock it, like this:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">&lt;Sig1&gt; &lt;Sig2&gt; &lt;2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG&gt;</pre></div>

<p>The two scripts are combined in two stages. First, the redeem script is
checked against the output script to make sure the hash matches:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">&lt;2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG&gt; OP_HASH160 &lt;script hash&gt; OP_EQUAL</pre></div>

<p>If the redeem script hash matches, the redeem script is executed:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">&lt;Sig1&gt; &lt;Sig2&gt; 2 &lt;PK1&gt; &lt;PK2&gt; &lt;PK3&gt; &lt;PK4&gt; &lt;PK5&gt; 5 OP_CHECKMULTISIG</pre></div>








<div id="id411" data-type="sect2" data-pdf-bookmark="P2SH Addresses">
<h2>P2SH Addresses</h2>

<p>Another
important part of the P2SH feature is the ability to encode a script
hash as an address, as defined in BIP13. P2SH addresses are base58check
encodings of the 20-byte hash of a script, just like Bitcoin addresses
are base58check encodings of the 20-byte hash of a public key. P2SH
addresses use the version prefix “5,” which results in
base58check-encoded addresses that start with a “3.”</p>

<p>For example, Mohammed’s complex script, hashed and base58check-encoded
as a P2SH address, becomes <code>39RF6JqABiHdYHkfChV6USGMe6Nsr66Gzw</code>.</p>

<p>Now, Mohammed can give this “address” to his customers, and they can use
almost any Bitcoin wallet to make a simple payment, like any other
Bitcoin address. The 3 prefix gives them a hint that this is a special
type of address, one corresponding to a script instead of a public key,
but otherwise it works in exactly the same way as a payment to any other Bitcoin
address.</p>

<p>P2SH addresses hide all of the complexity so the person making a
payment does not see the script.</p>
</div>








<div id="id412" data-type="sect2" data-pdf-bookmark="Benefits of P2SH">
<h2>Benefits of P2SH</h2>

<p>The P2SH feature
offers the following benefits compared to the direct use of complex
scripts in outputs:</p>

<ul>
<li>
<p>The similarity to original legacy addresses means the sender and the sender’s
wallet don’t need complex engineering to implement P2SH.</p>
</li>
<li>
<p>P2SH shifts the burden in data storage for the long script from the
output (which additionally to being stored on the blockchain is in the
UTXO set) to the input (only stored on the blockchain).</p>
</li>
<li>
<p>P2SH shifts the burden in data storage for the long script from the
present time (payment) to a future time (when it is spent).</p>
</li>
<li>
<p>P2SH shifts the transaction fee cost of a long script from the sender
to the recipient, who has to include the long redeem script to spend
it.</p>
</li>
</ul>
</div>








<div id="id116" data-type="sect2" data-pdf-bookmark="Redeem Script and Validation">
<h2>Redeem Script and Validation</h2>

<p>You are<a data-type="indexterm" data-primary="redeem scripts" data-secondary="validating" id="id912" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="validating" data-secondary="redeem scripts" id="id913" target="_blank" rel="noopener noreferrer"></a> not able to put a P2SH inside a P2SH redeem script because the
P2SH specification is not recursive. Also, while it is technically
possible to include <code>OP_RETURN</code> (see <a data-type="xref" href="#op_return" target="_blank" rel="noopener noreferrer">“Data Recording Output (OP_RETURN)”</a>) in a redeem script, as
nothing in the rules prevents you from doing so, it is of no practical
use because executing <code>OP_RETURN</code> during validation will cause the
transaction to be marked invalid.</p>

<p>Note that because the redeem script is not presented to the network
until you attempt to spend a P2SH output, if you create an output with the
hash of an invalid redeem script, you will not be able to spend
it.  The spending transaction, which includes the redeem script,
will not be accepted because it is an invalid script. This creates a
risk because you can send bitcoin to a P2SH address that cannot be spent later.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>P2SH output scripts
contain the hash of a redeem script, which gives no clues as to
the content of the redeem script. The P2SH output will be
considered valid and accepted even if the redeem script is invalid. You
might accidentally receive bitcoin in such a way that it cannot later<a data-type="indexterm" data-primary="scripts" data-secondary="P2SH (pay to script hash)" data-startref="script-p2sh" id="id914" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="P2SH (pay to script hash)" data-startref="p2sh-ch7" id="id915" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="addresses" data-secondary="P2SH (pay to script hash)" data-startref="address-p2sh-ch7" id="id916" target="_blank" rel="noopener noreferrer"></a> be
spent.</p>
</div>
</div>
</div>






<div id="op_return" data-type="sect1" data-pdf-bookmark="Data Recording Output (OP_RETURN)">
<h2>Data Recording Output (OP_RETURN)</h2>

<p>Bitcoin’s
distributed <a data-type="indexterm" data-primary="scripts" data-secondary="OP_RETURN" id="script-op-return" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="OP_RETURN scripts" id="op-return" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="nonpayment data" id="nonpayment-data" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="blockchain" data-secondary="nonpayment data in" id="blockchain-nonpayment" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="output scripts" data-secondary="OP_RETURN" id="output-script-op-return" target="_blank" rel="noopener noreferrer"></a>and timestamped blockchain has potential uses
beyond payments. Many developers have tried to use the transaction
scripting language to take advantage of the security and resilience of
the system for applications such as digital notary services.
Early attempts to use Bitcoin’s
script language for these purposes involved creating transaction outputs
that recorded data on the blockchain; for example, to record a commitment
to a file in such a way that anyone could establish
proof-of-existence of that file on a specific date by reference to that
transaction.</p>

<p>The use of Bitcoin’s blockchain to store data
unrelated to Bitcoin payments is a controversial subject. Many
people consider such use abusive and want to discourage it. Others
view it as a demonstration of the powerful capabilities of blockchain
technology and want to encourage such experimentation. Those who object
to the inclusion of nonpayment data argue that it
burdens those running full Bitcoin nodes with carrying the
cost of disk storage for data that the blockchain was not intended to
carry. Moreover, such transactions may create UTXOs that cannot be spent,
using a legacy Bitcoin address as a freeform 20-byte field.
Because the address is used for data, it doesn’t correspond to a private
key and the resulting UTXO can <em>never</em> be spent; it’s a fake payment.
These transactions that can never be spent are therefore never removed
from the UTXO set and cause the size of the UTXO database to forever
increase, or “bloat.”</p>

<p>A compromise was reached
that allows an output script starting with <code>OP_RETURN</code> to
add nonpayment data to a transaction output. However, unlike
the use of “fake” UTXOs, the <code>OP_RETURN</code> operator creates an explicitly
<em>provably unspendable</em> output, which does not need to be stored in the
UTXO set. <code>OP_RETURN</code> outputs are recorded on the blockchain, so they
consume disk space and contribute to the increase in the blockchain’s
size, but they are not stored in the UTXO set and therefore do not bloat
full nodes with the cost of more
expensive database operations.</p>

<p><code>OP_RETURN</code> scripts look like this:</p>



<p>The data portion
often represents a hash, such as the output
from the SHA256 algorithm (32 bytes). Some applications put a prefix in
front of the data to help identify the application. For example, the
<a href="https://proofofexistence.com/" target="_blank" rel="noopener noreferrer">Proof of Existence</a> digital notarization
service uses the 8-byte prefix <code>DOCPROOF</code>, which is ASCII encoded as <code>44
4f 43 50 52 4f 4f 46</code> in hexadecimal.</p>

<p>Keep in mind that there is no input script that corresponds to
<code>OP_RETURN</code> that could possibly be used to “spend” an <code>OP_RETURN</code> output. The
whole point of an <code>OP_RETURN</code> output is that you can’t spend the money locked in that
output, and therefore it does not need to be held in the UTXO set as
potentially spendable: <code>OP_RETURN</code> outputs are <em>provably unspendable</em>. <code>OP_RETURN</code> outputs
usually have a zero amount because any bitcoins
assigned to such an output are effectively lost forever. If an <code>OP_RETURN</code> output is
referenced as an input in a transaction, the script validation engine
will halt the execution of the validation script and mark the
transaction as invalid. The execution of <code>OP_RETURN</code> essentially causes the
script to “RETURN” with a <code>FALSE</code> and halt. Thus, if you accidentally
reference an <code>OP_RETURN</code> output as an input in a transaction, that
transaction<a data-type="indexterm" data-primary="scripts" data-secondary="OP_RETURN" data-startref="script-op-return" id="id917" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="OP_RETURN scripts" data-startref="op-return" id="id918" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="nonpayment data" data-startref="nonpayment-data" id="id919" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="blockchain" data-secondary="nonpayment data in" data-startref="blockchain-nonpayment" id="id920" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="output scripts" data-secondary="OP_RETURN" data-startref="output-script-op-return" id="id921" target="_blank" rel="noopener noreferrer"></a> is invalid.</p>








<div id="lock_time_limitations" data-type="sect2" data-pdf-bookmark="Transaction Lock Time Limitations">
<h2>Transaction Lock Time Limitations</h2>

<p>Use of the <a data-type="indexterm" data-primary="transactions" data-secondary="timelocks" data-tertiary="limitations of" id="id922" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="timelocks" data-secondary="limitations of" id="id923" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="lock time" data-secondary="limitations of" id="id924" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="scripts" data-secondary="timelocks" data-tertiary="limitations of" id="id925" target="_blank" rel="noopener noreferrer"></a>lock time allows a spender to restrict a transaction from
being included in a block until a specific block height, but it does not
prevent spending the funds in another transaction earlier than that.
Let’s explain that with the following example.</p>

<p>Alice signs a transaction spending one of her outputs to Bob’s address and sets the transaction lock time to 3 months in the future. Alice sends that transaction to Bob to hold. With this transaction Alice and Bob know that:</p>

<ul>
<li>
<p>Bob cannot transmit the transaction to redeem the funds until 3 months have elapsed.</p>
</li>
<li>
<p>Bob may transmit the transaction after 3 months.</p>
</li>
</ul>

<p>However:</p>

<ul>
<li>
<p>Alice can create a conflicting transaction, spending the same inputs without a lock time. Thus, Alice can spend the same UTXO before the 3 months have elapsed.</p>
</li>
<li>
<p>Bob has no guarantee that Alice won’t do that.</p>
</li>
</ul>

<p>It is important to understand the limitations of transaction lock time. The only guarantee is that Bob will not be able to redeem the presigned transaction before 3 months have elapsed. There is no guarantee that Bob will get the funds. One way to guarantee that Bob will receive the funds but cannot spend them until 3 months have elapsed is to place the timelock restriction on the UTXO itself as part of the script, rather than on the transaction. This is achieved by the next form of timelock, called Check Lock Time Verify.</p>
</div>








<div id="id118" data-type="sect2" data-pdf-bookmark="Check Lock Time Verify (OP_CLTV)">
<h2>Check Lock Time Verify (OP_CLTV)</h2>

<p>In <a data-type="indexterm" data-primary="transactions" data-secondary="timelocks" data-tertiary="verifying" id="transaction-timelock-op-cltv" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="timelocks" data-secondary="verifying" id="timelock-op-cltv" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="lock time" data-secondary="verifying" id="lock-time-op-cltv" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="OP_CLTV  script operator" id="op-cltv" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="verifying" data-secondary="lock time" id="verify-lock-time" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="scripts" data-secondary="timelocks" data-tertiary="verifying" id="script-timelock-verify" target="_blank" rel="noopener noreferrer"></a>December 2015, a new form of
timelock was introduced to Bitcoin as a soft fork upgrade. Based on a
specification in BIP65, a new script operator called
<code>OP_CHECKLOCKTIMEVERIFY</code> (<code>OP_CLTV</code>) was added to the scripting language.
<code>OP_CLTV</code> is a per-output timelock rather than a per-transaction timelock,
as is the case with lock time. This allows for additional
flexibility in the way timelocks are applied.</p>

<p>In simple terms, by committing to the <code>OP_CLTV</code> opcode in an
output, that output is restricted so that it can only be spent after the
specified time has elapsed.</p>

<p><code>OP_CLTV</code> doesn’t replace lock time, but rather restricts specific UTXOs
such that they can only be spent in a future transaction with
lock time set to a greater or equal value.</p>

<p>The <code>OP_CLTV</code> opcode takes one parameter as input, expressed as a number in
the same format as lock time (either a block height or Unix epoch
time). As indicated by the <code>VERIFY</code> suffix, <code>OP_CLTV</code> is the type of opcode
that halts execution of the script if the outcome is <code>FALSE</code>. If it
results in <code>TRUE</code>, execution continues.</p>

<p>In order to use <code>OP_CLTV</code>, you insert it into the redeem script of the
output in the transaction that creates the output. For
example, if Alice is paying Bob, he might usually accept payment to
the following P2SH script:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">&lt;Bob's public key&gt; OP_CHECKSIG</pre></div>

<p>To lock it to a time, say 3 months from now, his P2SH script would
instead be:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">&lt;Bob's pubkey&gt; OP_CHECKSIGVERIFY &lt;now + 3 months&gt; OP_CHECKLOCKTIMEVERIFY</pre></div>

<p>where <code>&lt;now + 3 months&gt;</code> is a block height or time value estimated
3 months from the time the transaction is mined: current block height
+ 12,960 (blocks) or current Unix epoch time + 7,760,000
(seconds).</p>

<p>When Bob tries to spend this UTXO, he constructs a transaction that
references the UTXO as an input. He uses his signature and public key in
the input script of that input and sets the transaction lock time
to be equal or greater to the timelock in the <code>OP_CHECKLOCKTIMEVERIFY</code>
Alice set. Bob then broadcasts the transaction on the Bitcoin network.</p>

<p>Bob’s transaction is evaluated as follows. If the <code>OP_CHECKLOCKTIMEVERIFY</code>
parameter Alice set is less than or equal to the spending transaction’s
lock time, script execution continues (acts as if a <em>no
operation</em> or <code>OP_NOP</code> opcode was executed). Otherwise, script
execution halts and the transaction is deemed invalid.</p>

<p>More precisely, BIP65 explains that <code>OP_CHECKLOCKTIMEVERIFY</code> fails and
halts execution if one of the following occurs:</p>

<ul>
<li>
<p>The stack is empty.</p>
</li>
<li>
<p>The top item on the stack is less than 0.</p>
</li>
<li>
<p>The lock-time type (height versus timestamp) of the top stack item and the lock time field are not the same.</p>
</li>
<li>
<p>The top stack item is greater than the transaction’s lock time field.</p>
</li>
<li>
<p>The sequence field of the input is 0xffffffff.</p>
</li>
</ul>


<p>After execution, if <code>OP_CLTV</code> is satisfied, the parameter that
preceded it remains as the top item on the stack and may need to be
dropped, with <code>OP_DROP</code>, for correct execution of subsequent script
opcodes. You will often see <code>OP_CHECKLOCKTIMEVERIFY</code> followed by <code>OP_DROP</code> in
scripts for this reason.  <code>OP_CLTV</code>, like <code>OP_CSV</code> (see <a data-type="xref" href="#op_csv" target="_blank" rel="noopener noreferrer">“Relative Timelocks”</a>)
are unlike other <code>CHECKVERIFY</code> opcodes in leaving items on the stack
because the soft forks that added them redefined existing opcodes that
did not drop stack items, and the behavior of those previous
no-operation (NOP) opcodes must be preserved.</p>

<p>By using lock time in conjunction with <code>OP_CLTV</code>, the scenario described in
<a data-type="xref" href="#lock_time_limitations" target="_blank" rel="noopener noreferrer">“Transaction Lock Time Limitations”</a> changes.  Alice sends her transaction
immediately, assigning the funds to Bob’s key. Alice can no longer spend
the money, but Bob cannot spend it before the 3-month lock time has
expired.</p>

<p>By introducing timelock functionality directly into the scripting
language, <code>OP_CLTV</code> allows us to develop some very interesting complex
scripts.</p>

<p>The standard<a data-type="indexterm" data-primary="transactions" data-secondary="timelocks" data-tertiary="verifying" data-startref="transaction-timelock-op-cltv" id="id930" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="timelocks" data-secondary="verifying" data-startref="timelock-op-cltv" id="id931" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="lock time" data-secondary="verifying" data-startref="lock-time-op-cltv" id="id932" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="OP_CLTV  script operator" data-startref="op-cltv" id="id933" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="verifying" data-secondary="lock time" data-startref="verify-lock-time" id="id934" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="scripts" data-secondary="timelocks" data-tertiary="verifying" data-startref="script-timelock-verify" id="id935" target="_blank" rel="noopener noreferrer"></a> is defined in
<a href="https://oreil.ly/YmJGD" target="_blank" rel="noopener noreferrer">BIP65
(OP_CHECKLOCKTIMEVERIFY)</a>.</p>
</div>








<div id="op_csv" data-type="sect2" data-pdf-bookmark="Relative Timelocks">
<h2>Relative Timelocks</h2>

<p>Lock time<a data-type="indexterm" data-primary="absolute timelocks" id="id936" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="transactions" data-secondary="timelocks" data-tertiary="relative" id="transaction-timelock-relative" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="timelocks" data-secondary="relative" id="timelock-relative" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="lock time" data-secondary="relative" id="locktime-relative" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="scripts" data-secondary="timelocks" data-tertiary="relative" id="script-timelock-relative" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="relative timelocks" id="relative-timelock2" target="_blank" rel="noopener noreferrer"></a> and <code>OP_CLTV</code> are both
<em>absolute timelocks</em> in that they specify an absolute point in time. The
next two timelock features we will examine are <em>relative timelocks</em> in
that they specify, as a condition of spending an output, an elapsed time
from the confirmation of the output in the blockchain.</p>

<p>Relative timelocks are useful because they allow
imposing a time
constraint on one transaction that is dependent on the elapsed time from
the confirmation of a previous transaction. In other words, the clock
doesn’t start counting until the UTXO is recorded on the blockchain.
This functionality is especially useful in bidirectional state channels
and Lightning Networks (LNs), as we will see in <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch14.html#state_channels" target="_blank" rel="noopener noreferrer">“Payment Channels and State Channels”</a>.</p>

<p>Relative timelocks, like absolute timelocks, are implemented with both a
transaction-level feature and a script-level opcode. The
transaction-level relative timelock is implemented as a consensus rule
on the value of <code>sequence</code>, a transaction field that is set in every
transaction input. Script-level relative timelocks are implemented with
the <code>OP_CHECKSEQUENCEVERIFY</code> (<code>OP_CSV</code>) opcode.</p>

<p>Relative timelocks are
implemented according to the specifications in
<a href="https://oreil.ly/ZuANb" target="_blank" rel="noopener noreferrer">BIP68,
Relative Lock-Time Using Consensus-Enforced Sequence Numbers</a> and
<a href="https://oreil.ly/dLA2r" target="_blank" rel="noopener noreferrer">BIP112,
OP_CHECKSEQUENCEVERIFY</a>.</p>

<p>BIP68 and BIP112 were activated in May 2016 as a soft fork upgrade to
the consensus rules.</p>
</div>








<div id="id120" data-type="sect2" data-pdf-bookmark="Relative Timelocks with OP_CSV">
<h2>Relative Timelocks with OP_CSV</h2>

<p>Just <a data-type="indexterm" data-primary="OP_CSV script opcode" id="op-csv" target="_blank" rel="noopener noreferrer"></a>like <code>OP_CLTV</code>
and lock time, there is a script opcode for relative timelocks that
leverages the sequence value in scripts. That opcode is
<code>OP_CHECKSEQUENCEVERIFY</code>, commonly referred to as <code>OP_CSV</code> for short.</p>

<p>The <code>OP_CSV</code> opcode when evaluated in a UTXO’s script allows
spending only in a transaction whose input sequence value is greater
than or equal to the <code>OP_CSV</code> parameter. Essentially, this restricts
spending the UTXO until a certain number of blocks or seconds have
elapsed relative to the time the UTXO was mined.</p>

<p>As with CLTV, the value in <code>OP_CSV</code> must match the format in the
corresponding sequence value. If <code>OP_CSV</code> is specified in terms of
blocks, then so must sequence. If <code>OP_CSV</code> is specified in terms of
seconds, then so must sequence.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>A script executing multiple <code>OP_CSV</code> opcodes must only use the same
variety, either time-based or height-based.  Mixing varieties will
produce an invalid script that can never be spent, the same problem we
saw with <code>OP_CLTV</code> in <a data-type="xref" href="#timelock_conflicts" target="_blank" rel="noopener noreferrer">“Timelock Conflicts”</a>.  However, <code>OP_CSV</code> allows
any two valid inputs to be included in the same transaction, so the problem
of interaction across inputs that occurs with <code>OP_CLTV</code> doesn’t affect <code>OP_CSV</code>.</p>
</div>

<p>Relative timelocks with <code>OP_CSV</code> are especially useful when several
(chained) transactions are created and signed but not propagated—​that
is, they’re kept off the blockchain (<em>offchain</em>). A child transaction cannot be used until the
parent transaction has been propagated, mined, and aged by the time
specified in the relative timelock. One application of this use case is shown in <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch14.html#state_channels" target="_blank" rel="noopener noreferrer">“Payment Channels and State Channels”</a> and <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch14.html#lightning_network" target="_blank" rel="noopener noreferrer">“Routed Payment Channels (Lightning Network)”</a>.</p>

<p><code>OP_CSV</code> is defined<a data-type="indexterm" data-primary="transactions" data-secondary="timelocks" data-tertiary="relative" data-startref="transaction-timelock-relative" id="id937" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="timelocks" data-secondary="relative" data-startref="timelock-relative" id="id938" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="lock time" data-secondary="relative" data-startref="locktime-relative" id="id939" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="scripts" data-secondary="timelocks" data-tertiary="relative" data-startref="script-timelock-relative" id="id940" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="OP_CSV script opcode" data-startref="op-csv" id="id941" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="relative timelocks" data-startref="relative-timelock2" id="id942" target="_blank" rel="noopener noreferrer"></a> in detail in
<a href="https://oreil.ly/z_Obw" target="_blank" rel="noopener noreferrer">BIP112,
CHECKSEQUENCEVERIFY</a>.</p>
</div>
</div>






<div id="id121" data-type="sect1" data-pdf-bookmark="Scripts with Flow Control (Conditional Clauses)">
<h2>Scripts with Flow Control (Conditional Clauses)</h2>

<p>One of<a data-type="indexterm" data-primary="scripts" data-secondary="flow control" id="script-flow" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="flow control in scripts" id="flow-control-script" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="conditional clauses in scripts" id="conditional-clause-script" target="_blank" rel="noopener noreferrer"></a> the more
powerful features of Bitcoin Script is flow control, also known as
conditional clauses. You are probably familiar with flow control in
various programming languages that use the construct <code>IF…​THEN…​ELSE</code>.
Bitcoin conditional clauses look a bit different but are essentially
the same construct.</p>

<p>At a basic level, Bitcoin conditional opcodes allow us to construct a
script that has two ways of being unlocked, depending on a
<code>TRUE</code>/<code>FALSE</code> outcome of evaluating a logical condition. For example,
if x is <code>TRUE</code>, the executed code path is A and the <code>ELSE</code> code path is B.</p>

<p>Additionally, Bitcoin conditional expressions can be “nested”
indefinitely, meaning that a conditional clause can contain another
within it, which contains another, etc. Bitcoin Script flow control can
be used to construct very complex scripts with hundreds
of possible execution paths. There is no limit to nesting, but
consensus rules impose a limit on the maximum size of a
script in bytes.</p>

<p>Bitcoin implements flow control using the <code>OP_IF</code>, <code>OP_ELSE</code>, <code>OP_ENDIF</code>, and
<code>OP_NOTIF</code> opcodes. Additionally, conditional expressions can contain
boolean operators such as <code>OP_BOOLAND</code>, <code>OP_BOOLOR</code>, and <code>OP_NOT</code>.</p>

<p>At first glance, you may find the Bitcoin’s flow control scripts
confusing. That is because Bitcoin Script is a stack language. The same
way that <code>1 + 1</code> looks “backward” when expressed as <code>1 1 OP_ADD</code>, flow
control clauses in Bitcoin also look “backward.”</p>

<p>In most traditional (procedural) programming languages, flow control
looks like this:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">if (condition):
  code to run when condition is true
else:
  code to run when condition is false
endif
code to run in either case</pre></div>

<p>In a stack-based language like Bitcoin Script, the logical condition
comes before the <code>IF</code>, which makes it look “backward”:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">condition
IF
  code to run when condition is true
OP_ELSE
  code to run when condition is false
OP_ENDIF
code to run in either case</pre></div>

<p>When reading Bitcoin Script, remember that the condition being evaluated
comes <em>before</em> the <code>IF</code> opcode.</p>








<div id="id122" data-type="sect2" data-pdf-bookmark="Conditional Clauses with VERIFY Opcodes">
<h2>Conditional Clauses with VERIFY Opcodes</h2>

<p>Another
form of <a data-type="indexterm" data-primary="VERIFY opcodes" id="id943" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="guard clauses in scripts" id="id944" target="_blank" rel="noopener noreferrer"></a>conditional in Bitcoin Script is any opcode that ends in
<code>VERIFY</code>. The <code>VERIFY</code> suffix means that if the condition evaluated is
not <code>TRUE</code>, execution of the script terminates immediately and the
transaction is deemed invalid.</p>

<p>Unlike an <code>IF</code> clause, which offers alternative
execution paths, the <code>VERIFY</code> suffix acts as a <em>guard clause</em>,
continuing only if a precondition is met.</p>

<p>For example, the following script requires Bob’s signature and a
preimage (secret) that produces a specific hash. Both conditions must
be satisfied to unlock:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">OP_HASH160 &lt;expected hash&gt; OP_EQUALVERIFY &lt;Bob's Pubkey&gt; OP_CHECKSIG</pre></div>

<p>To spend this, Bob must present a
valid preimage and a signature:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">&lt;Bob's Sig&gt; &lt;hash pre-image&gt;</pre></div>

<p>Without presenting the preimage, Bob can’t get to the part of the
script that checks for his signature.</p>

<p>This script can be written with an <code>OP_IF</code> instead:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">OP_HASH160 &lt;expected hash&gt; OP_EQUAL
OP_IF
   &lt;Bob's Pubkey&gt; OP_CHECKSIG
OP_ENDIF</pre></div>

<p>Bob’s authentication data is identical:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">&lt;Bob's Sig&gt; &lt;hash pre-image&gt;</pre></div>

<p>The script with <code>OP_IF</code> does the same thing as using an opcode with a
<code>VERIFY</code> suffix; they both operate as guard clauses. However, the
<code>VERIFY</code> construction is more efficient, using two fewer opcodes.</p>

<p>So, when do we use <code>VERIFY</code> and when do we use <code>OP_IF</code>? If all we are
trying to do is to attach a precondition (guard clause), then <code>VERIFY</code>
is better. If, however, we want to have more than one execution path
(flow control), then we need an <code>OP_IF…​OP_ELSE</code> flow control clause.</p>
</div>








<div id="id123" data-type="sect2" data-pdf-bookmark="Using Flow Control in Scripts">
<h2>Using Flow Control in Scripts</h2>

<p>A very common use for flow control in Bitcoin Script is to construct a
script that offers multiple execution paths, each a different way
of redeeming the UTXO.</p>

<p>Let’s look at a simple example where
we have two signers, Alice and Bob, and either one is able to redeem.
With multisig, this would be expressed as a 1-of-2 multisig script. For
the sake of demonstration, we will do the same thing with an <code>OP_IF</code>
clause:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">OP_IF
 &lt;Alice's Pubkey&gt;
OP_ELSE
 &lt;Bob's Pubkey&gt;
OP_ENDIF
OP_CHECKSIG</pre></div>

<p>Looking at this redeem script, you may be wondering: “Where is the
condition? There is nothing preceding the <code>IF</code> clause!”</p>

<p>The condition is not part of the script. Instead, the condition
will be offered at spending time, allowing Alice and Bob to
“choose” which execution path they want:</p>



<p>The <code>OP_TRUE</code> at the end serves as the condition (<code>TRUE</code>) that will make
the <code>OP_IF</code> clause execute the fist redemption path.  This conditions
puts the public key on the stack for which Alice has a signature.
The <code>OP_TRUE</code> opcode, also known as <code>OP_1</code>, will put the
number 1 on the stack.</p>

<p>For Bob to redeem this, he would have to choose the second execution
path in <code>OP_IF</code> by giving a <code>FALSE</code> value.  The <code>OP_FALSE</code> opcode, also
known as <code>OP_0</code>, pushes an empty byte array to the stack:</p>



<p>Bob’s input script causes the <code>OP_IF</code> clause
to execute the second (<code>OP_ELSE</code>) script, which requires Bob’s signature.</p>

<p>Since <code>OP_IF</code> clauses can be nested, we can create a “maze” of execution
paths. The input script can provide a “map” selecting which
execution path is actually executed:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">OP_IF
  subscript A
OP_ELSE
  OP_IF
    subscript B
  OP_ELSE
    subscript C
  OP_ENDIF
OP_ENDIF</pre></div>

<p>In this scenario, there are three execution paths (<code>subscript A</code>, <code>subscript
B</code>, and <code>subscript C</code>). The input script provides a path in the form of
a sequence of <code>TRUE</code> or <code>FALSE</code> values. To select path <code>subscript B</code>, for
example, the input script must end in <code>OP_1 OP_0</code> (<code>TRUE</code>, <code>FALSE</code>). These
values will be pushed onto the stack so that the second value (<code>FALSE</code>)
ends up at the top of the stack. The outer <code>OP_IF</code> clause pops the <code>FALSE</code>
value and executes the first <code>OP_ELSE</code> clause. Then the <code>TRUE</code> value moves
to the top of the stack and is evaluated by the inner (nested) <code>OP_IF</code>,
selecting the <code>B</code> execution path.</p>

<p>Using this construct, we can build redeem scripts with tens or hundreds
of execution paths, each offering a different way to redeem the UTXO. To
spend, we construct an input script that navigates the execution
path by putting the appropriate <code>TRUE</code> and <code>FALSE</code> values on the stack
at each flow control<a data-type="indexterm" data-primary="scripts" data-secondary="flow control" data-startref="script-flow" id="id945" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="flow control in scripts" data-startref="flow-control-script" id="id946" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="conditional clauses in scripts" data-startref="conditional-clause-script" id="id947" target="_blank" rel="noopener noreferrer"></a> point.</p>
</div>
</div>






<div id="id255" data-type="sect1" data-pdf-bookmark="Complex Script Example">
<h2>Complex Script Example</h2>

<p>In this<a data-type="indexterm" data-primary="scripts" data-secondary="examples of" id="script-example-complex" target="_blank" rel="noopener noreferrer"></a> section we combine many of
the concepts from this chapter into a single example.</p>

<p>Mohammed, a company owner in Dubai, operates an import/export
business; he
wishes to construct a company capital account with flexible rules. The
scheme he creates requires different levels of authorization depending
on timelocks. The participants in the multisig scheme are Mohammed, his
two partners Saeed and Zaira, and their company lawyer. The three
partners make decisions based on a majority rule, so two of the three
must agree. However, in the case of a problem with their keys, they want
their lawyer to be able to recover the funds with one of the three
partner signatures. Finally, if all partners are unavailable or
incapacitated for a while, they want the lawyer to be able to manage the
account directly after he gains access to the capital account’s
transaction records.</p>

<p><a data-type="xref" href="#variable_timelock_multisig" target="_blank" rel="noopener noreferrer">Example&nbsp;7-1</a> is the redeem script that Mohammed designs to achieve this (line
numbers have been prefixed).</p>
<div id="variable_timelock_multisig" data-type="example">
<h5><span>Example 7-1. </span>Variable multi-signature with timelock</h5>

<div data-testid="custom pre block"><pre data-type="programlisting">01  OP_IF
02    OP_IF
03      2
04    OP_ELSE
05      &lt;30 days&gt; OP_CHECKSEQUENCEVERIFY OP_DROP
06      &lt;Lawyer's Pubkey&gt; OP_CHECKSIGVERIFY
07      1
08    OP_ENDIF
09    &lt;Mohammed's Pubkey&gt; &lt;Saeed's Pubkey&gt; &lt;Zaira's Pubkey&gt; 3 OP_CHECKMULTISIG
10  OP_ELSE
11    &lt;90 days&gt; OP_CHECKSEQUENCEVERIFY OP_DROP
12    &lt;Lawyer's Pubkey&gt; OP_CHECKSIG
13  OP_ENDIF</pre></div></div>

<p>Mohammed’s script implements three execution paths using nested
<code>OP_IF…​OP_ELSE</code> flow control clauses.</p>

<p>In the first execution path, this script operates as a simple 2-of-3
multisig with the three partners. This execution path consists of lines
3 and 9. Line 3 sets the quorum of the multisig to <code>2</code> (2-of-3). This
execution path can be selected by putting <code>OP_TRUE OP_TRUE</code> at the end of the
input script:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">OP_0 &lt;Mohammed's Sig&gt; &lt;Zaira's Sig&gt; OP_TRUE OP_TRUE</pre></div>
<div data-type="tip"><h6>Tip</h6>
<p>The <code>OP_0</code> at the beginning of this input script is because of an oddity in
<code>OP_CHECKMULTISIG</code> that pops an extra value from the stack. The extra value
is disregarded by the <code>OP_CHECKMULTISIG</code>, but it must be present or the
script fails. Pushing an empty byte array with <code>OP_0</code> is a workaround to the oddity, as
described in <a data-type="xref" href="#multisig_bug" target="_blank" rel="noopener noreferrer">“An Oddity in CHECKMULTISIG Execution”</a>.</p>
</div>

<p>The second execution path can only be used after 30 days have elapsed
from the creation of the UTXO. At that time, it requires the signature
of the lawyer and one of the three partners (a 1-of-3 multisig).
This is achieved by line 7, which sets the quorum for the multisig to
<code>1</code>. To select this execution path, the input script would end in
<code>OP_FALSE OP_TRUE</code>:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">OP_0 &lt;Saeed's Sig&gt; &lt;Lawer's Sig&gt; OP_FALSE OP_TRUE</pre></div>
<div data-type="tip"><h6>Tip</h6>
<p>Why <code>OP_FALSE OP_TRUE</code>? Isn’t that backward? <code>FALSE</code> is pushed onto the
stack, and <code>TRUE</code> is pushed on top of it.
<code>TRUE</code> is therefore popped <em>first</em> by the first <code>OP_IF</code> opcode.</p>
</div>

<p>Finally, the third execution path allows the lawyer to spend the
funds alone, but only after 90 days. To select this execution path, the
input script has to end in <code>OP_FALSE</code>:</p>



<p>Try running the script on paper to see how it behaves on the stack.</p>








<div id="id256" data-type="sect2" data-pdf-bookmark="Segregated Witness Output and Transaction Examples">
<h2>Segregated Witness Output and Transaction Examples</h2>

<p>Let’s look at <a data-type="indexterm" data-primary="scripts" data-secondary="segregated witness" id="script-segwit" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="segregated witness (segwit)" data-secondary="scripts and" id="segwit-script" target="_blank" rel="noopener noreferrer"></a>some of our example transactions and see how they would
change with segregated witness. We’ll first look at how a
 P2PKH payment can be accomplished as the
segregated witness program. Then, we’ll look at the segregated witness
equivalent for P2SH scripts. Finally, we’ll look at
how both of the preceding segregated witness programs can be embedded
inside a P2SH script.</p>










<div id="p2wpkh" data-type="sect3" data-pdf-bookmark="Pay to witness public key hash (P2WPKH)">
<h3>Pay to witness public key hash (P2WPKH)</h3>

<p>Let’s start <a data-type="indexterm" data-primary="scripts" data-secondary="segregated witness" data-tertiary="P2WPKH" id="script-segwit-p2wpkh" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="segregated witness (segwit)" data-secondary="scripts and" data-tertiary="P2WPKH" id="segwit-script-p2wpkh" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="P2WPKH (pay to witness public key hash)" id="p2wpkh-ch7" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="output scripts" data-secondary="P2WPKH (pay to witness public key hash)" id="output-script-p2wpkh" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="addresses" data-secondary="P2WPKH (pay to witness public key hash)" id="address-p2wpkh" target="_blank" rel="noopener noreferrer"></a>by looking at the example of a P2PKH
output script:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7
OP_EQUALVERIFY OP_CHECKSIG</pre></div>

<p>With segregated witness, Alice would create a
P2WPKH script.  If that script commits
to the same public key, it would look like this:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">0 ab68025513c3dbd2f7b92a94e0581f5d50f654e7</pre></div>

<p>As you can see, a P2WPKH output script is much
simpler than the P2PKH equivalent. It consists of two values that are
pushed onto the script evaluation stack. To an old (nonsegwit-aware)
Bitcoin client, the two pushes would look like an output that anyone can
spend. To a newer, segwit-aware client, the first number (0)
is interpreted as a version number (the <em>witness version</em>) and the
second part (20 bytes) is a
<em>witness program</em>. The 20-byte witness program is simply the hash of the
public key, as in a P2PKH script.</p>

<p>Now, let’s look at the corresponding transaction that Bob uses to spend
this output. For the original script, the spending transaction
would have to include a signature within the transaction input:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">[...]
"vin" : [
  "txid": "abcdef12345...",
  "vout": 0,
  "scriptSig": “&lt;Bob’s scriptSig&gt;”,
]
[...]</pre></div>

<p>However, to spend the P2WPKH output, the transaction has no
signature on that input. Instead, Bob’s transaction has an empty
input script and includes a witness structure:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">[...]
"vin" : [
  "txid": "abcdef12345...",
  "vout": 0,
  "scriptSig": “”,
]
[...]
“witness”: “&lt;Bob’s witness structure&gt;”
[...]</pre></div>
</div>










<div id="id257" data-type="sect3" data-pdf-bookmark="Wallet construction of P2WPKH">
<h3>Wallet construction of P2WPKH</h3>

<p>It is extremely<a data-type="indexterm" data-primary="wallets" data-secondary="P2WPKH (pay to witness public key hash)" id="id948" target="_blank" rel="noopener noreferrer"></a> important to note that P2WPKH witness programs should only be created by
the receiver and not converted by the spender from a known
public key, P2PKH script, or address. The spender has no way of knowing
if the receiver’s wallet has the ability to construct segwit
transactions and spend P2WPKH outputs.</p>

<p>Additionally, P2WPKH outputs must be constructed from the hash of a
<em>compressed</em> public key. Uncompressed public keys are nonstandard in
segwit and may be explicitly disabled by a future soft fork. If the hash
used in the P2WPKH came from an uncompressed public key, it may be
unspendable and you may lose funds. P2WPKH outputs should be created by
the payee’s wallet by deriving a compressed public key from their
private key.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>P2WPKH should be constructed by the receiver by converting a compressed
public key to a P2WPKH hash. Neither the spender nor anyone else should
ever transform a P2PKH script, Bitcoin address, or uncompressed public
key to a P2WPKH witness script.  In general, a spender should only send
to the receiver in the manner that the receiver indicated.</p>
</div>
</div>










<div id="p2wsh" data-type="sect3" data-pdf-bookmark="Pay to witness script hash (P2WSH)">
<h3>Pay to witness script hash (P2WSH)</h3>

<p>The <a data-type="indexterm" data-primary="scripts" data-secondary="segregated witness" data-tertiary="P2WSH" id="script-segwit-p2wsh" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="segregated witness (segwit)" data-secondary="scripts and" data-tertiary="P2WSH" id="segwit-script-p2wsh" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="P2WSH (pay to witness script hash)" id="p2wsh-ch7" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="output scripts" data-secondary="P2WSH (pay to witness script hash)" id="output-script-p2wsh" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="addresses" data-secondary="P2WSH (pay to witness script hash)" id="address-p2wsh" target="_blank" rel="noopener noreferrer"></a>second type of
segwit v0 witness program corresponds to a P2SH script. We
saw this type of script in <a data-type="xref" href="#p2sh" target="_blank" rel="noopener noreferrer">“Pay to Script Hash”</a>. In that example, P2SH was used by
Mohammed’s company to express a multisignature script. Payments to
Mohammed’s company were encoded with a script like this:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">OP_HASH160 54c557e07dde5bb6cb791c7a540e0a4796f5e97e OP_EQUAL</pre></div>

<p>This P2SH script references the hash of a <em>redeem script</em> that defines a
2-of-3 multisignature requirement to spend funds. To spend this output,
Mohammed’s company would present the redeem script (whose hash matches
the script hash in the P2SH output) and the signatures necessary to
satisfy that redeem script, all inside the transaction input:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">[...]
"vin" : [
  "txid": "abcdef12345...",
  "vout": 0,
  "scriptSig": “&lt;SigA&gt; &lt;SigB&gt; &lt;2 PubA PubB PubC PubD PubE 5 OP_CHECKMULTISIG&gt;”,
]</pre></div>

<p>Now, let’s look at how this entire example would be upgraded to segwit v0.
If Mohammed’s customers were using a segwit-compatible wallet, they
would make a payment, creating a P2WSH output that would look like this:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">0 a9b7b38d972cabc7961dbfbcb841ad4508d133c47ba87457b4a0e8aae86dbb89</pre></div>

<p>Again, as with the example of P2WPKH, you can see that the segregated
witness equivalent script is a lot simpler and reduces the template
overhead that you see in P2SH scripts. Instead, the segregated witness
output script consists of two values pushed to the stack: a witness version
(0) and the 32-byte SHA256 hash of the witness script (the witness
program).</p>
<div data-type="tip"><h6>Tip</h6>
<p>While P2SH uses the 20-byte <code>RIPEMD160(SHA256(script))</code> hash, the P2WSH
witness program uses a 32-byte <code>SHA256(script)</code> hash. This difference in
the selection of the hashing algorithm is deliberate
to provide stronger security to
P2WSH in certain use cases (128 bits of security in P2WSH versus 80 bits
of security in P2SH).  For details, see <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch04.html#p2sh_collision_attacks" target="_blank" rel="noopener noreferrer">“P2SH Collision Attacks”</a>.</p>
</div>

<p>Mohammed’s company can spend the P2WSH output by presenting the
correct witness script and sufficient signatures to satisfy it. The
witness script and the signatures would be
included as part of the witness structure. No data would be placed in the
input script because this is a native witness program, which does not use
the legacy input script field:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">[...]
"vin" : [
  "txid": "abcdef12345...",
  "vout": 0,
  "scriptSig": “”,
]
[...]
“witness”: “&lt;SigA&gt; &lt;SigB&gt; &lt;2 PubA PubB PubC PubD PubE 5 OP_CHECKMULTISIG&gt;”
[...]</pre></div>
</div>










<div id="id126" data-type="sect3" data-pdf-bookmark="Differentiating between P2WPKH and P2WSH">
<h3>Differentiating between P2WPKH and P2WSH</h3>

<p>In the<a data-type="indexterm" data-primary="scripts" data-secondary="segregated witness" data-tertiary="P2WPKH" data-startref="script-segwit-p2wpkh" id="id949" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="segregated witness (segwit)" data-secondary="scripts and" data-tertiary="P2WPKH" data-startref="segwit-script-p2wpkh" id="id950" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="P2WPKH (pay to witness public key hash)" data-startref="p2wpkh-ch7" id="id951" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="output scripts" data-secondary="P2WPKH (pay to witness public key hash)" data-startref="output-script-p2wpkh" id="id952" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="addresses" data-secondary="P2WPKH (pay to witness public key hash)" data-startref="address-p2wpkh" id="id953" target="_blank" rel="noopener noreferrer"></a> previous two sections, we demonstrated two types of witness
programs: <a data-type="xref" href="#p2wpkh" target="_blank" rel="noopener noreferrer">“Pay to witness public key hash (P2WPKH)”</a> and <a data-type="xref" href="#p2wsh" target="_blank" rel="noopener noreferrer">“Pay to witness script hash (P2WSH)”</a>. Both types of witness programs
consist of the same version number followed by a data push. They
look very similar, but are interpreted very differently: one is
interpreted as a public key hash, which is satisfied by a signature and
the other as a script hash, which is satisfied by a witness script. The
critical difference between them is the length of the witness program:</p>

<ul>
<li>
<p>The witness program in P2WPKH is 20 bytes.</p>
</li>
<li>
<p>The witness program in P2WSH is 32 bytes.</p>
</li>
</ul>

<p>This is the one difference that allows a full node to differentiate between
the two types of witness programs. By looking at the length of the hash,
a node can determine what type of witness program it is, P2WPKH <a data-type="indexterm" data-primary="P2WSH (pay to witness script hash)" data-startref="p2wsh-ch7" id="id954" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="output scripts" data-secondary="P2WSH (pay to witness script hash)" data-startref="output-script-p2wsh" id="id955" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="addresses" data-secondary="P2WSH (pay to witness script hash)" data-startref="address-p2wsh" id="id956" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="scripts" data-secondary="segregated witness" data-tertiary="P2WSH" data-startref="script-segwit-p2wsh" id="id957" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="segregated witness (segwit)" data-secondary="scripts and" data-tertiary="P2WSH" data-startref="segwit-script-p2wsh" id="id958" target="_blank" rel="noopener noreferrer"></a>or
P2WSH.</p>
</div>
</div>








<div id="id127" data-type="sect2" data-pdf-bookmark="Upgrading to Segregated Witness">
<h2>Upgrading to Segregated Witness</h2>

<p>As we <a data-type="indexterm" data-primary="scripts" data-secondary="segregated witness" data-tertiary="upgrading to" id="script-segwit-upgrade" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="segregated witness (segwit)" data-secondary="scripts and" data-tertiary="upgrading to" id="segwit-script-upgrade" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="upgrading to segregated witness" id="upgrade-segwit" target="_blank" rel="noopener noreferrer"></a>can see from the previous examples, upgrading to segregated
witness is a two-step process. First, wallets must create segwit
type outputs. Then, these outputs can be spent by wallets that know how
to construct segregated witness transactions. In the examples, Alice’s
wallet is able to create outputs paying
segregated witness output scripts. Bob’s wallet is also segwit-aware and able
to spend those outputs.</p>

<p>Segregated witness was implemented as a
backward-compatible upgrade, where <em>old and new clients can coexist</em>.
Wallet developers independently upgraded wallet software to add
segwit capabilities.
Legacy P2PKH and
P2SH continue to work for 
<span>nonupgraded</span> wallets. That leaves two
important scenarios, which are addressed in the next section:</p>

<ul>
<li>
<p>Ability of a spender’s wallet that is not segwit-aware to make a
payment to a recipient’s wallet that can process segwit transactions.</p>
</li>
<li>
<p>Ability of a spender’s wallet that is segwit-aware to recognize and
distinguish between recipients that are segwit-aware and ones that are
not, by their <em>addresses</em>.</p>
</li>
</ul>










<div id="id128" data-type="sect3" data-pdf-bookmark="Embedding segregated witness inside P2SH">
<h3>Embedding segregated witness inside P2SH</h3>

<p>Let’s assume,<a data-type="indexterm" data-primary="embedded segregated witness" id="id959" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="P2SH (pay to script hash)" data-secondary="embedded segregated witness" id="id960" target="_blank" rel="noopener noreferrer"></a> for example, that Alice’s wallet is not upgraded to
segwit, but Bob’s wallet is upgraded and can handle segwit transactions.
Alice and Bob can use legacy non-segwit outputs. But Bob would
likely want to use segwit to reduce transaction fees, taking advantage
of the reduced cost of witness structure.</p>

<p>In this case, Bob’s wallet can construct a P2SH address that contains a
segwit script inside it. Alice’s wallet can make payments to it without
any knowledge of segwit.
Bob’s wallet can then spend this payment with a segwit transaction,
taking advantage of segwit and reducing transaction fees.</p>

<p>Both forms of witness scripts, P2WPKH and P2WSH, can be embedded in a
P2SH address. The first is noted as nested P2WPKH, and the second is noted
as nested P2WSH.</p>
</div>










<div id="id258" data-type="sect3" data-pdf-bookmark="Nested pay to witness public key hash">
<h3>Nested pay to witness public key hash</h3>

<p>The first<a data-type="indexterm" data-primary="P2WPKH (pay to witness public key hash)" data-secondary="nesting" id="p2wpkh-nest" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="nesting" data-secondary="P2WPKH (pay to witness public key hash)" id="nest-p2wpkh-ch7" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="addresses" data-secondary="P2WPKH (pay to witness public key hash)" data-tertiary="nesting" id="address-p2wpkh-nest" target="_blank" rel="noopener noreferrer"></a> form of output script we will examine is nested P2WPKH. This
is a pay to witness public key hash witness program, embedded inside a
pay to script hash script, so that a wallet that is
not aware of segwit can pay the output script.</p>

<p>Bob’s wallet constructs a P2WPKH witness program with Bob’s public key.
This witness program is then hashed and the resulting hash is encoded as
a P2SH script. The P2SH script is converted to a Bitcoin address, one
that starts with a “3,” as we saw in <a data-type="xref" href="#p2sh" target="_blank" rel="noopener noreferrer">“Pay to Script Hash”</a>.</p>

<p>Bob’s wallet starts with the P2WPKH witness version and witness program we saw earlier:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">0 ab68025513c3dbd2f7b92a94e0581f5d50f654e7</pre></div>

<p>The data consists of the witness version and Bob’s
20-byte public key hash.</p>

<p>Bob’s wallet then hashes the data, first with
SHA256, then with RIPEMD-160, producing another 20-byte hash.
Next, the redeem script hash is converted to a Bitcoin address.
Finally, Alice’s wallet can make a payment to
<code>37Lx99uaGn5avKBxiW26HjedQE3LrDCZru</code>, just as it would to any other
Bitcoin address.</p>

<p>To pay Bob, Alice’s wallet would lock the output with a P2SH script:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">OP_HASH160 3e0547268b3b19288b3adef9719ec8659f4b2b0b OP_EQUAL</pre></div>

<p>Even though Alice’s wallet has no support for segwit, the payment it
creates can be spent by Bob with a segwit <a data-type="indexterm" data-primary="P2WPKH (pay to witness public key hash)" data-secondary="nesting" data-startref="p2wpkh-nest" id="id961" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="nesting" data-secondary="P2WPKH (pay to witness public key hash)" data-startref="nest-p2wpkh-ch7" id="id962" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="addresses" data-secondary="P2WPKH (pay to witness public key hash)" data-tertiary="nesting" data-startref="address-p2wpkh-nest" id="id963" target="_blank" rel="noopener noreferrer"></a>transaction.</p>
</div>










<div id="id129" data-type="sect3" data-pdf-bookmark="Nested pay to witness script hash">
<h3>Nested pay to witness script hash</h3>

<p>Similarly, <a data-type="indexterm" data-primary="P2WSH (pay to witness script hash)" data-secondary="nesting" id="p2wsh-nest" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="nesting" data-secondary="P2WSH (pay to witness script hash)" id="nest-p2wsh-ch7" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="addresses" data-secondary="P2WSH (pay to witness script hash)" data-tertiary="nesting" id="address-p2wsh-nest" target="_blank" rel="noopener noreferrer"></a>a P2WSH witness program for a multisig script or other
complicated script can be embedded inside a P2SH script and address,
making it possible for any wallet to make payments that are segwit
compatible.</p>

<p>As we saw in <a data-type="xref" href="#p2wsh" target="_blank" rel="noopener noreferrer">“Pay to witness script hash (P2WSH)”</a>, Mohammed’s company is using segregated witness payments to
multisignature scripts. To make it possible for any client to pay his
company, regardless of whether their wallets are upgraded for segwit,
Mohammed’s wallet can embed the P2WSH witness program inside a P2SH
script.</p>

<p>First, Mohammed’s wallet hashes the witness script with SHA256 (just
once), producing the hash:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">9592d601848d04b172905e0ddb0adde59f1590f1e553ffc81ddc4b0ed927dd73</pre></div>

<p>Next, the hashed witness script is turned into a version-prefixed P2WSH witness program:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">0 9592d601848d04b172905e0ddb0adde59f1590f1e553ffc81ddc4b0ed927dd73</pre></div>

<p>Then, the witness program itself is hashed with SHA256 and RIPEMD-160,
producing a new 20-byte hash:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">86762607e8fe87c0c37740cddee880988b9455b2</pre></div>

<p>Next, the wallet constructs a P2SH Bitcoin address from this hash:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">3Dwz1MXhM6EfFoJChHCxh1jWHb8GQqRenG</pre></div>

<p>Now, Mohammed’s clients can make payments to this address even if they
don’t support segwit. To send a payment to Mohammed, a wallet would
lock the output with the following P2SH script:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">OP_HASH160 86762607e8fe87c0c37740cddee880988b9455b2 OP_EQUAL</pre></div>

<p>Mohammed’s company can then construct segwit transactions to spend these
payments, taking advantage of segwit features including <a data-type="indexterm" data-primary="scripts" data-secondary="examples of" data-startref="script-example-complex" id="id964" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="scripts" data-secondary="segregated witness" data-startref="script-segwit" id="id965" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="segregated witness (segwit)" data-secondary="scripts and" data-startref="segwit-script" id="id966" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="scripts" data-secondary="segregated witness" data-tertiary="upgrading to" data-startref="script-segwit-upgrade" id="id967" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="segregated witness (segwit)" data-secondary="scripts and" data-tertiary="upgrading to" data-startref="segwit-script-upgrade" id="id968" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="upgrading to segregated witness" data-startref="upgrade-segwit" id="id969" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="P2WSH (pay to witness script hash)" data-secondary="nesting" data-startref="p2wsh-nest" id="id970" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="nesting" data-secondary="P2WSH (pay to witness script hash)" data-startref="nest-p2wsh-ch7" id="id971" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="addresses" data-secondary="P2WSH (pay to witness script hash)" data-tertiary="nesting" data-startref="address-p2wsh-nest" id="id972" target="_blank" rel="noopener noreferrer"></a>lower
transaction fees.</p>
</div>
</div>
</div>






<div id="mast" data-type="sect1" data-pdf-bookmark="Merklized Alternative Script Trees (MAST)">
<h2>Merklized Alternative Script Trees (MAST)</h2>

<p>Using <code>OP_IF</code>, you <a data-type="indexterm" data-primary="scripts" data-secondary="MAST" id="script-mast" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="MAST (merklized alternative script trees)" id="mast-ch7" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="merkle trees" data-secondary="MAST" id="merkle-tree-mast" target="_blank" rel="noopener noreferrer"></a>can authorize multiple different spending conditions,
but this approach has several undesirable aspects:</p>
<dl>
<dt>Weight (cost)</dt>
<dd>
<p>Every condition you add increases the size of the
  script, increasing the weight of the transaction and the amount of fee
  that will need to be paid in order to spend bitcoins protected by
  that script.</p>
</dd>
<dt>Limited size</dt>
<dd>
<p>Even if you’re willing to pay for extra conditions,
  there’s a limit to the maximum number you can put in a script.  For
  example, legacy script is limited to 10,000 bytes, practically
  limiting you to a few hundred conditional branches at most.  Even if
  you could create a script as large as an entire block, it could still
  only contain about 20,000 useful branches.  That’s a lot for simple
  payments but tiny compared to some imagined uses of Bitcoin.</p>
</dd>
<dt>Lack of privacy</dt>
<dd>
<p>Every condition you add to your script becomes
  public knowledge when you spend bitcoins protected by that script.
  For example, Mohammed’s lawyer and business partners will be able to
  see the entire script in <a data-type="xref" href="#variable_timelock_multisig" target="_blank" rel="noopener noreferrer">Example&nbsp;7-1</a> whenever
  anyone spends from it.  That means their lawyer, even if he’s not
  needed for signing, will be able to track all of their transactions.</p>
</dd>
</dl>

<p>However, Bitcoin already uses a data structure known as a merkle tree
that allows verifying an element is a member of a set without
needing to identify every other member of the set.</p>

<p>We’ll learn more about merkle trees in <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch11.html#merkle_trees" target="_blank" rel="noopener noreferrer">“Merkle Trees”</a>, but the
essential information is that members of the set of data we want
(e.g., authorization conditions of any length) can be passed into a hash
function to create a short commitment (called a <em>leaf</em> of the merkle
tree).  Each of those leaves is then paired with another leaf
and hashed again, creating a commitment to the leaves, called a
<em>branch</em> commitment.  A commitment to a pair of branches can be created
the same way.  This step is repeated for the branches until only one
identifier remains, called the <em>merkle root</em>.  Using our example script
from <a data-type="xref" href="#variable_timelock_multisig" target="_blank" rel="noopener noreferrer">Example&nbsp;7-1</a>, we construct a merkle tree for each
of the three authorization conditions in <a data-type="xref" href="#diagram_mast1" target="_blank" rel="noopener noreferrer">Figure&nbsp;7-5</a>.</p>

<figure><div id="diagram_mast1">
<p><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098150082/files/assets/mbc3_0705.png" alt="" width="600" height="261"></p><h6><span>Figure 7-5. </span>A MAST with three subscripts.</h6>
</div></figure>

<p>We can now create a compact membership proof that proves a particular
authorization condition is a member of the merkle tree without
disclosing any details about the other members of the merkle tree.  See
<a data-type="xref" href="#diagram_mast2" target="_blank" rel="noopener noreferrer">Figure&nbsp;7-6</a>, and note that the shaded nodes can be
computed from other data provided by the user, so they don’t need to be
specified at spend time.</p>

<figure><div id="diagram_mast2">
<p><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098150082/files/assets/mbc3_0706.png" alt="" width="600" height="614"></p><h6><span>Figure 7-6. </span>A MAST membership proof for one of the subscripts.</h6>
</div></figure>

<p>The hash digests used to create the commitments are each 32 bytes, so
proving that a spend of <a data-type="xref" href="#diagram_mast2" target="_blank" rel="noopener noreferrer">Figure&nbsp;7-6</a> is authorized (using a merkle tree and the
particular conditions) and authenticated (using signatures) uses 383
bytes.  By comparison, the same spend without a merkle tree (i.e., providing all possible authorization conditions) uses 412 bytes.</p>

<p>Saving 29 bytes (7%) in this example doesn’t fully
capture the potential savings.  The binary-tree nature of a merkle tree
means that you only need an additional 32-byte commitment every time
you double the number of members in the set (in this case, authorization
conditions).  In this instance, with three conditions, we need to use three
commitments (one of them being the merkle root, which will need to be
included in the authorization data); we could also have four
commitments for the same cost.  An extra commitment would give us up to
eight conditions.  With just 16 commitments—​512 bytes of commitments—​we could have
over 32,000 authorization conditions, far more than could be effectively
used in an entire block of transactions filled with <code>OP_IF</code> statements.  With 128 commitments
(4,096 bytes), the number of conditions we could create in theory far
exceeds the number of conditions that all the computers in the world
could create.</p>

<p>It’s commonly the case that not every authorization condition is equally
as likely to be used.  In the our example case, we expect Mohammed and
his partners to spend their money frequently; the time delayed
conditions only exist in case something goes wrong.  We can restructure
our tree with this knowledge as shown in <a data-type="xref" href="#diagram_mast3" target="_blank" rel="noopener noreferrer">Figure&nbsp;7-7</a>.</p>

<figure><div id="diagram_mast3">
<p><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098150082/files/assets/mbc3_0707.png" alt="" width="600" height="261"></p><h6><span>Figure 7-7. </span>A MAST with the most-expected script in the best position.</h6>
</div></figure>

<p>Now we only need to provide two commitments for the common case (saving 32
bytes), although we still need three commitments for the less common cases.
If you know (or can guess) the probabilities of
using the different authorization conditions, you can use the Huffman
algorithm to place them into a maximally efficient tree; see BIP341 for
details.</p>

<p>Regardless of how the tree is constructed, we can see in the previous
examples that we’re only revealing the actual authorization conditions
that get used.  The other conditions remain private.  Also remaining
private are the number of conditions: a tree could have a single condition
or a trillion conditions—​there’s no way for someone looking only at the
onchain data for a single transaction to tell.</p>

<p>Except for increasing the complexity of Bitcoin slightly, there are no
significant downsides of MAST for Bitcoin and there were two solid
proposals for it, BIP114 and BIP116, before an improved approach was
discovered, which we’ll see in <a data-type="xref" href="#taproot" target="_blank" rel="noopener noreferrer">“Taproot”</a>.</p>

</div>






<div id="pay_to_contract" data-type="sect1" data-pdf-bookmark="Pay to Contract (P2C)">
<h2>Pay to Contract (P2C)</h2>

<p>As we<a data-type="indexterm" data-primary="P2C (pay to contract)" id="p2c" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="key tweaks" id="key-tweak" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="public key cryptography" data-secondary="key tweaks" id="pub-key-tweak" target="_blank" rel="noopener noreferrer"></a> saw in <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch05.html#public_child_key_derivation" target="_blank" rel="noopener noreferrer">“Public Child Key Derivation”</a>, the math of elliptic curve
cryptography (ECC) allows Alice to use a private key to derive a public
key that she gives to Bob.  He can add an arbitrary value to that public
key to create a derived public key.  If he gives that arbitrary value to Alice, she can
add it to her private key to derive the private key for the derived
public key.  In short, Bob can create child public keys for which only
Alice can create the corresponding private keys.  This is useful for
BIP32-style Hierarchical Deterministic (HD) wallet recovery, but it can
also serve another use.</p>

<p>Let’s imagine Bob wants to buy something from Alice but he also wants to
be able prove later what he paid for in case there’s any dispute.  Alice
and Bob agree on the name of the item or service being sold (e.g.,
“Alice’s podcast episode #123”), and transform that description into a
number by hashing it and interpreting the hash digest as a number.  Bob
adds that number to Alice’s public key and pays it.  The process is
called <em>key tweaking</em>, and the number is known as a <em>tweak</em>.</p>

<p>Alice can spend the funds by tweaking her private key using the same
number (tweak).</p>

<p>Later, Bob can prove to anyone what he paid Alice by revealing her
underlying key and the description they used.  Anyone can verify that
the public key, which was paid, equals the underlying key plus the
hash commitment to the description.  If Alice admits that key is hers,
then she received the payment.  If Alice spent the funds, this further
proves she knew the description at the time she signed the spending
transaction since she could only create a valid signature for the
tweaked public key if she knew the tweak (the description).</p>

<p>If neither Alice nor Bob decided to publicly reveal the description they
use, the payment between them looks like any other payment.  There’s no
privacy loss.</p>

<p>Because P2C is private by default, we can’t know how often it is used
for its original purpose—​in theory every payment could be using it,
although we consider that unlikely.  However, P2C is widely used today
in a slightly different form, which we’ll<a data-type="indexterm" data-primary="P2C (pay to contract)" data-startref="p2c" id="id979" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="key tweaks" data-startref="key-tweak" id="id980" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="public key cryptography" data-secondary="key tweaks" data-startref="pub-key-tweak" id="id981" target="_blank" rel="noopener noreferrer"></a> see in <a data-type="xref" href="#taproot" target="_blank" rel="noopener noreferrer">“Taproot”</a>.</p>
</div>






<div id="scriptless_multisignatures_and_threshold_signatures" data-type="sect1" data-pdf-bookmark="Scriptless Multisignatures and Threshold Signatures">
<h2>Scriptless Multisignatures and Threshold Signatures</h2>

<p>In <a data-type="xref" href="#multisig" target="_blank" rel="noopener noreferrer">“Scripted Multisignatures”</a>, we <a data-type="indexterm" data-primary="scriptless multisignatures" id="scriptless-multi" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="multisignature scripts" data-secondary="scriptless" id="multisignature-scriptless" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="threshold signatures" id="threshold-signature" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="public key cryptography" data-secondary="scriptless multisignatures" id="pub-key-scriptless" target="_blank" rel="noopener noreferrer"></a>looked at scripts that require signatures from
multiple keys.  However, there’s another way to require cooperation from
multiple keys, which is also confusingly called <em>multisignature</em>.  To
distinguish between the two types in this section, we’ll call the
version involving <code>OP_CHECKSIG</code>-style opcodes <em>script multisignatures</em>
and the other version <em>scriptless multisignatures</em>.</p>

<p>Scriptless multisignatures involve each participant creating their own
secret the same way they create a private key.  We’ll call this <a data-type="indexterm" data-primary="partial private keys" id="id982" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="private keys" data-secondary="partial" id="id983" target="_blank" rel="noopener noreferrer"></a>secret a
<em>partial private key</em>, although we should note that it’s the same length
as a regular full private key.  From the partial private key, each
participant derives a partial public key using the same algorithm used
for regular public keys we described in <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch04.html#public_key_derivation" target="_blank" rel="noopener noreferrer">“Public Keys”</a>.  Each
participant shares their partial public keys with all the other
participants and then combines all of the keys together to create the
scriptless multisignature public key.</p>

<p>This combined public key looks the same as any other Bitcoin public key.
A third party can’t distinguish between a multiparty public key and an
ordinary key generated by a single user.</p>

<p>To spend bitcoins protected by the scriptless multisignature public key,
each participant generates a partial signature.  The partial signatures
are then combined to create a regular full signature.  There are
many known methods for creating and combining the partial signatures;
we’ll look at this topic more in <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch08.html#c_signatures" target="_blank" rel="noopener noreferrer">Chapter&nbsp;8</a>.  Similar to the public
keys for scriptless multisignatures, the signatures generated by this
process look the same as any other Bitcoin signature.  Third parties
can’t determine whether a signature was created by a single person or a
million people cooperating with each other.</p>

<p>Scriptless multisignatures are smaller and more private than scripted
multisignatures.  For scripted multisignatures, the number of bytes
placed in a transaction increases for every key and signature involved.
For scriptless multisignatures, the size is constant—​a million
participants each providing their own partial key and partial signature
puts exactly the same amount of data in a transaction as an individual
using a single key and signature.  The story is the same for privacy:
because each new key or signature adds data to a transaction, scripted
multisignatures disclose data about how many keys and signatures are
being used—​which may make it easy to figure out which transactions were
created by which group of participants.  However, because every scriptless
multisignatures looks like every other scriptless
multisignature and every single-signature, no privacy-reducing data is
leaked.</p>
<p>
There are two downsides of scriptless multisignatures.  The first is
that all known secure algorithms for creating them for Bitcoin require more
rounds of interaction or more careful management of state than
scripted multisignatures.  This can be challenging in cases where
signatures are being generated by nearly stateless hardware signing
devices and the keys are physically distributed.  For example, if you
keep a hardware signing device in a bank safe deposit box, you would
need to visit that box once to create a scripted multisignature but
possibly two or three times for a scriptless multisignature.
</p>

<p>The other downside is that threshold signing doesn’t reveal who signed.
In scripted threshold signing, Alice, Bob, and Carol agree (for example)
that any two of them signing will be sufficient to spend the funds.
If Alice and Bob sign, this requires putting signatures from each of
them on chain, proving to anyone who knows their keys that they signed
and Carol didn’t.  In scriptless threshold signing, a signature from
Alice and Bob is indistinguishable from a signature between Alice and
Carol or Bob and Carol.  This is beneficial for privacy, but it means
that, even if Carol claims she didn’t sign, she can’t
prove that she didn’t, which may be bad for accountability and
auditability.</p>

<p>For many users and use cases, the always reduced size and increased
privacy of multisignatures outweighs its occasional challenges for
creating and auditing<a data-type="indexterm" data-primary="scriptless multisignatures" data-startref="scriptless-multi" id="id984" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="multisignature scripts" data-secondary="scriptless" data-startref="multisignature-scriptless" id="id985" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="threshold signatures" data-startref="threshold-signature" id="id986" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="public key cryptography" data-secondary="scriptless multisignatures" data-startref="pub-key-scriptless" id="id987" target="_blank" rel="noopener noreferrer"></a> signatures.</p>
</div>






<div id="taproot" data-type="sect1" data-pdf-bookmark="Taproot">
<h2>Taproot</h2>

<p>One reason <a data-type="indexterm" data-primary="scripts" data-secondary="MAST" data-tertiary="taproot" id="script-mast-taproot" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="MAST (merklized alternative script trees)" data-secondary="taproot" id="mast-taproot" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="merkle trees" data-secondary="MAST" data-tertiary="taproot" id="merkle-tree-mast-taproot" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="taproot" id="taproot-ch7" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="mutual satisfaction contracts" data-secondary="taproot" id="mutual-satisfaction-taproot" target="_blank" rel="noopener noreferrer"></a>people choose to use Bitcoin is that it’s possible to create
contracts with highly predictable outcomes.  Legal contracts enforced by
a court of law depend in part on decisions by the judges and jurors
involved in the case.  By contrast, Bitcoin contracts often require
actions by their participants but are otherwise enforced by thousands of
full nodes all running functionally identical code.  When given the same
contract and the same input, every full node will always produce the
same result.  Any deviation would mean that Bitcoin was broken.
Human judges and juries can be much more flexible than software, but
when that flexibility isn’t wanted or needed, the predictability of
Bitcoin contracts is a major asset.</p>

<p>If all of the participants in a contract recognize that its outcome has
become completely predictable, there’s not actually any need for them to
continue using the contract.  They could just do whatever the contract
compels them to do and then terminate the contract.  In society, this
is how most contracts terminate: if the interested parties are
satisfied, they never take the contract before a judge or jury.  In
Bitcoin, it means that any contract that will use a significant amount
of block space to settle should also provide a clause that allows it to
instead be settled by mutual satisfaction.</p>

<p>In MAST and with scriptless multisignatures, a mutual satisfaction
clause is easy to design.  We simply make one of the top leaves of the
script tree a scriptless multisignature between all interested parties.
We already saw a complex contract between several parties with a
simple mutual satisfaction clause in <a data-type="xref" href="#diagram_mast3" target="_blank" rel="noopener noreferrer">Figure&nbsp;7-7</a>.  We could make
that more optimized by switching from scripted multisignature to
scriptless multisignature.</p>

<p>That’s reasonably efficient and private.  If the mutual satisfaction
clause is used, we only need to provide a single merkle branch and all
we reveal is that a signature was involved (it could be from one person
or it could be from thousands of different participants).  But
developers in 2018 realized that we could do better if we also used
pay to contract.</p>

<p>In our previous description of pay to contract in <a data-type="xref" href="#pay_to_contract" target="_blank" rel="noopener noreferrer">“Pay to Contract (P2C)”</a>,
we tweaked a public key to commit to the text of an agreement between
Alice and Bob.  We can instead commit to the program code of a contract
by committing to the root of a MAST.  The public key we tweak
is a regular Bitcoin public key, meaning it could require a signature
from a single person or it could require a signature from multiple
people (or it could be created in a special way to make it impossible to
generate a signature for it).  That means we can satisfy the contract
either with a single signature from all interested parties or by
revealing the MAST branch we want to use.  That commitment tree
involving both a public key and a MAST is shown in <a data-type="xref" href="#diagram_taproot1" target="_blank" rel="noopener noreferrer">Figure&nbsp;7-10</a>.</p>

<figure><div id="diagram_taproot1">
<p><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098150082/files/assets/mbc3_0710.png" alt="" width="600" height="530"></p><h6><span>Figure 7-10. </span>A taproot with the public key committing to a merkle root.</h6>
</div></figure>

<p>This makes the mutual satisfaction clause using a multisignature
extremely efficient and very private.  It’s even more private than it
may appear because any transaction created by a single user who wants it
to be satisfied by a single signature (or a multisignature generated by
multiple different wallets they control) looks identical onchain to a
mutual-satisfaction spend.  There’s no onchain difference in this case
between a spend by a million users involved in an extraordinarily complex
contract or a single user just spending their saved bitcoins.</p>

<p>When spending is possible using just the key, such as for a single signature
or scriptless multisignature, that is<a data-type="indexterm" data-primary="keypath spending" id="id988" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="scriptpath spending" id="id989" target="_blank" rel="noopener noreferrer"></a> called <em>keypath spending</em>.  When
the tree of scripts is used, that is called <em>scriptpath spending</em>.
For keypath spending, the data that gets put onchain is the public key
(in a witness program) and the signature (on the witness stack).</p>

<p>For scriptpath spending, the onchain data also includes the public key,
which is placed in a witness program and called the <em>taproot output key</em>
in this context.  The witness structure includes the following information:</p>

<ul>
<li>
<p>A version number.</p>
</li>
<li>
<p>The underlying key—​the key that existed before being tweaked by the
merkle root to produce the taproot output key.  This underlying key
is called the <em>taproot internal key</em>.</p>
</li>
<li>
<p>The script to execute, called the <em>leaf script</em>.</p>
</li>
<li>
<p>One 32-byte hash for each junction in merkle tree along the path that connects the leaf to the merkle root.</p>
</li>
<li>
<p>Any data necessary to satisfy the script (such as signatures or hash preimages).</p>
</li>
</ul>

<p>We’re only aware of one significant described downside of taproot:
contracts whose participants want to use MAST but who don’t want a
mutual satisfaction clause have to include a taproot internal key on the
blockchain, adding about 33 bytes of overhead. Given that almost
all contracts are expected to benefit from a mutual satisfaction clause,
or other multisignature clause that uses the top-level public key, and
all users benefit from the increased anonymity set of outputs looking
similar to each other, that rare overhead was not considered important
by most users who participated in taproot’s activation.</p>

<p>Support for taproot was added to Bitcoin in a soft fork that <a data-type="indexterm" data-primary="scripts" data-secondary="MAST" data-tertiary="taproot" data-startref="script-mast-taproot" id="id990" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="MAST (merklized alternative script trees)" data-secondary="taproot" data-startref="mast-taproot" id="id991" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="merkle trees" data-secondary="MAST" data-tertiary="taproot" data-startref="merkle-tree-mast-taproot" id="id992" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="taproot" data-startref="taproot-ch7" id="id993" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="mutual satisfaction contracts" data-secondary="taproot" data-startref="mutual-satisfaction-taproot" id="id994" target="_blank" rel="noopener noreferrer"></a>activated
in November 2021.</p>
</div>






<div id="id134" data-type="sect1" data-pdf-bookmark="Tapscript">
<h2>Tapscript</h2>

<p>Taproot <a data-type="indexterm" data-primary="tapscript" id="tapscript" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="mutual satisfaction contracts" data-secondary="tapscript" id="mutual-satisfaction-tapscript" target="_blank" rel="noopener noreferrer"></a>enables MAST but only with a slightly different version of the
Bitcoin Script language than previously used, the new version being
called <em>tapscript</em>.  The major differences include:</p>
<dl>
<dt>Scripted multisignature changes</dt>
<dd>
<p>The old <code>OP_CHECKMULTISIG</code> and <code>OP_CHECKMULTISIGVERIFY</code> opcodes are
removed.  Those opcodes don’t combine well with one of the other
changes in the taproot soft fork, the ability to use schnorr signatures
with batch validation (see <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch08.html#schnorr_signatures" target="_blank" rel="noopener noreferrer">“Schnorr Signatures”</a>).  A new <code>OP_CHECKSIGADD</code> opcode is provided
instead.  When it successfully verifies a signature, this new opcode
increments a counter by one, making it possible to conveniently count
how many signatures passed, which can be compared against the desired number
of successful signatures to reimplement the same behavior as
<code>OP_CHECKMULTISIG</code>.</p>
</dd>
<dt>Changes to all signatures</dt>
<dd>
<p>All signature operations in tapscript use the schnorr signature
algorithm as defined in BIP340.  We’ll explore schnorr signatures more
in <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch08.html#c_signatures" target="_blank" rel="noopener noreferrer">Chapter&nbsp;8</a>.</p>

<p>Additionally, any signature-checking operation that is not expected
  to succeed must be fed the value <code>OP_FALSE</code> (also called <code>OP_0</code>)
  instead of an actual signature.  Providing anything else to a failed
  signature-checking operation will cause the entire script to fail.
  This also helps support batch validation of schnorr signatures.</p>
</dd>
<dt><code>OP_SUCCESSx</code> opcodes</dt>
<dd>
<p>Opcodes in previous versions of Script that were unusable are now
redefined to cause an entire script to succeed if they are used.
This allows future soft forks to redefine them as not succeeding under
certain circumstances, which
is a restriction and so is possible to do in a soft fork.  (The
opposite, to define a not-succeeding operation as a success can only
be done in a hard fork, which is a much more challenging upgrade
path.)</p>
</dd>
</dl>

<p>Although we’ve looked at authorization and authentication in depth in
this chapter, we’ve skipped over one very important part of how Bitcoin
authenticates spenders: its signatures.  We’ll look at that<a data-type="indexterm" data-primary="tapscript" data-startref="tapscript" id="id995" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="mutual satisfaction contracts" data-secondary="tapscript" data-startref="mutual-satisfaction-tapscript" id="id996" target="_blank" rel="noopener noreferrer"></a> next in
<a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch08.html#c_signatures" target="_blank" rel="noopener noreferrer">Chapter&nbsp;8</a>.</p>
</div>
</div></div>
  <span></span> <!-- for IntersectionObserver -->
  
  
  
  


<style id="note-styling">
    .note {
      position: absolute;
      z-index: 10;
      border: none;
      outline: none;
      font-family: inherit;
      font-size: inherit;
      padding: 5px;
      min-width: 32px;
      min-height: 32px;
    }
    .note:focus {
      z-index: 11;
    }
    .note[type="0"] {
      background-color: #fff740;
      color: #2c2c2d;
    }
    .note[type="0"]::placeholder {
      color: #868226;
    }
    .note[type="1"] {
      background-color: #feff9c;
      color: #2c2c2d;
    }
    .note[type="1"]::placeholder {
      color: #6d6d3d;
    }
    .note[type="2"] {
      background-color: #ff65a3;
      color: #2c2c2d;
    }
    .note[type="2"]::placeholder {
      color: #65263f;
    }
    .note[type="3"] {
      background-color: #ff7eb9;
      color: #2c2c2d;
    }
    .note[type="3"]::placeholder {
      color: #562b3f;
    }
    .note[type="4"] {
      background-color: #7afcff;
      color: #295c5d;
    }
    .note[type="4"]::placeholder {
      color: #377677;
    }</style><div id="chapters-container">
      <style>
        #chapters {
          display: grid;
          grid-template-columns: 1fr 1fr;
          margin: 2ch 0;
        }
        #chapters a {
          cursor: pointer;
        }
        #chapters a[href=""] {
          opacity: 0.5;
          pointer-events: none;
          color: inherit;
        }
        #chapters a:first-child {
          justify-self: start;
        }
        #chapters a:last-child {
          justify-self: end;
        }
      </style>
      <hr>
      <div id="chapters">
        <a href="" title="move to the previous chapter (Ctrl/Command + PageUp)">Previous Chapter</a>
        <a href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch08.html" title="move to the next chapter (Ctrl/Command + PageDown)">Next Chapter</a>
      </div>
    </div></body><style>body {
      font-size:  19px;
      font-family: Georgia, 'Times New Roman', serif;
      width: 600px;
    }
    p {
      text-align: justify
    }
    .page {
      line-height: 28.5px;
      column-count: unset;
    }
    h1, h2, h3 {
      line-height: initial;
    }</style></html>