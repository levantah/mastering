<!DOCTYPE html>
<html><head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <base target="_blank">
  <style>
/* latin */
@font-face {
  font-family: 'Comic Neue';
  font-style: normal;
  font-weight: 400;
  src: url(fonts/4UaHrEJDsxBrF37olUeD96rp57F2IwM.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
/* latin */
@font-face {
  font-family: 'Lexend Deca';
  font-style: normal;
  font-weight: 400;
  src: url(fonts/K2FifZFYk-dHSE0UPPuwQ7CrD94i-NCKm-U48M1wqxnDirZPl3v-.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
/* latin */
@font-face {
  font-family: 'Poppins';
  font-style: normal;
  font-weight: 400;
  src: url(fonts/pxiEyp8kv8JHgFVrJJfecnFHGPc.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

:root {
  --fg: #000; /* foreground  */
  --bg: #fff; /* background  */
  --bd: #000; /* border  */
  --lk: #006fa5; /* link */
  --lkv: #d33bf0; /* link visited */
  --hg: #ffff81; /* highlight  */
}
html {
  overflow: overlay;
}
body {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  margin: 30px auto 0 auto;
  padding: 10px;
  position: relative;

  color: var(--fg);
  border-color: var(--bd);
  background-color: var(--bg);
}
body[data-mode$="dark"] {
  --lk: #0096de;
}
body[data-mode="light"] {
  color-scheme: light;
  --fg: #222;
  --bd: #222;
  --bg: whitesmoke;
}
body[data-mode="dark"] {
  color-scheme: dark;
  --fg: #eee;
  --bd: #eee;
  --bg: #333;
}
body[data-mode="sepia"] {
  color-scheme: light;
  --fg: #5b4636;
  --bd: #5b4636;
  --bg: #f4ecd8;
}
body[data-mode="solarized-light"] {
  color-scheme: light;
  --fg: #586e75;
  --bd: #586e75;
  --bg: #fdf6e3;
}
body[data-mode="nord-light"] {
  color-scheme: light;
  --fg: #2e3440;
  --bd: #2e3440;
  --bg: #e5e9f0;
}
body[data-mode="groove-dark"] {
  color-scheme: dark;
  --fg: #cec4ac;
  --bd: #cec4ac;
  --bg: #282828;
}
body[data-mode="solarized-dark"] {
  color-scheme: dark;
  --fg: #839496;
  --bd: #839496;
  --bg: #002b36;
}
body[data-mode="nord-dark"] {
  color-scheme: dark;
  --fg: #e5e9f0;
  --bd: #e5e9f0;
  --bg: #2e3440;
}

@media print {
  body[data-mode] {
    --fg: #000;
    --bd: #000;
    --bg: #fff;

    width: unset;
    padding: 0;
    margin: 0;
  }
}
body[data-loaded=true] {
  
}
img {
  max-width: 100%;
  height: auto;
}
img:not([width])[src$=".svg"] {
  max-width: 100px;
}
body[data-images=false] canvas,
body[data-images=false] svg,
body[data-images=false] img {
  display: none;
}
svg:not([width]):not([height]) {
  max-width: 25vmin;
}
a {
  color: var(--lk);
  text-decoration: none;
}
a:visited {
  color: var(--lkv);
}

hr {
  background-color: var(--bd);
  height: 1px;
  border: 0;
}
#reader-domain {
  font-family: Helvetica, Arial, sans-serif;
  text-decoration: none;
  border-bottom-color: currentcolor;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  width: 100%;
  display: inline-block;
  direction: ltr;
}
#reader-domain > span:first-child {
  font-size: 1.1em;
}
#reader-domain > span:last-child {
  font-size: 0.8em;
}
#reader-title {
  font-size: 1.6em;
  line-height: 1.25em;
  width: 100%;
  margin: 20px 0;
  padding: 0;
}
#reader-credits,
#doi,
#published-time,
#reader-estimated-time {
  font-size: 0.85em;
  line-height: 1.48em;
  margin: 0 0 10px 0;
  padding: 0;
}
#reader-credits:not(:empty)::after {
  content: ' ⋮ ';
}
#published-time:not(:empty)::before {
  content: ' ⋮ ';
}
#doi-json {
  overflow: hidden;
}
#doi-json code {
  overflow: auto;
  max-height: 400px;
}
#published-time:empty,
#reader-credits:empty {
  display: none;
}
mark.hghlght {
  background-color: var(--hg);
}
body:not([data-columns="1"]) .page :is(h1, h2) {
  column-span: all;
  background-color: rgba(125, 125, 125, 0.1);
  padding: 10px;
}
.hidden {
  display: none;
}
</style>
  <style id="user-css">body {
  padding-bottom: 64px;
}
pre {
  white-space: pre-wrap;
}
pre code {
  background-color: #eff0f1;
  color: #393318;
  font-family: monospace;
  display: block;
  padding: 5px 10px;
}
body[data-mode="dark"] pre code {
  background-color: #585858;
  color: #e8e8e8;
}

/* CSS for sans-serif fonts */
body[data-font=sans-serif] {}
/* CSS for serif fonts */
body[data-font=serif] {}

/* CSS for "sepia" theme */
body[data-mode=sepia] {}
/* CSS for "light" theme */
body[data-mode=light] {}
/* CSS for "dark" theme */
body[data-mode=dark] {}</style>
<title>6. Transactions</title><title>6. Transactions :: Reader View</title></head>
<body tabindex="1" data-images="true" data-mode="groove-dark" data-font="serif" data-columns="1" data-loaded="true">
  <span></span> <!-- for IntersectionObserver -->
  <a id="reader-domain" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch06.html">
    <span>learning.oreilly.com</span>
    <span>/library/view/mastering-bitcoin-3rd/9781098150082/ch06.html</span>
  </a>
  <h1 dir="auto" id="reader-title">6. Transactions</h1>
  <span dir="auto" id="reader-credits"></span>
  <span dir="auto" id="reader-estimated-time">44-56 minutes</span>
  <span dir="auto" id="published-time"></span>
  <hr>
  <div id="readability-page-1" class="page"><div id="sbo-rt-content" data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 6. Transactions">
<h2><span>Chapter 6. </span>Transactions</h2>


<p>The way we typically transfer physical cash has little resemblance to
the way we transfer bitcoins.  Physical cash is a bearer token.  Alice
pays Bob by handing him some number of tokens, such as dollar bills.
By comparison, bitcoins don’t exist either physically or as digital
data—​Alice can’t hand Bob some bitcoins or send them by email.</p>

<p>Instead, consider how Alice might transfer control over a parcel of land
to Bob.  She can’t physically pick up the land and hand it to Bob.
Rather there exists some sort of record (usually maintained by a local
government) that describes the land Alice owns.  Alice transfers that
land to Bob by convincing the government to update the record to say
that Bob now owns the land.</p>

<p>Bitcoin works in a similar way.  There exists a database on every
Bitcoin full node that says that Alice controls some number of
bitcoins. Alice pays Bob by convincing full nodes to update their
database to say that some of Alice’s bitcoins are now controlled by Bob.
The data that Alice uses to convince full nodes to update their
databases is called a <em>transaction</em>.  This is done without directly
using either Alice’s or Bob’s identities, as we’ll see in
<a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch07.html#c_authorization_authentication" target="_blank" rel="noopener noreferrer">Chapter&nbsp;7</a>.</p>

<p>In this chapter we’ll deconstruct a Bitcoin transaction and examine each
of its parts to see how they facilitate the transfer of value in a way
that’s highly expressive and amazingly reliable.</p>






<div id="tx_structure" data-type="sect1" data-pdf-bookmark="A Serialized Bitcoin Transaction">
<h2>A Serialized Bitcoin Transaction</h2>

<p>In <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch03.html#exploring_and_decoding_transactions" target="_blank" rel="noopener noreferrer">“Exploring and Decoding Transactions”</a>, we <a data-type="indexterm" data-primary="transactions" data-secondary="serialized" id="transaction-serialize" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="serialized transactions" id="serial-transactions" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="Bitcoin Core" data-secondary="serialized transactions" id="bitcoin-core-serial-transaction" target="_blank" rel="noopener noreferrer"></a>used Bitcoin Core with
the txindex option enabled to retrieve a copy of Alice’s payment to Bob.
Let’s retrieve the transaction containing that payment again, as shown in <a data-type="xref" href="#alice_tx_serialized_reprint" target="_blank" rel="noopener noreferrer">Example&nbsp;6-1</a>.</p>
<div id="alice_tx_serialized_reprint" data-type="example">
<h5><span>Example 6-1. </span>Alice’s serialized transaction</h5>

<div data-testid="custom pre block"><pre data-type="programlisting">$ bitcoin-cli getrawtransaction 466200308696215bbc949d5141a49a41\
38ecdfdfaa2a8029c1f9bcecd1f96177

01000000000101eb3ae38f27191aa5f3850dc9cad00492b88b72404f9da13569
8679268041c54a0100000000ffffffff02204e0000000000002251203b41daba
4c9ace578369740f15e5ec880c28279ee7f51b07dca69c7061e07068f8240100
000000001600147752c165ea7be772b2c0acb7f4d6047ae6f4768e0141cf5efe
2d8ef13ed0af21d4f4cb82422d6252d70324f6f4576b727b7d918e521c00b51b
e739df2f899c49dc267c0ad280aca6dab0d2fa2b42a45182fc83e81713010000
0000</pre></div></div>

<p>Bitcoin Core’s serialization format is special because it’s the format
used to make commitments to transactions and to relay them across
Bitcoin’s P2P network, but otherwise programs can use
a different format as long as they transmit all of the
same data.  However, Bitcoin Core’s format is reasonably compact for the
data it transmits and simple to parse, so many other Bitcoin programs
use this format.</p>
<div data-type="tip"><h6>Tip</h6>
<p>The only <a data-type="indexterm" data-primary="partially signed bitcoin transaction (PSBT) format" id="id790" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="PSBT (partially signed bitcoin transaction) format" id="id791" target="_blank" rel="noopener noreferrer"></a>other widely used transaction serialization format that
we’re aware of is the partially signed bitcoin transaction (PSBT) format
documented in BIPs 174 and 370 (with extensions documented in other
BIPs).  PSBT allows an untrusted program to produce a transaction
template that can be verified and updated by trusted programs (such as
hardware signing devices) that have the necessary private keys or
other sensitive data to fill in the template.  To accomplish this, PSBT
allows storing a significant amount of metadata about a transaction,
making it much less compact than the standard serialization format.
This book does not go into detail about PSBT, but we strongly recommend
it to developers of wallets that plan to support signing
with multiple keys.</p>
</div>

<p>The transaction displayed in hexadecimal in <a data-type="xref" href="#alice_tx_serialized_reprint" target="_blank" rel="noopener noreferrer">Example&nbsp;6-1</a> is
replicated as a byte map in <a data-type="xref" href="#alice_tx_byte_map" target="_blank" rel="noopener noreferrer">Figure&nbsp;6-1</a>.  Note that it takes
64 hexadecimal characters to display 32 bytes.  This map shows only the
top-level fields.  We’ll examine each of them in the order they appear
in the transaction and describe any additional fields that they<a data-type="indexterm" data-primary="transactions" data-secondary="serialized" data-startref="transaction-serialize" id="id792" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="serialized transactions" data-startref="serial-transactions" id="id793" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="Bitcoin Core" data-secondary="serialized transactions" data-startref="bitcoin-core-serial-transaction" id="id794" target="_blank" rel="noopener noreferrer"></a> contain.</p>

<figure><div id="alice_tx_byte_map">
<p><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098150082/files/assets/mbc3_0601.png" alt="" width="600" height="449"></p><h6><span>Figure 6-1. </span>A byte map of Alice’s transaction.</h6>
</div></figure>
</div>






<div id="version" data-type="sect1" data-pdf-bookmark="Version">
<h2>Version</h2>

<p>The first <a data-type="indexterm" data-primary="transactions" data-secondary="version of" id="transactions-version" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="version (of transactions)" id="version-transactions" target="_blank" rel="noopener noreferrer"></a>four bytes of a serialized Bitcoin transaction are its
version.  The original version of Bitcoin transactions was version 1
(0x01000000).  All transactions in Bitcoin must follow
the rules of version 1 transactions, with many of those rules being
described throughout this book.</p>

<p>Version 2 Bitcoin transactions were introduced in the BIP68 soft fork
change to Bitcoin’s consensus rules.  BIP68 places additional
constraints on the sequence field, but those constraints only apply to
transactions with version 2 or higher.  Version 1 transactions are
unaffected.  BIP112, which was part of the same soft fork as BIP68,
upgraded an opcode (<code>OP_CHECKSEQUENCEVERIFY</code>), which will now fail if it is
evaluated as part of a transaction with a version less than 2.  Beyond
those two changes, version 2 transactions are identical to version 1
transactions.</p>


<p>As of this writing, a proposal to begin using version 3 transactions is
being widely considered.  That proposal does not seek to change the
consensus rules but only the policy that Bitcoin full nodes use to relay
transactions.  Under the proposal, version 3 transactions would be
subject to additional constraints in order to prevent certain denial of
service (DoS) attacks that we’ll discuss<a data-type="indexterm" data-primary="transactions" data-secondary="version of" data-startref="transactions-version" id="id796" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="version (of transactions)" data-startref="version-transactions" id="id797" target="_blank" rel="noopener noreferrer"></a> further in <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch09.html#transaction_pinning" target="_blank" rel="noopener noreferrer">“Transaction Pinning”</a>.</p>
</div>






<div id="id84" data-type="sect1" data-pdf-bookmark="Extended Marker and Flag">
<h2>Extended Marker and Flag</h2>

<p>The next two fields<a data-type="indexterm" data-primary="transactions" data-secondary="extended serialization format" id="id798" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="extended serialization format" id="id799" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="BIP144 extended serialization format" id="id800" target="_blank" rel="noopener noreferrer"></a> of the example serialized transaction were added as
part of the segregated witness (segwit) soft fork change to Bitcoin’s
consensus rules.  The rules were changed according to BIPs 141 and 143,
but the <em>extended serialization format</em> is defined in BIP144.</p>

<p>If the transaction includes a witness structure (which we’ll describe in
<a data-type="xref" href="#witness_structure" target="_blank" rel="noopener noreferrer">“Witness Structure”</a>), the marker must be zero (0x00) and the flag must be
nonzero.  In the current P2P protocol, the flag should always be one
(0x01); alternative flags are reserved for later protocol upgrades.</p>

<p>If the transaction doesn’t need a witness stack, the marker and flag must not
be present.  This is compatible with the original version of Bitcoin’s
transaction serialization format, now called <em>legacy serialization</em>.
For details, see <a data-type="xref" href="#legacy_serialization" target="_blank" rel="noopener noreferrer">“Legacy Serialization”</a>.</p>

<p>In <a data-type="indexterm" data-primary="transactions" data-secondary="legacy serialization" id="id801" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="legacy serialization" id="id802" target="_blank" rel="noopener noreferrer"></a>legacy serialization, the marker byte would have been interpreted as
the number of inputs (zero).  A transaction can’t have zero inputs, so
the marker signals to modern programs that extended serialization is
being used.  The flag field provides a similar signal and also
simplifies the process of updating the serialization format in the
future.</p>
</div>






<div id="inputs" data-type="sect1" data-pdf-bookmark="Inputs">
<h2>Inputs</h2>

<p>The<a data-type="indexterm" data-primary="transactions" data-secondary="inputs" id="transaction-input" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="inputs" id="input-transaction" target="_blank" rel="noopener noreferrer"></a> inputs field contains several other fields, so let’s start by showing a
map of those bytes in <a data-type="xref" href="#alice_tx_input_map" target="_blank" rel="noopener noreferrer">Figure&nbsp;6-2</a>.</p>

<figure><div id="alice_tx_input_map">
<p><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098150082/files/assets/mbc3_0602.png" alt="" width="600" height="174"></p><h6><span>Figure 6-2. </span>Map of bytes in the inputs field of Alice’s transaction.</h6>
</div></figure>








<div id="id86" data-type="sect2" data-pdf-bookmark="Length of Transaction Input List">
<h2>Length of Transaction Input List</h2>

<p>The <a data-type="indexterm" data-primary="transactions" data-secondary="inputs" data-tertiary="length of list" id="transaction-input-length" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="inputs" data-secondary="length of list" id="input-transaction-length" target="_blank" rel="noopener noreferrer"></a>transaction input list starts with an integer indicating the number of inputs
in the transaction.  The minimum value is one.  There’s no explicit
maximum value, but restrictions on the maximum size of a transaction
effectively limit transactions to a few thousand inputs.  The number is
encoded as a compactSize unsigned integer.</p>


<p>Each input in a transaction must contain three fields: an <em>outpoint</em> field, a length-prefixed <em>input script</em> field, and a <em>sequence</em></p>

<p>We’ll look at each of those fields in the following sections.  Some
inputs also include a witness stack, but this is serialized at the end of a
transaction so we’ll <a data-type="indexterm" data-primary="transactions" data-secondary="inputs" data-tertiary="length of list" data-startref="transaction-input-length" id="id804" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="inputs" data-secondary="length of list" data-startref="input-transaction-length" id="id805" target="_blank" rel="noopener noreferrer"></a>examine it later.</p>
</div>








<div id="outpoints" data-type="sect2" data-pdf-bookmark="Outpoint">
<h2>Outpoint</h2>

<p>A Bitcoin <a data-type="indexterm" data-primary="transactions" data-secondary="inputs" data-tertiary="outpoint field" id="transaction-input-outpoint" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="inputs" data-secondary="outpoint field" id="input-transaction-outpoint" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="outpoint field (transaction inputs)" id="outpoint" target="_blank" rel="noopener noreferrer"></a>transaction is a request for full nodes to update their
database of coin ownership information.  For Alice to transfer control
of some of her bitcoins to Bob, she first needs to tell full nodes how
to find the previous transfer where she received those bitcoins.  Since
control over bitcoins is assigned in transaction outputs, Alice <em>points</em>
to the previous <em>output</em> using an <em>outpoint</em> field.  Each input must
contain a single outpoint.</p>

<p>The outpoint contains a 32-byte txid for the
transaction where Alice received the bitcoins she now wants to spend.
This txid is in Bitcoin’s internal byte order for hashes; see
<a data-type="xref" href="#internal_and_display_order" target="_blank" rel="noopener noreferrer">“Internal and Display Byte Orders”</a>.</p>

<p>Because transactions may contain multiple outputs, Alice also needs to
identify which particular output from that transaction to use, <a data-type="indexterm" data-primary="output indexes" id="id806" target="_blank" rel="noopener noreferrer"></a>called
its <em>output index</em>.  Output indexes are 4-byte unsigned
integers starting from zero.</p>

<p>When a full node encounters an outpoint, it uses that information to try
to find the referenced output.  Full nodes are only required to look at earlier
transactions in the blockchain.  For example, Alice’s transaction is
included in block 774,958.  A full node verifying her transaction
only looks for the previous output referenced by her outpoint in that
block and previous blocks, not any later blocks.  Within block 774,958,
they will only look at transactions placed in the block prior to Alice’s
transaction, as determined by the order of leaves in the block’s merkle
tree (see <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch11.html#merkle_trees" target="_blank" rel="noopener noreferrer">“Merkle Trees”</a>).</p>

<p>Upon finding the previous output, the full node obtains several critical
pieces of information from it:</p>

<ul>
<li>
<p>The amount of bitcoins assigned to that previous output.  All of those
bitcoins will be transferred in this transaction.  In the example
transaction, the value of the previous output was 100,000 satoshis.</p>
</li>
<li>
<p>The authorization conditions for that previous output.  These are the
conditions that must be fulfilled in order to spend the bitcoins
assigned to that previous output.</p>
</li>
<li>
<p>For confirmed transactions, the height of the block that confirmed it
and the median time past (MTP) for that block.  This is required for
relative timelocks (described in <a data-type="xref" href="#relative_timelocks" target="_blank" rel="noopener noreferrer">“Sequence as a consensus-enforced relative timelock”</a>) and outputs
of coinbase transactions (described in <a data-type="xref" href="#coinbase_transactions" target="_blank" rel="noopener noreferrer">“Coinbase Transactions”</a>).</p>
</li>
<li>
<p>Proof that the previous output exists in the blockchain (or as a known
unconfirmed transaction) and that no other transaction has spent it.
One of Bitcoin’s consensus rules forbids any output from being spent
more than once within a valid blockchain.  This is the<a data-type="indexterm" data-primary="double spending" id="id807" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="conflicting transactions" id="id808" target="_blank" rel="noopener noreferrer"></a> rule against
<em>double spending</em>: Alice can’t use the same previous output to pay
both Bob and Carol in separate transactions.  Two transactions that each try to spend the
same previous output are called <em>conflicting transactions</em> because
only one of them can be included in a valid blockchain.</p>
</li>
</ul>

<p>Different approaches to tracking previous outputs have been tried by
different full node implementations at various times.  Bitcoin Core
currently uses the solution believed to be most effective at retaining
all necessary information while minimizing disk space: it keeps a
database that stores every UTXO and
essential metadata about it (like its confirmation block height).  Each
time a new block of transactions arrives, all of the outputs they spend
are removed from the UTXO database and all of the outputs they create
are added to the<a data-type="indexterm" data-primary="transactions" data-secondary="inputs" data-tertiary="outpoint field" data-startref="transaction-input-outpoint" id="id809" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="inputs" data-secondary="outpoint field" data-startref="input-transaction-outpoint" id="id810" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="outpoint field (transaction inputs)" data-startref="outpoint" id="id811" target="_blank" rel="noopener noreferrer"></a> database.</p>

</div>








<div id="id88" data-type="sect2" data-pdf-bookmark="Input Script">
<h2>Input Script</h2>

<p>The <a data-type="indexterm" data-primary="transactions" data-secondary="inputs" data-tertiary="input script" id="id816" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="inputs" data-secondary="input script" id="id817" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="input scripts" id="id818" target="_blank" rel="noopener noreferrer"></a>input script field is a remnant of the legacy transaction format.  Our
example transaction input spends a native segwit output that doesn’t
require any data in the input script, so the length prefix for the
input script is set to zero (0x00).</p>

<p>For an example of a length-prefixed input script that spends a legacy
output, we use one from an arbitrary transaction in the most recent
block as of this writing:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">6b483045022100a6cc4e8cd0847951a71fad3bc9b14f24d44ba59d19094e0a8c
fa2580bb664b020220366060ea8203d766722ed0a02d1599b99d3c95b97dab8e
41d3e4d3fe33a5706201210369e03e2c91f0badec46c9c903d9e9edae67c167b
9ef9b550356ee791c9a40896</pre></div>

<p>The length prefix is a compactSize unsigned integer indicating the
length of the serialized input script field.  In this case, it’s a single
byte (0x6b) indicating the input script is 107 bytes.  We’ll cover parsing
and using scripts in detail in <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch07.html#c_authorization_authentication" target="_blank" rel="noopener noreferrer">Chapter&nbsp;7</a>.</p>
</div>








<div id="sequence" data-type="sect2" data-pdf-bookmark="Sequence">
<h2>Sequence</h2>

<p>The <a data-type="indexterm" data-primary="transactions" data-secondary="inputs" data-tertiary="sequence field" id="transaction-input-sequence" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="inputs" data-secondary="sequence field" id="input-transaction-sequence" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="sequence field (transaction inputs)" id="sequence-field" target="_blank" rel="noopener noreferrer"></a>final four bytes of an input are its <em>sequence</em> number.
The use and meaning of this field has changed over time.</p>










<div id="original_tx_replacement" data-type="sect3" data-pdf-bookmark="Original sequence-based transaction replacement">
<h3>Original sequence-based transaction replacement</h3>

<p>The <a data-type="indexterm" data-primary="sequence-based transaction replacement" id="sequence-replace" target="_blank" rel="noopener noreferrer"></a>sequence field was originally intended to allow creation of
multiple versions of the same transaction, with later versions replacing
earlier versions as candidates for confirmation.  The sequence number
tracked the version of the transaction.</p>

<p>For example, imagine Alice and Bob want to bet on a game of cards.  They
start by each signing a transaction that deposits some money into an
output with a script that requires signatures from both of them to <a data-type="indexterm" data-primary="multisignature scripts" id="id819" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="setup transactions" id="id820" target="_blank" rel="noopener noreferrer"></a>spend, a
<em>multisignature</em> script (<em>multisig</em> for short).  This is called the
<em>setup transaction</em>.  They then create a transaction that spends that
output:</p>

<ul>
<li>
<p>The first version of the transaction, with nSequence 0 (0x00000000),
pays Alice and Bob back the money they initially deposited.  This is
called a <em>refund transaction</em>.  Neither of them broadcasts the refund
transaction at this time.  They only need it if there’s a problem.</p>
</li>
<li>
<p>Alice wins the first round of the card game, so the second version of
the transaction, with sequence 1, increases the amount of money paid
to Alice and decreases Bob’s share.  They both sign the updated
transaction.  Again, they don’t need to broadcast this version of the
transaction unless there’s a problem.</p>
</li>
<li>
<p>Bob wins the second round, so the sequence is incremented to 2,
Alice’s share is decreased, and Bob’s share is increased.  They again
sign but don’t broadcast.</p>
</li>
<li>
<p>After many more rounds where the sequence is incremented, the
funds redistributed, and the resulting transaction is signed but not
broadcast, they decide to finalize the transaction.  Creating a
transaction with the final balance of funds, they set sequence to its
maximum value (0xffffffff), finalizing the transaction.  They broadcast
this version of the transaction, it’s relayed across the network, and
eventually confirmed by miners.</p>
</li>
</ul>

<p>We can see the replacement rules for sequence at work if we consider
alternative scenarios:</p>

<ul>
<li>
<p>Imagine that Alice broadcasts the final transaction, with a sequence of
0xffffffff, and then Bob broadcasts one of the earlier transactions
where his balance was higher.  Because Bob’s version of the
transaction has a lower sequence number, full nodes using the original
Bitcoin code won’t relay it to miners, and miners who also used the
original code won’t mine it.</p>
</li>
<li>
<p>In another scenario, imagine that Bob broadcasts an earlier version of
the transaction a few seconds before Alice broadcasts the final
version.  Nodes will relay Bob’s version and miners will attempt to
mine it, but when Alice’s version with its higher sequence number
arrives, nodes will also relay it and miners using the original
Bitcoin code will try to mine it instead of Bob’s version.  Unless Bob
got lucky and a block was discovered before Alice’s version arrived,
it’s Alice’s version of the transaction that will get confirmed.</p>
</li>
</ul>

<p>This type of protocol is what we now <a data-type="indexterm" data-primary="payment channels" id="id821" target="_blank" rel="noopener noreferrer"></a>call a <em>payment channel</em>.
Bitcoin’s creator, in an email attributed to him, called<a data-type="indexterm" data-primary="high-frequency transactions" id="id822" target="_blank" rel="noopener noreferrer"></a> these
<em>high-frequency transactions</em> and described a number of features added to
the protocol to support them.  We’ll learn about several of those other
features later and also discover how modern versions of payment channels
are increasingly being used in Bitcoin today.</p>

<p>There were a few problems with purely sequence-based payment channels.
The first was that the rules for replacing a lower-sequence transaction
with a higher-sequence transaction were only a matter of software
policy.  There was no direct incentive for miners to prefer one version
of the transaction over any other.  The second problem was that the
first person to send their transaction might get lucky and have it
confirmed even if it wasn’t the highest-sequence transaction.  A
security protocol that fails a few percent of the time due to bad luck
isn’t a very effective protocol.</p>

<p>The third problem was that it was possible to replace one version of a
transaction with a different version an unlimited number of
times.  Each replacement would consume the bandwidth of all the relaying full nodes
on the network.  For example, as of this writing, there are about 50,000
relaying full nodes; an attacker creating 1,000 replacement transactions
per minute at 200 bytes each would use about 20 KB of their
personal bandwidth but about 10 GB of full node network bandwidth
every minute.  Except for the cost of their 20 KB/minute bandwidth and
the occasional fee when a transaction got confirmed, the attacker wouldn’t
need to pay any costs for the enormous burden they placed on full node
operators.</p>

<p>To eliminate the risk of this attack, the original type of
sequence-based transaction replacement was disabled in an early version
of the Bitcoin software.  For several years, Bitcoin full nodes would
not allow an unconfirmed transaction containing a particular input (as
indicated by its outpoint) to be replaced by a different transaction
containing the same input.  However, that situation didn’t <a data-type="indexterm" data-primary="sequence-based transaction replacement" data-startref="sequence-replace" id="id823" target="_blank" rel="noopener noreferrer"></a>last forever.</p>
</div>










<div id="sequence-bip125" data-type="sect3" data-pdf-bookmark="Opt-in transaction replacement signaling">
<h3>Opt-in transaction replacement signaling</h3>

<p>After the<a data-type="indexterm" data-primary="opt-in transaction replacement" id="id824" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="replace by fee (RBF)" id="id825" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="transaction fees" data-secondary="opt-in transaction replacement" id="id826" target="_blank" rel="noopener noreferrer"></a> original sequence-based transaction replacement was disabled
due to the potential for abuse, a solution was proposed: programming
Bitcoin Core and other relaying full node software to allow a
transaction that paid a higher transaction fee rate to replace a
conflicting transaction that paid a lower fee rate.  This is called
<em>replace by fee</em>, or <em>RBF</em> for short.  Some users and businesses
objected to adding support for transaction replacement back into Bitcoin
Core, so a compromise was reached that once again used the sequence
field in support of replacement.</p>

<p>As documented in BIP125, an unconfirmed transaction with any input that
has a sequence set to a value below 0xfffffffe (i.e., at least 2 below
the maximum value) signals to the network that its signer wants it to be
replaceable by a conflicting transaction paying a higher fee rate.
Bitcoin Core allowed those unconfirmed transactions to be replaced and
continued to disallow other transactions from being replaced.  This
allowed users and businesses that objected to replacement to simply
ignore unconfirmed transactions containing the BIP125 signal until they
became confirmed.</p>

<p>There’s more to modern transaction replacement policies than fee rates
and sequence signals, which we’ll see in <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch09.html#rbf" target="_blank" rel="noopener noreferrer">“Replace By Fee (RBF) Fee Bumping”</a>.</p>
</div>










<div id="relative_timelocks" data-type="sect3" data-pdf-bookmark="Sequence as a consensus-enforced relative timelock">
<h3>Sequence as a consensus-enforced relative timelock</h3>

<p>In <a data-type="xref" href="#version" target="_blank" rel="noopener noreferrer">“Version”</a>, we learned <a data-type="indexterm" data-primary="relative timelocks" id="relative-timelock" target="_blank" rel="noopener noreferrer"></a>that the BIP68 soft fork added
a new constraint to transactions with version numbers 2 or higher.  That
constraint applies to the sequence field.</p>

<p>Transaction inputs with sequence values less than 2<sup>31</sup> are
interpreted as having a relative timelock. Such a transaction may only
be included in the blockchain once the previous output (referenced by the
outpoint) has aged by the relative timelock amount. For example, a
transaction with one input with a relative timelock of 30 blocks can
only be confirmed in a block with at least 29 blocks between it and the
block containing the output being spent on the same blockchain.
Since sequence is a per-input field, a transaction may contain any
number of timelocked inputs, all of which must have sufficiently aged
for the transaction to be valid. A disable flag allows a transaction to
include both inputs with a relative timelock (sequence &lt; 2<sup>31</sup>) and
inputs without a relative timelock (sequence ≥ 2<sup>31</sup>).</p>

<p>The sequence value is specified in either blocks or seconds.
A type-flag
is used to differentiate between values counting blocks and values
counting time in seconds. The type-flag is set in the 23rd
least-significant bit (i.e., value 1&lt;&lt;22). If the type-flag is set, then
the sequence value is interpreted as a multiple of 512 seconds. If
the type-flag is not set, the sequence value is interpreted as a
number of blocks.</p>

<p>When interpreting sequence as a relative timelock, only the 16 least
significant bits are considered. Once the flags (bits 32 and 23) are
evaluated, the sequence value is usually “masked” with a 16-bit mask
(e.g., <code>sequence</code> &amp; 0x0000FFFF).  The multiple of 512 seconds is
roughly equal to the average amount of time between blocks, so the
maximum relative timelock in both blocks and seconds from 16 bits
(2<sup>16</sup>) is a bit more than one year.</p>

<p><a data-type="xref" href="#bip_68_def_of_nseq" target="_blank" rel="noopener noreferrer">Figure&nbsp;6-3</a> shows the binary layout of the sequence value,
as defined by BIP68.</p>

<figure><div id="bip_68_def_of_nseq">
<p><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098150082/files/assets/mbc3_0603.png" alt="" width="600" height="68"></p><h6><span>Figure 6-3. </span>BIP68 definition of sequence encoding (Source: BIP68).</h6>
</div></figure>

<p>Note that any transaction that sets a relative timelock using sequence
also sends the signal for opt-in replace by fee <a data-type="indexterm" data-primary="transactions" data-secondary="inputs" data-startref="transaction-input" id="id827" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="inputs" data-startref="input-transaction" id="id828" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="transactions" data-secondary="inputs" data-tertiary="sequence field" data-startref="transaction-input-sequence" id="id829" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="inputs" data-secondary="sequence field" data-startref="input-transaction-sequence" id="id830" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="sequence field (transaction inputs)" data-startref="sequence-field" id="id831" target="_blank" rel="noopener noreferrer"></a>as described in
<a data-type="xref" href="#sequence-bip125" target="_blank" rel="noopener noreferrer">“Opt-in transaction replacement signaling”</a>.</p>
</div>
</div>
</div>






<div id="id93" data-type="sect1" data-pdf-bookmark="Outputs">
<h2>Outputs</h2>

<p>The <a data-type="indexterm" data-primary="transactions" data-secondary="outputs" id="transaction-output" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="outputs" id="output-transaction" target="_blank" rel="noopener noreferrer"></a>outputs field of a transaction contains several fields related to
specific outputs.  Just as we did with the inputs field, we’ll start by
looking at the specific bytes of the outputs field from the example
transaction where Alice pays Bob, displayed as
a map of those bytes in <a data-type="xref" href="#output-byte-map" target="_blank" rel="noopener noreferrer">Figure&nbsp;6-4</a>.</p>

<figure><div id="output-byte-map">
<p><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098150082/files/assets/mbc3_0604.png" alt="" width="600" height="230"></p><h6><span>Figure 6-4. </span>A byte map of the outputs field from Alice’s transaction.</h6>
</div></figure>








<div id="id250" data-type="sect2" data-pdf-bookmark="Outputs Count">
<h2>Outputs Count</h2>

<p>Identical<a data-type="indexterm" data-primary="transactions" data-secondary="outputs" data-tertiary="count" id="id832" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="outputs" data-secondary="count" id="id833" target="_blank" rel="noopener noreferrer"></a> to the start of the inputs section of a transaction, the outputs
field begins with a count indicating the number of outputs in this
transaction.  It’s a compactSize integer and must be greater than zero.</p>

<p>The example transaction has two outputs.</p>
</div>








<div id="id94" data-type="sect2" data-pdf-bookmark="Amount">
<h2>Amount</h2>

<p>The first<a data-type="indexterm" data-primary="transactions" data-secondary="outputs" data-tertiary="amount field" id="transaction-output-amount" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="outputs" data-secondary="amount field" id="output-transaction-amount" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="amount field (transaction outputs)" id="amount-field" target="_blank" rel="noopener noreferrer"></a> field of a specific output is its <em>amount</em>, also called
“value” in Bitcoin Core.  This is an 8-byte signed integer indicating
the number of satoshis to transfer.  A satoshi is the smallest unit of
bitcoin that can be represented in an onchain Bitcoin transaction.
There are 100 million satoshis in a bitcoin.</p>

<p>Bitcoin’s consensus rules allow an output to have a value as small as
zero and as large as 21 million bitcoins (2.1 quadrillion satoshis).</p>










<div id="uneconomical_outputs" data-type="sect3" data-pdf-bookmark="Uneconomical outputs and disallowed dust">
<h3>Uneconomical outputs and disallowed dust</h3>

<p>Despite not <a data-type="indexterm" data-primary="uneconomical outputs" id="uneconomical" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="dust policies" id="dust" target="_blank" rel="noopener noreferrer"></a>having any value, a zero-value output can be spent under
the same rules as any other output.  However, spending an output (using
it as the input in a transaction) increases the size of a transaction,
which increases the amount of fee that needs to be paid.  If the value
of the output is less than the cost of the additional fee, then it doesn’t
make economic sense to spend the output.  Such outputs are known as
<em>uneconomical outputs</em>.</p>

<p>A zero-value output is always an uneconomical output; it wouldn’t
contribute any value to a transaction spending it even if the
transaction’s fee rate was zero.  However, many other outputs with low
values can be uneconomical as well, even unintentionally.  For example,
at a typical fee rate on the network today, an output might add more
value to a transaction than it costs to spend—​but tomorrow, fee rates
might rise and make the output uneconomical.</p>

<p>The need for full nodes to keep track of all UTXOs, as described in <a data-type="xref" href="#outpoints" target="_blank" rel="noopener noreferrer">“Outpoint”</a>, means that every UTXO makes it
slightly harder to run a full node.  For UTXOs containing significant
value, there’s an incentive to eventually spend them, so they aren’t a
problem.  But there’s no incentive for the person controlling an
uneconomical UTXO to ever spend it, potentially making it a perpetual
burden on operators of full nodes.  Because Bitcoin’s decentralization
depends on many people being willing to run full nodes, several full
node implementations such as Bitcoin Core discourage the creation of
uneconomical outputs using policies that affect the relay and mining of
unconfirmed transactions.</p>

<p>The policies against relaying or mining transactions creating new
uneconomical outputs are called <em>dust</em> policies, based on a metaphorical
comparison between outputs with very small values and particles with
very small size.  Bitcoin Core’s dust policy is complicated and contains
several arbitrary numbers, so many programs we’re aware of simply
assume outputs with less than 546 satoshis are dust and will not be
relayed or mined by default.  There are occasionally proposals to lower
dust limits, and counterproposals to raise them, so we encourage
developers using presigned transactions or multiparty protocols to
check whether the policy has changed since publication of this book.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Since Bitcoin’s inception, every full node has needed to keep a copy of
every UTXO, but that might not always be
the case.  Several developers have been working on<a data-type="indexterm" data-primary="Utreexo" id="id834" target="_blank" rel="noopener noreferrer"></a> Utreexo, a project
that allows full nodes to store a commitment to the set of UTXOs rather
than the data itself.  A minimal commitment might be only a kilobyte or
two in size—​compare that to the over five gigabytes Bitcoin Core stores
as of this writing.</p>

<p>However, Utreexo will still require some nodes to store all UTXO data,
especially nodes serving miners and other operations that need to
quickly validate new blocks.  That means uneconomical outputs can still
be a problem for full nodes even in a possible future where most nodes
use Utreexo.</p>
</div>

<p>Bitcoin Core’s policy rules about dust do have one exception: output
scripts starting with <code>OP_RETURN</code>, called <em>data carrier outputs</em>,
can have a value of zero.  The <code>OP_RETURN</code> opcode causes the script to
immediately fail no matter what comes after it, so these outputs can
never be spent.  That means full nodes don’t need to keep track of them,
a feature Bitcoin Core takes advantage of to allow users to store small
amounts of arbitrary data in the blockchain without increasing the size
of its UTXO database.  Since the outputs are unspendable, they aren’t
uneconomical—​any satoshis assigned to them become
permanently unspendable—​so allowing the amount to be zero ensures
satoshis aren’t being <a data-type="indexterm" data-primary="transactions" data-secondary="outputs" data-tertiary="amount field" data-startref="transaction-output-amount" id="id835" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="outputs" data-secondary="amount field" data-startref="output-transaction-amount" id="id836" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="amount field (transaction outputs)" data-startref="amount-field" id="id837" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="uneconomical outputs" data-startref="uneconomical" id="id838" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="dust policies" data-startref="dust" id="id839" target="_blank" rel="noopener noreferrer"></a>destroyed.</p>
</div>
</div>








<div id="id96" data-type="sect2" data-pdf-bookmark="Output Scripts">
<h2>Output Scripts</h2>

<p>The <a data-type="indexterm" data-primary="transactions" data-secondary="outputs" data-tertiary="output scripts" id="transaction-output-script" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="outputs" data-secondary="output scripts" id="output-transaction-script" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="output scripts" id="output-script2" target="_blank" rel="noopener noreferrer"></a>output amount is followed by a compactSize integer indicating the
length of the <em>output script</em>, the script that contains the
conditions that will need to be fulfilled in order to spend the
bitcoins.  According to Bitcoin’s
consensus rules, the minimum size of an output script is zero.</p>

<p>The consensus maximum allowed size of an output script varies depending on
when it’s being checked.  There’s no explicit limit on the size of an
output script in the output of a transaction, but a later transaction can
only spend a previous output with a script of 10,000 bytes or
smaller.  Implicitly, an output script can be almost as large as the
transaction containing it, and a transaction can be almost as large as
the block containing it.</p>
<div data-type="tip" id="anyone-can-spend"><h6>Tip</h6>
<p>An output script with zero length can be spent by an input script containing
<code>OP_TRUE</code>.  Anyone can create that input script, which means anyone
can spend an empty output script.  There are an essentially unlimited
number of scripts that anyone can spend, and they are known to Bitcoin
protocol developers as <em>anyone can spends</em>.  Upgrades to Bitcoin’s
script language often take an existing anyone-can-spend script and add
new constraints to it, making it only spendable under the new
conditions.  Application developers should never need to use an
anyone-can-spend script, but if you do, we highly recommend that you
loudly announce your plans to Bitcoin users and developers so that
future upgrades don’t accidentally interfere with your system.</p>
</div>

<p>Bitcoin Core’s policy for relaying and mining transactions effectively
limits output scripts to just a few templates, <a data-type="indexterm" data-primary="standard transaction outputs" id="id840" target="_blank" rel="noopener noreferrer"></a>called <em>standard
transaction outputs</em>.  This was originally implemented after the
discovery of several early bugs in Bitcoin related to the Script
language and is retained in modern Bitcoin Core to support
anyone-can-spend upgrades and to encourage the best practice of placing
script conditions in P2SH redeem scripts, segwit v0 witness scripts, and
segwit v1 (taproot) leaf scripts.</p>

<p>We’ll look at each of the current standard transaction templates and
learn how to <a data-type="indexterm" data-primary="transactions" data-secondary="outputs" data-startref="transaction-output" id="id841" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="outputs" data-startref="output-transaction" id="id842" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="transactions" data-secondary="outputs" data-tertiary="output scripts" data-startref="transaction-output-script" id="id843" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="outputs" data-secondary="output scripts" data-startref="output-transaction-script" id="id844" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="output scripts" data-startref="output-script2" id="id845" target="_blank" rel="noopener noreferrer"></a>parse scripts in <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch07.html#c_authorization_authentication" target="_blank" rel="noopener noreferrer">Chapter&nbsp;7</a>.</p>
</div>
</div>






<div id="witness_structure" data-type="sect1" data-pdf-bookmark="Witness Structure">
<h2>Witness Structure</h2>

<p>In court,<a data-type="indexterm" data-primary="transactions" data-secondary="witnesses" id="transaction-witness" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="witnesses" id="witness" target="_blank" rel="noopener noreferrer"></a> a witness is someone who testifies that they saw something
important happen.  Human witnesses aren’t always reliable, so courts
have various processes for interrogating witnesses to (ideally) only
accept evidence from those who are reliable.</p>

<p>Imagine what a witness would look like for a math problem.  For example,
if the important problem was <em>x + 2 == 4</em> and someone claimed they
witnessed the solution, what would we ask them?  We’d want a
mathematical proof that showed a value that could be summed with two to
equal four.  We could even omit the need for a person and just use the
proposed value for <em>x</em> as our witness.  If we were told that the witness
was <em>two</em>, then we could fill in the equation, check that it was correct, and
decide that the important problem had been solved.</p>

<p>When spending bitcoins, the important problem we want to solve is
determining whether the spend was authorized by the person or people who
control those bitcoins.  The thousands of full nodes that enforce
Bitcoin’s consensus rules can’t interrogate human witnesses, but they can
accept <em>witnesses</em> that consist entirely of data for solving math
problems.  For example, a witness of <em>2</em> will allow spending bitcoins
protected by the following script:</p>



<p>Obviously, allowing your bitcoins to be spent by anyone who can solve a
simple equation wouldn’t be secure.  As we’ll see in <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch08.html#c_signatures" target="_blank" rel="noopener noreferrer">Chapter&nbsp;8</a>, an
unforgeable digital signature scheme uses an equation that can only be
solved by someone in possession of certain data they’re able to
keep secret.  They’re able to reference that secret data using a public
identifier.  That public identifier is <a data-type="indexterm" data-primary="public keys" id="id846" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="digital signatures" id="id847" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="signatures" data-see="digital signatures" id="id848" target="_blank" rel="noopener noreferrer"></a>called a <em>public key</em> and a
solution to the equation is called a <em>signature</em>.</p>

<p>The following script contains a public key and an opcode that requires
a corresponding signature commit to the data in the spending transaction.  Like
the number <em>2</em> in our simple example, the signature is our witness:</p>



<p>Witnesses, the values used to solve the math problems that protect
bitcoins, need to be included in the transactions where they’re used in
order for full nodes to verify them.  In the legacy transaction format
used for all early Bitcoin transactions, signatures and other data are
placed in the input script field.  However, when developers started to
implement contract protocols on Bitcoin, such as we saw in
<a data-type="xref" href="#original_tx_replacement" target="_blank" rel="noopener noreferrer">“Original sequence-based transaction replacement”</a>, they discovered several significant
problems with placing witnesses in the input script field.</p>








<div id="id98" data-type="sect2" data-pdf-bookmark="Circular Dependencies">
<h2>Circular Dependencies</h2>

<p>Many <a data-type="indexterm" data-primary="transactions" data-secondary="witnesses" data-tertiary="circular dependencies" id="transaction-witness-circular" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="witnesses" data-secondary="circular dependencies" id="witness-circular" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="circular dependencies" id="circular" target="_blank" rel="noopener noreferrer"></a>contract protocols for Bitcoin involve a series of transactions
that are signed out of order.  For example, Alice and Bob want to
deposit funds into a script that can only be spent with signatures from
both of them, but they each also want to get their money back if the
other person becomes unresponsive.  A simple solution is to sign
transactions out of order:</p>

<ul>
<li>
<p>Tx<sub>0</sub> pays money from Alice and money from Bob into an output with a
script that requires signatures from both Alice and Bob to spend.</p>
</li>
<li>
<p>Tx<sub>1</sub> spends the previous output to two outputs, one refunding Alice
her money and one refunding Bob his money (minus a small amount for
transaction fees).</p>
</li>
<li>
<p>If Alice and Bob sign Tx<sub>1</sub> before they sign Tx<sub>0</sub>, then they’re both
guaranteed to be able to get a refund at any time.  The protocol
doesn’t require either of them to trust the other, making <a data-type="indexterm" data-primary="trustless protocols" id="id849" target="_blank" rel="noopener noreferrer"></a>it a <em>trustless
protocol</em>.</p>
</li>
</ul>

<p>A problem with this construction in the legacy transaction format is
that every field, including the input script field that contains
signatures, is used to derive a 
<span>transaction’s</span> identifier (txid).  The
txid for Tx<sub>0</sub> is part of the input’s outpoint in Tx<sub>1</sub>.  That means
there’s no way for Alice and Bob to construct Tx<sub>1</sub> until both
signatures for Tx<sub>0</sub> are known—​but if they know the signatures for
Tx<sub>0</sub>, one of them can broadcast that transaction before signing the
refund transaction, eliminating the guarantee of a refund.  This is a
<em>circular dependency</em>.</p>
</div>








<div id="id99" data-type="sect2" data-pdf-bookmark="Third-Party Transaction Malleability">
<h2>Third-Party Transaction Malleability</h2>

<p>A more <a data-type="indexterm" data-primary="transactions" data-secondary="witnesses" data-tertiary="third-party transaction malleability" id="transaction-witness-third-party" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="witnesses" data-secondary="third-party transaction malleability" id="witness-circular-third-party" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="third-party transaction malleability" id="third-party" target="_blank" rel="noopener noreferrer"></a>complex series of transactions can sometimes eliminate a circular
dependency, but many protocols will then encounter a new concern: it’s
often possible to solve the same script in different ways.  For example,
consider our simple script from <a data-type="xref" href="#witness_structure" target="_blank" rel="noopener noreferrer">“Witness Structure”</a>:</p>



<p>We can make this script pass by providing the value <em>2</em> in an input script,
but there are several ways to put that value on the stack in Bitcoin.
Here are just a few:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">OP_2
OP_PUSH1 0x02
OP_PUSH2 0x0002
OP_PUSH3 0x000002
...
OP_PUSHDATA1 0x0102
OP_PUSHDATA1 0x020002
...
OP_PUSHDATA2 0x000102
OP_PUSHDATA2 0x00020002
...
OP_PUSHDATA4 0x0000000102
OP_PUSHDATA4 0x000000020002
...</pre></div>

<p>Each alternative encoding of the number <em>2</em> in an input script will produce
a slightly different transaction with a completely different txid.  Each
different version of the transaction spends the same inputs (outpoints)
as every other version of the transaction, making them all <em>conflict</em>
with each other.  Only one version of a set of conflicting transactions
can be contained within a valid blockchain.</p>

<p>Imagine Alice creates one version of the transaction with <code>OP_2</code> in the
input script and an output that pays Bob.  Bob then immediately spends that
output to Carol.  Anyone on the network can replace <code>OP_2</code> with
<code>OP_PUSH1 0x02</code>, creating a conflict with Alice’s original version.  If
that conflicting transaction is confirmed, then there’s no way to
include Alice’s original version in the same blockchain, which means
there’s no way for Bob’s transaction to spend its output.
Bob’s payment to Carol has been made invalid even though neither Alice,
Bob, nor Carol did anything wrong.  Someone not involved in the
transaction (a third party) was able to change (mutate) Alice’s
transaction, a problem called <em>unwanted third-party transaction
malleability</em>.</p>
<div data-type="tip"><h6>Tip</h6>
<p>There are cases when people want their transactions to be malleable and
Bitcoin provides several features to support that, most notably the
signature hashes (sighash) we’ll learn about in <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch08.html#sighash_types" target="_blank" rel="noopener noreferrer">“Signature Hash Types (SIGHASH)”</a>.  For
example, Alice can use a sighash to allow Bob to help her pay some
transaction fees.  This mutates Alice’s transaction but only in a way
that Alice wants.  For that reason, we will occasionally prefix the
word <em>unwanted</em> to the term <em>transaction malleability</em>.  Even when we
and other Bitcoin technical writers use the shorter term, we’re almost
certainly talking about the unwanted variant of<a data-type="indexterm" data-primary="transactions" data-secondary="witnesses" data-tertiary="third-party transaction malleability" data-startref="transaction-witness-third-party" id="id850" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="witnesses" data-secondary="third-party transaction malleability" data-startref="witness-circular-third-party" id="id851" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="third-party transaction malleability" data-startref="third-party" id="id852" target="_blank" rel="noopener noreferrer"></a> malleability.</p>
</div>
</div>








<div id="id100" data-type="sect2" data-pdf-bookmark="Second-Party Transaction Malleability">
<h2>Second-Party Transaction Malleability</h2>

<p>When the <a data-type="indexterm" data-primary="transactions" data-secondary="witnesses" data-tertiary="second-party transaction malleability" id="transaction-witness-second-party" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="witnesses" data-secondary="second-party transaction malleability" id="witness-circular-second-party" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="second-party transaction malleability" id="second-party" target="_blank" rel="noopener noreferrer"></a>legacy transaction format was the only transaction format,
developers worked on proposals to minimize third-party malleability,
such as BIP62.  However, even if they were able to entirely eliminate
third-party malleability, users of contract protocols faced another problem:
if they required a signature from someone else involved in the protocol,
that person could generate alternative signatures and change the txid.</p>

<p>For example, Alice and Bob have deposited their money into a script
requiring a signature from both of them to spend.  They’ve also created
a refund transaction that allows each of them to get their money back at
any time.  Alice decides she wants to spend just some of the
money, so she cooperates with Bob to create a chain of transactions:</p>

<ul>
<li>
<p>Tx<sub>0</sub> includes signatures from both Alice and Bob, spending its
bitcoins to two outputs.  The first output spends some of Alice’s
money; the second output returns the remainder of the bitcoins back to
the script requiring Alice and 
<span>Bob’s signatures.</span>  Before signing this
transaction, they create a new refund transaction, Tx<sub>1</sub>.</p>
</li>
<li>
<p>Tx<sub>1</sub> spends the second output of Tx<sub>0</sub> to two new outputs, one to
Alice for her share of the joint funds, and one to Bob for his share.
Alice and Bob both sign this transaction before they sign Tx<sub>0</sub>.</p>
</li>
</ul>

<p>There’s no circular dependency here and, if we ignore third-party
transaction malleability, this looks like it should provide us with a
trustless protocol.  However, it’s a property of Bitcoin signatures that
the signer has to choose a large random number when creating their
signature.  Choosing a different random number will produce a different
signature even if everything being signed stays the same.  It’s sort of
like how, if you provide a handwritten signature for two copies of the
same contract, each of those physical signatures will look slightly
different.</p>

<p>This mutability of signatures means that, if Alice tries to broadcast
Tx<sub>0</sub> (which contains Bob’s signature), Bob can generate an alternative
signature to create a conflicting transaction with a different txid.  If
Bob’s alternative version of Tx<sub>0</sub> gets confirmed, then Alice can’t use
the presigned version of Tx<sub>1</sub> to claim her refund.  This type of
mutation <a data-type="indexterm" data-primary="transactions" data-secondary="witnesses" data-tertiary="second-party transaction malleability" data-startref="transaction-witness-second-party" id="id853" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="witnesses" data-secondary="second-party transaction malleability" data-startref="witness-circular-second-party" id="id854" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="second-party transaction malleability" data-startref="second-party" id="id855" target="_blank" rel="noopener noreferrer"></a>is called <em>unwanted second-party transaction malleability</em>.</p>
</div>








<div id="segwit" data-type="sect2" data-pdf-bookmark="Segregated Witness">
<h2>Segregated Witness</h2>

<p>As <a data-type="indexterm" data-primary="transactions" data-secondary="witnesses" data-tertiary="segregated witness" id="transaction-witness-segwit" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="witnesses" data-secondary="segregated witness" id="witness-segwit" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="segregated witness (segwit)" id="segregated-witness-segwit" target="_blank" rel="noopener noreferrer"></a>early as <a href="https://oreil.ly/---bp" target="_blank" rel="noopener noreferrer">2011</a>,
protocol developers knew how to solve the problems of circular
dependence, third-party malleability, and second-party malleability.  The
idea was to avoid including the input script in the calculation that
produces a transaction’s txid.  Recall that an abstract name for the data
held by an input script is a <em>witness</em>.  The idea of separating the rest of
the data in a transaction from its witness for the purpose of generating
a txid is called <em>segregated witness</em> (segwit).</p>

<p>The obvious method for implementing segwit requires a
change to Bitcoin’s consensus rules that would not be compatible with
older full nodes, also <a data-type="indexterm" data-primary="hard forks" id="id856" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="forks" data-secondary="hard forks" id="id857" target="_blank" rel="noopener noreferrer"></a>called
a <em>hard fork</em>.  Hard forks come with a lot of challenges, as we’ll
discuss further in <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch12.html#hard_forks" target="_blank" rel="noopener noreferrer">“Hard Forks”</a>.</p>

<p>An alternative approach to segwit was described in late 2015.  This
would use a backward-compatible change to the consensus rules, <a data-type="indexterm" data-primary="soft forks" id="id858" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="forks" data-secondary="soft forks" id="id859" target="_blank" rel="noopener noreferrer"></a>called a
<em>soft fork</em>.  Backward compatible means that full nodes implementing
the change must not accept any blocks that full nodes without the change
would consider invalid.  As long as they obey that rule, newer full
nodes can reject blocks that older full nodes would accept, giving them
the ability to enforce new consensus rules (but only if the newer full
nodes represent the economic consensus among Bitcoin users—​we’ll
explore the details of upgrading Bitcoin’s consensus rules in
<a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch12.html#mining" target="_blank" rel="noopener noreferrer">Chapter&nbsp;12</a>).</p>

<p>The soft fork segwit approach is based on anyone-can-spend
output scripts.  A script that starts with any of the numbers 0 to 16
and followed by 2 to 40 bytes of data is defined as a segwit
output script template.  The number indicates its version (e.g., 0 is
segwit version 0, or <em>segwit v0</em>).  The data is called a <em>witness
program</em>.  It’s also possible to wrap the segwit template in a P2SH
commitment, but we won’t deal with that in this chapter.</p>

<p>From the perspective of old nodes, these output script templates can be
spent with an empty input script.  From the perspective of a new node that
is aware of the new segwit rules, any payment to a segwit output script
template must only be spent with an empty input script.  Notice the
difference here: old nodes <em>allow</em> an empty input script; new nodes
<em>require</em> an empty input script.</p>

<p>An empty input script keeps witnesses from affecting the txid, eliminating
circular dependencies, third-party transaction malleability, and
second-party transaction malleability.  But, with no ability to put
data in an input script, users of segwit output script templates need a
new field.  That field is called the <em>witness structure</em>.</p>

<p>The introduction of witness programs and the witness structure complicates Bitcoin,
but it follows an existing trend of increasing abstraction.  Recall from
<a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch04.html#ch04_keys_addresses" target="_blank" rel="noopener noreferrer">Chapter&nbsp;4</a> that the original Bitcoin whitepaper describes a system
where bitcoins were received to public keys (pubkeys) and spent with
signatures (sigs).  The public key defined who was <em>authorized</em> to spend
the bitcoins (whoever controlled the corresponding private key) and the
signature provided <em>authentication</em> that the spending transaction came
from someone who controlled the private key.  To make that system more
flexible, the initial release of Bitcoin introduced scripts that allow
bitcoins to be received to output scripts and spent with input scripts.
Later experience with contract protocols inspired allowing bitcoins to
be received to witness programs and spent with the witness structure. The terms and fields used in different versions of Bitcoin<a data-type="indexterm" data-primary="transactions" data-secondary="witnesses" data-tertiary="segregated witness" data-startref="transaction-witness-segwit" id="id860" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="witnesses" data-secondary="segregated witness" data-startref="witness-segwit" id="id861" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="segregated witness (segwit)" data-startref="segregated-witness-segwit" id="id862" target="_blank" rel="noopener noreferrer"></a> are shown in <a data-type="xref" href="#terms_used_authorization_authentication" target="_blank" rel="noopener noreferrer">Table&nbsp;6-1</a>.</p>
<table id="terms_used_authorization_authentication"><caption><span>Table 6-1. </span>Terms used for authorization and authentication data in different parts of Bitcoin</caption><thead><tr><th></th><th><p>Authorization</p></th><th><p>Authentication</p></th></tr></thead><tbody><tr><td><p><strong>Whitepaper</strong></p></td><td><p>Public key</p></td><td><p>Signature</p></td></tr><tr><td><p><strong>Original (Legacy)</strong></p></td><td><p>Output script</p></td><td><p>Input script</p></td></tr><tr><td><p><strong>Segwit</strong></p></td><td><p>Witness program</p></td><td><p>Witness structure</p></td></tr></tbody></table>
</div>








<div id="id102" data-type="sect2" data-pdf-bookmark="Witness Structure Serialization">
<h2>Witness Structure Serialization</h2>

<p>Similar to<a data-type="indexterm" data-primary="transactions" data-secondary="witnesses" data-tertiary="count" id="transaction-witness-count" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="witnesses" data-secondary="count" id="witness-count" target="_blank" rel="noopener noreferrer"></a> the inputs and outputs fields, the witness structure contains
other fields, so we’ll start with a map of those bytes from
Alice’s transaction in <a data-type="xref" href="#alice_tx_witness_map" target="_blank" rel="noopener noreferrer">Figure&nbsp;6-5</a>.</p>

<figure><div id="alice_tx_witness_map">
<p><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098150082/files/assets/mbc3_0605.png" alt="" width="600" height="230"></p><h6><span>Figure 6-5. </span>A byte map of the witness structure from Alice’s transaction.</h6>
</div></figure>

<p>Unlike the inputs and outputs fields, the overall witness structure doesn’t
start with any indication of the total number of witness stacks it contains.
Instead, this is implied by the inputs field—​there’s one witness
stack for every input in a transaction.</p>

<p>The witness structure for a particular input does start with a count of the
number of elements they contain.  Those elements are <a data-type="indexterm" data-primary="witness items" id="id863" target="_blank" rel="noopener noreferrer"></a>called <em>witness
items</em>.  We’ll explore them in detail in
<a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch07.html#c_authorization_authentication" target="_blank" rel="noopener noreferrer">Chapter&nbsp;7</a>, but for now we need to know that
each witness item is prefixed by a compactSize integer indicating its
size.</p>

<p>Legacy inputs don’t contain any witness items, so their witness stack
consists entirely of a count of zero (0x00).</p>

<p>Alice’s transaction contains one input and one <a data-type="indexterm" data-primary="transactions" data-secondary="witnesses" data-startref="transaction-witness" id="id864" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="witnesses" data-startref="witness" id="id865" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="transactions" data-secondary="witnesses" data-tertiary="count" data-startref="transaction-witness-count" id="id866" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="witnesses" data-secondary="count" data-startref="witness-count" id="id867" target="_blank" rel="noopener noreferrer"></a>witness item.</p>
</div>
</div>






<div id="lock_time" data-type="sect1" data-pdf-bookmark="Lock Time">
<h2>Lock Time</h2>

<p>The <a data-type="indexterm" data-primary="transactions" data-secondary="lock time" id="id868" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="lock time" id="id869" target="_blank" rel="noopener noreferrer"></a>final field in a serialized transaction is its lock time.  This
field was part of Bitcoin’s original serialization format, but it was
initially only enforced by Bitcoin’s policy for choosing which
transactions to mine.  Bitcoin’s earliest known soft fork added a rule
that, starting at block height 31,000, forbid the inclusion of a
transaction in a block unless it satisfies one of the following rules:</p>

<ul>
<li>
<p>The transaction indicates that it should be eligible for inclusion in
any block by setting its lock time to 0.</p>
</li>
<li>
<p>The transaction indicates that it wants to restrict which blocks it
can be included in by setting its lock time to a value less than
500,000,000.  In this case, the transaction can only be included in a
block that has a height equal to the lock time or higher.  For
example, a transaction with a lock time of 123,456 can be included in
block 123,456 or any later block.</p>
</li>
<li>
<p>The transaction indicates that it wants to restrict when it can be
included in the blockchain by setting its lock time to a value of
500,000,000 or greater.  In this case, the field is parsed as epoch
time (the number of seconds since 1970-01-01T00:00 UTC) and the
transaction can only be included in a <a data-type="indexterm" data-primary="median time past (MTP)" id="id870" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="MTP (median time past)" id="id871" target="_blank" rel="noopener noreferrer"></a>block with a <em>median time past</em>
(MTP) greater than the lock time.  MTP is normally about an hour or
two behind the current time.  The rules for MTP are described in
<a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch12.html#mtp" target="_blank" rel="noopener noreferrer">“Median Time Past (MTP)”</a>.</p>
</li>
</ul>
</div>






<div id="coinbase_transactions" data-type="sect1" data-pdf-bookmark="Coinbase Transactions">
<h2>Coinbase Transactions</h2>

<p>The first <a data-type="indexterm" data-primary="transactions" data-secondary="coinbase" id="transaction-coinbase2" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="coinbase transactions" id="coinbase-transaction" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="generation transactions" id="id872" target="_blank" rel="noopener noreferrer"></a>transaction in each block is a special case.  Most older
documentation calls this a <em>generation transaction</em>, but most newer
documentation calls it a <em>coinbase transaction</em> (not to be confused with
transactions created by the company named “Coinbase”).</p>

<p>Coinbase transactions are created by the miner of the block that
includes them and gives the miner the option to claim any fees paid by
transactions in that block.  Additionally, up until block 6,720,000,
miners are allowed to claim a subsidy consisting of bitcoins that have
never previously been circulated, called <a data-type="indexterm" data-primary="block subsidy" id="id873" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="block reward" id="id874" target="_blank" rel="noopener noreferrer"></a>the <em>block subsidy</em>.  The total
amount a miner can claim for a block—​the combination of fees and
subsidy—​is called the <em>block reward</em>.</p>

<p>Some of the special rules for coinbase transactions include:</p>

<ul>
<li>
<p>They may only have one input.</p>
</li>
<li>
<p>The single input must have an outpoint with a null txid (consisting entirely
of zeros) and a maximal output index (0xffffffff).  This prevents the
coinbase transaction from referencing a previous transaction output,
which would (at the very least) be confusing given that the coinbase
transaction pays out fees and subsidy.</p>
</li>
<li>
<p>The field that would contain an input script in a normal transaction is
called a <em>coinbase</em>.  It’s this field that gives the coinbase
transaction its name.  The coinbase field must be at least two bytes
and not longer than 100 bytes.  This script is not executed but legacy
transaction limits on the number of signature-checking operations
(sigops) do apply to it, so any arbitrary data placed in it should be
prefixed by a data-pushing opcode.  Since a 2013 soft fork defined in
BIP34, the first few bytes of this field must follow additional rules
we’ll describe in <a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch12.html#duplicate_transactions" target="_blank" rel="noopener noreferrer">“Coinbase Data”</a>.</p>
</li>
<li>
<p>The sum of the outputs must not exceed the value of the fees collected
from all the transactions in that block plus the subsidy.  The subsidy
started at 50 BTC per block and halves every 210,000 blocks
(approximately every four years).  Subsidy values are rounded down to the
nearest satoshi.</p>
</li>
<li>
<p>Since the 2017 segwit soft fork documented in BIP141, any block that contains
a transaction spending a segwit output must contain an output to the
coinbase transaction that commits to all of the transactions in the
block (including their witnesses).  We’ll explore this commitment in
<a data-type="xref" href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch12.html#mining" target="_blank" rel="noopener noreferrer">Chapter&nbsp;12</a>.</p>
</li>
</ul>

<p>A coinbase transaction can have any other outputs that would be valid in
a normal transaction.  However, a transaction spending one of those
outputs cannot be included in any block until after the coinbase
transaction has received 100 confirmations.  This is called the
<em>maturity rule</em>, and <a data-type="indexterm" data-primary="maturity rule" id="id875" target="_blank" rel="noopener noreferrer"></a>coinbase transaction outputs that don’t yet have
100 confirmations are called <em>immature</em>.</p>

<p>Most Bitcoin software doesn’t need to deal with coinbase transactions,
but their special nature does mean they can occasionally be the cause of
unusual problems in software that’s not designed to expect<a data-type="indexterm" data-primary="transactions" data-secondary="coinbase" data-startref="transaction-coinbase2" id="id876" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="coinbase transactions" data-startref="coinbase-transaction" id="id877" target="_blank" rel="noopener noreferrer"></a> them.</p>
</div>






<div id="id105" data-type="sect1" data-pdf-bookmark="Weight and Vbytes">
<h2>Weight and Vbytes</h2>

<p>Each <a data-type="indexterm" data-primary="transactions" data-secondary="weights" id="transactions-weight" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="weights (of transactions)" id="weights" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="vbytes" id="vbytes" target="_blank" rel="noopener noreferrer"></a>Bitcoin block is limited in the amount of transaction data it can
contain, so most Bitcoin software needs to be able to measure the
transactions it creates or processes.  The modern unit of measurement
for Bitcoin is called <em>weight</em>.  An alternative version of weight is
<em>vbytes</em>, where four units of weight equal one vbyte, providing an easy
comparison to the original <em>byte</em> measurement unit used in legacy
Bitcoin blocks.</p>

<p>Blocks are limited to 4 million weight.  The block header takes up 240
weight.  An additional field, the transaction count, uses either 4 or
12 weight.  All of the remaining weight may be used for transaction
data.</p>

<p>To calculate the weight of a particular field in a transaction, the size
of that serialized field in bytes is multiplied by a factor.  To
calculate the weight of a transaction, sum together the weights of all
of its fields.  The factors for each of the fields in a transaction are
shown in <a data-type="xref" href="#weight_factors" target="_blank" rel="noopener noreferrer">Table&nbsp;6-2</a>.  To provide an example, we also calculate
the weight of each field in this chapter’s example transaction from
Alice to Bob.</p>

<p>The factors, and the fields to which they are applied, were chosen to
reduce the weight used when spending a UTXO.  This helps discourage the
creation of uneconomical outputs as described in
<a data-type="xref" href="#uneconomical_outputs" target="_blank" rel="noopener noreferrer">“Uneconomical outputs and disallowed dust”</a>.</p>
<table id="weight_factors"><caption><span>Table 6-2. </span>Weight factors for all fields in a Bitcoin transaction</caption><thead><tr><th><p>Field</p></th><th><p>Factor</p></th><th><p>Weight in Alice’s Tx</p></th></tr></thead><tbody><tr><td><p>Version</p></td><td><p>4</p></td><td><p>16</p></td></tr><tr><td><p>Marker &amp; Flag</p></td><td><p>1</p></td><td><p>2</p></td></tr><tr><td><p>Inputs Count</p></td><td><p>4</p></td><td><p>4</p></td></tr><tr><td><p>Outpoint</p></td><td><p>4</p></td><td><p>144</p></td></tr><tr><td><p>Input script</p></td><td><p>4</p></td><td><p>4</p></td></tr><tr><td><p>Sequence</p></td><td><p>4</p></td><td><p>16</p></td></tr><tr><td><p>Outputs Count</p></td><td><p>4</p></td><td><p>4</p></td></tr><tr><td><p>Amount</p></td><td><p>4</p></td><td><p>64 (2 outputs)</p></td></tr><tr><td><p>Output script</p></td><td><p>4</p></td><td><p>232 (2 outputs with different scripts)</p></td></tr><tr><td><p>Witness Count</p></td><td><p>1</p></td><td><p>1</p></td></tr><tr><td><p>Witness items</p></td><td><p>1</p></td><td><p>66</p></td></tr><tr><td><p>Lock time</p></td><td><p>4</p></td><td><p>16</p></td></tr><tr><td><p><strong>Total</strong></p></td><td><p><em>N/A</em></p></td><td><p><strong>569</strong></p></td></tr></tbody></table>

<p>We can verify our weight calculation by getting the total for Alice’s
transaction from Bitcoin Core:</p>

<div data-testid="custom pre block"><pre data-type="programlisting">$ bitcoin-cli getrawtransaction 466200308696215bbc949d5141a49a41\
38ecdfdfaa2a8029c1f9bcecd1f96177 2 | jq .weight
569</pre></div>

<p>Alice’s transaction from <a data-type="xref" href="#alice_tx_serialized_reprint" target="_blank" rel="noopener noreferrer">Example&nbsp;6-1</a> at the beginning of
this chapter is shown represented in weight units in
<a data-type="xref" href="#alice_tx_weight_map" target="_blank" rel="noopener noreferrer">Figure&nbsp;6-6</a>.  You can see the factor at work by comparing
the difference in size between the various fields in the <a data-type="indexterm" data-primary="transactions" data-secondary="weights" data-startref="transactions-weight" id="id878" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="weights (of transactions)" data-startref="weights" id="id879" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="vbytes" data-startref="vbytes" id="id880" target="_blank" rel="noopener noreferrer"></a>two images.</p>

<figure><div id="alice_tx_weight_map">
<p><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098150082/files/assets/mbc3_0606.png" alt="" width="600" height="337"></p><h6><span>Figure 6-6. </span>A byte map of Alice’s transaction.</h6>
</div></figure>
</div>






<div id="legacy_serialization" data-type="sect1" data-pdf-bookmark="Legacy Serialization">
<h2>Legacy Serialization</h2>

<p>The <a data-type="indexterm" data-primary="transactions" data-secondary="legacy serialization" id="id881" target="_blank" rel="noopener noreferrer"></a><a data-type="indexterm" data-primary="legacy serialization" id="id882" target="_blank" rel="noopener noreferrer"></a>serialization format described in this chapter is used for the
majority of new Bitcoin transactions as of the writing of this book, but
an older serialization format is still used for many transactions.  That
older format, called <em>legacy serialization</em>, must be used on the Bitcoin
P2P network for any transaction with an empty witness structure (which is only
valid if the transaction doesn’t spend any witness programs).</p>

<p>Legacy serialization does not include the marker, flag, and witness structure
fields.</p>
<p>
In this chapter, we looked at each of the fields in a transaction and
discovered how they communicate to full nodes the details about the
bitcoins to be transferred between users.  We only briefly looked at the
output script, input script, and witness structure that allow specifying and
satisfying conditions that restrict who can spend what bitcoins.
Understanding how to construct and use these conditions is essential to
ensuring that only Alice can spend her bitcoins, so they will be the
subject of the next chapter.</p>
</div>
</div></div>
  <span></span> <!-- for IntersectionObserver -->
  
  
  
  


<style id="note-styling">
    .note {
      position: absolute;
      z-index: 10;
      border: none;
      outline: none;
      font-family: inherit;
      font-size: inherit;
      padding: 5px;
      min-width: 32px;
      min-height: 32px;
    }
    .note:focus {
      z-index: 11;
    }
    .note[type="0"] {
      background-color: #fff740;
      color: #2c2c2d;
    }
    .note[type="0"]::placeholder {
      color: #868226;
    }
    .note[type="1"] {
      background-color: #feff9c;
      color: #2c2c2d;
    }
    .note[type="1"]::placeholder {
      color: #6d6d3d;
    }
    .note[type="2"] {
      background-color: #ff65a3;
      color: #2c2c2d;
    }
    .note[type="2"]::placeholder {
      color: #65263f;
    }
    .note[type="3"] {
      background-color: #ff7eb9;
      color: #2c2c2d;
    }
    .note[type="3"]::placeholder {
      color: #562b3f;
    }
    .note[type="4"] {
      background-color: #7afcff;
      color: #295c5d;
    }
    .note[type="4"]::placeholder {
      color: #377677;
    }</style><div id="chapters-container">
      <style>
        #chapters {
          display: grid;
          grid-template-columns: 1fr 1fr;
          margin: 2ch 0;
        }
        #chapters a {
          cursor: pointer;
        }
        #chapters a[href=""] {
          opacity: 0.5;
          pointer-events: none;
          color: inherit;
        }
        #chapters a:first-child {
          justify-self: start;
        }
        #chapters a:last-child {
          justify-self: end;
        }
      </style>
      <hr>
      <div id="chapters">
        <a href="" title="move to the previous chapter (Ctrl/Command + PageUp)">Previous Chapter</a>
        <a href="https://learning.oreilly.com/library/view/mastering-bitcoin-3rd/9781098150082/ch07.html" title="move to the next chapter (Ctrl/Command + PageDown)">Next Chapter</a>
      </div>
    </div></body><style>body {
      font-size:  19px;
      font-family: Georgia, 'Times New Roman', serif;
      width: 600px;
    }
    p {
      text-align: justify
    }
    .page {
      line-height: 28.5px;
      column-count: unset;
    }
    h1, h2, h3 {
      line-height: initial;
    }</style></html>